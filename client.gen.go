// Package lemmy provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package lemmy

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"

	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	BearerAuthScopes = "bearerAuth.Scopes"
)

// Defines values for CommentSortType.
const (
	CommentSortTypeControversial CommentSortType = "Controversial"
	CommentSortTypeHot           CommentSortType = "Hot"
	CommentSortTypeNew           CommentSortType = "New"
	CommentSortTypeOld           CommentSortType = "Old"
	CommentSortTypeTop           CommentSortType = "Top"
)

// Defines values for CommunitySortType.
const (
	CommunitySortTypeActiveDaily      CommunitySortType = "ActiveDaily"
	CommunitySortTypeActiveMonthly    CommunitySortType = "ActiveMonthly"
	CommunitySortTypeActiveSixMonths  CommunitySortType = "ActiveSixMonths"
	CommunitySortTypeActiveWeekly     CommunitySortType = "ActiveWeekly"
	CommunitySortTypeComments         CommunitySortType = "Comments"
	CommunitySortTypeHot              CommunitySortType = "Hot"
	CommunitySortTypeNameAsc          CommunitySortType = "NameAsc"
	CommunitySortTypeNameDesc         CommunitySortType = "NameDesc"
	CommunitySortTypeNew              CommunitySortType = "New"
	CommunitySortTypeOld              CommunitySortType = "Old"
	CommunitySortTypePosts            CommunitySortType = "Posts"
	CommunitySortTypeSubscribers      CommunitySortType = "Subscribers"
	CommunitySortTypeSubscribersLocal CommunitySortType = "SubscribersLocal"
)

// Defines values for CommunityVisibility.
const (
	LocalOnly CommunityVisibility = "LocalOnly"
	Private   CommunityVisibility = "Private"
	Public    CommunityVisibility = "Public"
)

// Defines values for FederationMode.
const (
	FederationModeAll     FederationMode = "All"
	FederationModeDisable FederationMode = "Disable"
	FederationModeLocal   FederationMode = "Local"
)

// Defines values for InboxCombinedView0Type.
const (
	InboxCombinedView0TypeCommentReply InboxCombinedView0Type = "CommentReply"
)

// Defines values for InboxCombinedView1Type.
const (
	CommentMention InboxCombinedView1Type = "CommentMention"
)

// Defines values for InboxCombinedView2Type.
const (
	PostMention InboxCombinedView2Type = "PostMention"
)

// Defines values for InboxCombinedView3Type.
const (
	InboxCombinedView3TypePrivateMessage InboxCombinedView3Type = "PrivateMessage"
)

// Defines values for InboxDataType.
const (
	InboxDataTypeAll            InboxDataType = "All"
	InboxDataTypeCommentMention InboxDataType = "CommentMention"
	InboxDataTypeCommentReply   InboxDataType = "CommentReply"
	InboxDataTypePostMention    InboxDataType = "PostMention"
	InboxDataTypePrivateMessage InboxDataType = "PrivateMessage"
)

// Defines values for ListingType.
const (
	ListingTypeAll           ListingType = "All"
	ListingTypeLocal         ListingType = "Local"
	ListingTypeModeratorView ListingType = "ModeratorView"
	ListingTypeSubscribed    ListingType = "Subscribed"
)

// Defines values for ModlogActionType.
const (
	ModlogActionTypeAdminAllowInstance   ModlogActionType = "AdminAllowInstance"
	ModlogActionTypeAdminBlockInstance   ModlogActionType = "AdminBlockInstance"
	ModlogActionTypeAdminPurgeComment    ModlogActionType = "AdminPurgeComment"
	ModlogActionTypeAdminPurgeCommunity  ModlogActionType = "AdminPurgeCommunity"
	ModlogActionTypeAdminPurgePerson     ModlogActionType = "AdminPurgePerson"
	ModlogActionTypeAdminPurgePost       ModlogActionType = "AdminPurgePost"
	ModlogActionTypeAll                  ModlogActionType = "All"
	ModlogActionTypeModAdd               ModlogActionType = "ModAdd"
	ModlogActionTypeModAddCommunity      ModlogActionType = "ModAddCommunity"
	ModlogActionTypeModBan               ModlogActionType = "ModBan"
	ModlogActionTypeModBanFromCommunity  ModlogActionType = "ModBanFromCommunity"
	ModlogActionTypeModFeaturePost       ModlogActionType = "ModFeaturePost"
	ModlogActionTypeModHideCommunity     ModlogActionType = "ModHideCommunity"
	ModlogActionTypeModLockPost          ModlogActionType = "ModLockPost"
	ModlogActionTypeModRemoveComment     ModlogActionType = "ModRemoveComment"
	ModlogActionTypeModRemoveCommunity   ModlogActionType = "ModRemoveCommunity"
	ModlogActionTypeModRemovePost        ModlogActionType = "ModRemovePost"
	ModlogActionTypeModTransferCommunity ModlogActionType = "ModTransferCommunity"
)

// Defines values for ModlogCombinedView0Type.
const (
	ModlogCombinedView0TypeAdminAllowInstance ModlogCombinedView0Type = "AdminAllowInstance"
)

// Defines values for ModlogCombinedView1Type.
const (
	ModlogCombinedView1TypeAdminBlockInstance ModlogCombinedView1Type = "AdminBlockInstance"
)

// Defines values for ModlogCombinedView2Type.
const (
	ModlogCombinedView2TypeAdminPurgeComment ModlogCombinedView2Type = "AdminPurgeComment"
)

// Defines values for ModlogCombinedView3Type.
const (
	ModlogCombinedView3TypeAdminPurgeCommunity ModlogCombinedView3Type = "AdminPurgeCommunity"
)

// Defines values for ModlogCombinedView4Type.
const (
	ModlogCombinedView4TypeAdminPurgePerson ModlogCombinedView4Type = "AdminPurgePerson"
)

// Defines values for ModlogCombinedView5Type.
const (
	ModlogCombinedView5TypeAdminPurgePost ModlogCombinedView5Type = "AdminPurgePost"
)

// Defines values for ModlogCombinedView6Type.
const (
	ModlogCombinedView6TypeModAdd ModlogCombinedView6Type = "ModAdd"
)

// Defines values for ModlogCombinedView7Type.
const (
	ModlogCombinedView7TypeModAddCommunity ModlogCombinedView7Type = "ModAddCommunity"
)

// Defines values for ModlogCombinedView8Type.
const (
	ModlogCombinedView8TypeModBan ModlogCombinedView8Type = "ModBan"
)

// Defines values for ModlogCombinedView9Type.
const (
	ModlogCombinedView9TypeModBanFromCommunity ModlogCombinedView9Type = "ModBanFromCommunity"
)

// Defines values for ModlogCombinedView10Type.
const (
	ModlogCombinedView10TypeModFeaturePost ModlogCombinedView10Type = "ModFeaturePost"
)

// Defines values for ModlogCombinedView11Type.
const (
	ModlogCombinedView11TypeModHideCommunity ModlogCombinedView11Type = "ModHideCommunity"
)

// Defines values for ModlogCombinedView12Type.
const (
	ModlogCombinedView12TypeModLockPost ModlogCombinedView12Type = "ModLockPost"
)

// Defines values for ModlogCombinedView13Type.
const (
	ModlogCombinedView13TypeModRemoveComment ModlogCombinedView13Type = "ModRemoveComment"
)

// Defines values for ModlogCombinedView14Type.
const (
	ModlogCombinedView14TypeModRemoveCommunity ModlogCombinedView14Type = "ModRemoveCommunity"
)

// Defines values for ModlogCombinedView15Type.
const (
	ModlogCombinedView15TypeModRemovePost ModlogCombinedView15Type = "ModRemovePost"
)

// Defines values for ModlogCombinedView16Type.
const (
	ModlogCombinedView16TypeModTransferCommunity ModlogCombinedView16Type = "ModTransferCommunity"
)

// Defines values for PersonContentCombinedView0Type.
const (
	PersonContentCombinedView0TypePost PersonContentCombinedView0Type = "Post"
)

// Defines values for PersonContentCombinedView1Type.
const (
	PersonContentCombinedView1TypeComment PersonContentCombinedView1Type = "Comment"
)

// Defines values for PersonContentType.
const (
	PersonContentTypeAll      PersonContentType = "All"
	PersonContentTypeComments PersonContentType = "Comments"
	PersonContentTypePosts    PersonContentType = "Posts"
)

// Defines values for PostFeatureType.
const (
	PostFeatureTypeCommunity PostFeatureType = "Community"
	PostFeatureTypeLocal     PostFeatureType = "Local"
)

// Defines values for PostListingMode.
const (
	Card      PostListingMode = "Card"
	List      PostListingMode = "List"
	SmallCard PostListingMode = "SmallCard"
)

// Defines values for PostSortType.
const (
	PostSortTypeActive        PostSortType = "Active"
	PostSortTypeControversial PostSortType = "Controversial"
	PostSortTypeHot           PostSortType = "Hot"
	PostSortTypeMostComments  PostSortType = "MostComments"
	PostSortTypeNew           PostSortType = "New"
	PostSortTypeNewComments   PostSortType = "NewComments"
	PostSortTypeOld           PostSortType = "Old"
	PostSortTypeScaled        PostSortType = "Scaled"
	PostSortTypeTop           PostSortType = "Top"
)

// Defines values for RegistrationMode.
const (
	Closed             RegistrationMode = "Closed"
	Open               RegistrationMode = "Open"
	RequireApplication RegistrationMode = "RequireApplication"
)

// Defines values for ReportCombinedView0Type.
const (
	ReportCombinedView0TypePost ReportCombinedView0Type = "Post"
)

// Defines values for ReportCombinedView1Type.
const (
	ReportCombinedView1TypeComment ReportCombinedView1Type = "Comment"
)

// Defines values for ReportCombinedView2Type.
const (
	ReportCombinedView2TypePrivateMessage ReportCombinedView2Type = "PrivateMessage"
)

// Defines values for ReportCombinedView3Type.
const (
	ReportCombinedView3TypeCommunity ReportCombinedView3Type = "Community"
)

// Defines values for ReportType.
const (
	ReportTypeAll             ReportType = "All"
	ReportTypeComments        ReportType = "Comments"
	ReportTypeCommunities     ReportType = "Communities"
	ReportTypePosts           ReportType = "Posts"
	ReportTypePrivateMessages ReportType = "PrivateMessages"
)

// Defines values for SearchCombinedView0Type.
const (
	SearchCombinedView0TypePost SearchCombinedView0Type = "Post"
)

// Defines values for SearchCombinedView1Type.
const (
	SearchCombinedView1TypeComment SearchCombinedView1Type = "Comment"
)

// Defines values for SearchCombinedView2Type.
const (
	SearchCombinedView2TypeCommunity SearchCombinedView2Type = "Community"
)

// Defines values for SearchCombinedView3Type.
const (
	SearchCombinedView3TypePerson SearchCombinedView3Type = "Person"
)

// Defines values for SearchSortType.
const (
	SearchSortTypeNew SearchSortType = "New"
	SearchSortTypeOld SearchSortType = "Old"
	SearchSortTypeTop SearchSortType = "Top"
)

// Defines values for SearchType.
const (
	All         SearchType = "All"
	Comments    SearchType = "Comments"
	Communities SearchType = "Communities"
	Posts       SearchType = "Posts"
	Users       SearchType = "Users"
)

// Defines values for SubscribedType.
const (
	ApprovalRequired SubscribedType = "ApprovalRequired"
	NotSubscribed    SubscribedType = "NotSubscribed"
	Pending          SubscribedType = "Pending"
	Subscribed       SubscribedType = "Subscribed"
)

// ActivityId defines model for ActivityId.
type ActivityId = float64

// AddAdmin Adds an admin to a site.
type AddAdmin struct {
	Added bool `json:"added"`

	// PersonId The person id.
	PersonId PersonId `json:"person_id"`
}

// AddAdminResponse The response of current admins.
type AddAdminResponse struct {
	Admins []PersonView `json:"admins"`
}

// AddModToCommunity Add a moderator to a community.
type AddModToCommunity struct {
	Added bool `json:"added"`

	// CommunityId The community id.
	CommunityId CommunityId `json:"community_id"`

	// PersonId The person id.
	PersonId PersonId `json:"person_id"`
}

// AddModToCommunityResponse The response of adding a moderator to a community.
type AddModToCommunityResponse struct {
	Moderators []CommunityModeratorView `json:"moderators"`
}

// AdminAllowInstance defines model for AdminAllowInstance.
type AdminAllowInstance struct {
	// AdminPersonId The person id.
	AdminPersonId PersonId             `json:"admin_person_id"`
	Allowed       bool                 `json:"allowed"`
	Id            AdminAllowInstanceId `json:"id"`

	// InstanceId The instance id.
	InstanceId InstanceId `json:"instance_id"`
	Published  string     `json:"published"`
	Reason     *string    `json:"reason,omitempty"`
}

// AdminAllowInstanceId defines model for AdminAllowInstanceId.
type AdminAllowInstanceId = float64

// AdminAllowInstanceParams defines model for AdminAllowInstanceParams.
type AdminAllowInstanceParams struct {
	Allow    bool    `json:"allow"`
	Instance string  `json:"instance"`
	Reason   *string `json:"reason,omitempty"`
}

// AdminAllowInstanceView When an admin purges a post.
type AdminAllowInstanceView struct {
	// Admin A person.
	Admin              *Person            `json:"admin,omitempty"`
	AdminAllowInstance AdminAllowInstance `json:"admin_allow_instance"`

	// Instance A federated instance / site.
	Instance Instance `json:"instance"`
}

// AdminBlockInstance defines model for AdminBlockInstance.
type AdminBlockInstance struct {
	// AdminPersonId The person id.
	AdminPersonId PersonId             `json:"admin_person_id"`
	Blocked       bool                 `json:"blocked"`
	Expires       *string              `json:"expires,omitempty"`
	Id            AdminBlockInstanceId `json:"id"`

	// InstanceId The instance id.
	InstanceId InstanceId `json:"instance_id"`
	Published  string     `json:"published"`
	Reason     *string    `json:"reason,omitempty"`
}

// AdminBlockInstanceId defines model for AdminBlockInstanceId.
type AdminBlockInstanceId = float64

// AdminBlockInstanceParams defines model for AdminBlockInstanceParams.
type AdminBlockInstanceParams struct {
	Block    bool    `json:"block"`
	Expires  *string `json:"expires,omitempty"`
	Instance string  `json:"instance"`
	Reason   *string `json:"reason,omitempty"`
}

// AdminBlockInstanceView When an admin purges a post.
type AdminBlockInstanceView struct {
	// Admin A person.
	Admin              *Person            `json:"admin,omitempty"`
	AdminBlockInstance AdminBlockInstance `json:"admin_block_instance"`

	// Instance A federated instance / site.
	Instance Instance `json:"instance"`
}

// AdminPurgeComment When an admin purges a comment.
type AdminPurgeComment struct {
	// AdminPersonId The person id.
	AdminPersonId PersonId            `json:"admin_person_id"`
	Id            AdminPurgeCommentId `json:"id"`

	// PostId The post id.
	PostId    PostId  `json:"post_id"`
	Published string  `json:"published"`
	Reason    *string `json:"reason,omitempty"`
}

// AdminPurgeCommentId defines model for AdminPurgeCommentId.
type AdminPurgeCommentId = float64

// AdminPurgeCommentView When an admin purges a comment.
type AdminPurgeCommentView struct {
	// Admin A person.
	Admin *Person `json:"admin,omitempty"`

	// AdminPurgeComment When an admin purges a comment.
	AdminPurgeComment AdminPurgeComment `json:"admin_purge_comment"`

	// Post A post.
	Post Post `json:"post"`
}

// AdminPurgeCommunity When an admin purges a community.
type AdminPurgeCommunity struct {
	// AdminPersonId The person id.
	AdminPersonId PersonId              `json:"admin_person_id"`
	Id            AdminPurgeCommunityId `json:"id"`
	Published     string                `json:"published"`
	Reason        *string               `json:"reason,omitempty"`
}

// AdminPurgeCommunityId defines model for AdminPurgeCommunityId.
type AdminPurgeCommunityId = float64

// AdminPurgeCommunityView When an admin purges a community.
type AdminPurgeCommunityView struct {
	// Admin A person.
	Admin *Person `json:"admin,omitempty"`

	// AdminPurgeCommunity When an admin purges a community.
	AdminPurgeCommunity AdminPurgeCommunity `json:"admin_purge_community"`
}

// AdminPurgePerson When an admin purges a person.
type AdminPurgePerson struct {
	// AdminPersonId The person id.
	AdminPersonId PersonId           `json:"admin_person_id"`
	Id            AdminPurgePersonId `json:"id"`
	Published     string             `json:"published"`
	Reason        *string            `json:"reason,omitempty"`
}

// AdminPurgePersonId defines model for AdminPurgePersonId.
type AdminPurgePersonId = float64

// AdminPurgePersonView When an admin purges a person.
type AdminPurgePersonView struct {
	// Admin A person.
	Admin *Person `json:"admin,omitempty"`

	// AdminPurgePerson When an admin purges a person.
	AdminPurgePerson AdminPurgePerson `json:"admin_purge_person"`
}

// AdminPurgePost When an admin purges a post.
type AdminPurgePost struct {
	// AdminPersonId The person id.
	AdminPersonId PersonId `json:"admin_person_id"`

	// CommunityId The community id.
	CommunityId CommunityId      `json:"community_id"`
	Id          AdminPurgePostId `json:"id"`
	Published   string           `json:"published"`
	Reason      *string          `json:"reason,omitempty"`
}

// AdminPurgePostId defines model for AdminPurgePostId.
type AdminPurgePostId = float64

// AdminPurgePostView When an admin purges a post.
type AdminPurgePostView struct {
	// Admin A person.
	Admin *Person `json:"admin,omitempty"`

	// AdminPurgePost When an admin purges a post.
	AdminPurgePost AdminPurgePost `json:"admin_purge_post"`

	// Community A community.
	Community Community `json:"community"`
}

// ApproveCommunityPendingFollower defines model for ApproveCommunityPendingFollower.
type ApproveCommunityPendingFollower struct {
	Approve bool `json:"approve"`

	// CommunityId The community id.
	CommunityId CommunityId `json:"community_id"`

	// FollowerId The person id.
	FollowerId PersonId `json:"follower_id"`
}

// ApproveRegistrationApplication Approves a registration application.
type ApproveRegistrationApplication struct {
	Approve    bool    `json:"approve"`
	DenyReason *string `json:"deny_reason,omitempty"`

	// Id The registration application id.
	Id RegistrationApplicationId `json:"id"`
}

// AuthenticateWithOauth Logging in with an OAuth 2.0 authorization
type AuthenticateWithOauth struct {
	// Answer An answer is mandatory if require application is enabled on the server
	Answer *string `json:"answer,omitempty"`
	Code   string  `json:"code"`

	// OauthProviderId The oauth provider id.
	OauthProviderId  OAuthProviderId `json:"oauth_provider_id"`
	PkceCodeVerifier *string         `json:"pkce_code_verifier,omitempty"`
	RedirectUri      string          `json:"redirect_uri"`
	ShowNsfw         *bool           `json:"show_nsfw,omitempty"`

	// Username Username is mandatory at registration time
	Username *string `json:"username,omitempty"`
}

// BanFromCommunity Ban a user from a community.
type BanFromCommunity struct {
	Ban bool `json:"ban"`

	// CommunityId The community id.
	CommunityId CommunityId `json:"community_id"`

	// Expires A time that the ban will expire, in unix epoch seconds.
	//
	// An i64 unix timestamp is used for a simpler API client implementation.
	Expires *float64 `json:"expires,omitempty"`

	// PersonId The person id.
	PersonId PersonId `json:"person_id"`
	Reason   *string  `json:"reason,omitempty"`

	// RemoveOrRestoreData Optionally remove or restore all their data. Useful for new troll accounts.
	// If ban is true, then this means remove. If ban is false, it means restore.
	RemoveOrRestoreData *bool `json:"remove_or_restore_data,omitempty"`
}

// BanFromCommunityResponse The response for banning a user from a community.
type BanFromCommunityResponse struct {
	Banned bool `json:"banned"`

	// PersonView A person view.
	PersonView PersonView `json:"person_view"`
}

// BanPerson Ban a person from the site.
type BanPerson struct {
	Ban bool `json:"ban"`

	// Expires A time that the ban will expire, in unix epoch seconds.
	//
	// An i64 unix timestamp is used for a simpler API client implementation.
	Expires *float64 `json:"expires,omitempty"`

	// PersonId The person id.
	PersonId PersonId `json:"person_id"`
	Reason   *string  `json:"reason,omitempty"`

	// RemoveOrRestoreData Optionally remove or restore all their data. Useful for new troll accounts.
	// If ban is true, then this means remove. If ban is false, it means restore.
	RemoveOrRestoreData *bool `json:"remove_or_restore_data,omitempty"`
}

// BanPersonResponse A response for a banned person.
type BanPersonResponse struct {
	Banned bool `json:"banned"`

	// PersonView A person view.
	PersonView PersonView `json:"person_view"`
}

// BannedPersonsResponse The list of banned persons.
type BannedPersonsResponse struct {
	Banned []PersonView `json:"banned"`
}

// BlockCommunity Block a community.
type BlockCommunity struct {
	Block bool `json:"block"`

	// CommunityId The community id.
	CommunityId CommunityId `json:"community_id"`
}

// BlockCommunityResponse The block community response.
type BlockCommunityResponse struct {
	Blocked bool `json:"blocked"`

	// CommunityView A community view.
	CommunityView CommunityView `json:"community_view"`
}

// BlockPerson Block a person.
type BlockPerson struct {
	Block bool `json:"block"`

	// PersonId The person id.
	PersonId PersonId `json:"person_id"`
}

// BlockPersonResponse The response for a person block.
type BlockPersonResponse struct {
	Blocked bool `json:"blocked"`

	// PersonView A person view.
	PersonView PersonView `json:"person_view"`
}

// CaptchaResponse A captcha response.
type CaptchaResponse struct {
	// Png A Base64 encoded png
	Png string `json:"png"`

	// Uuid The UUID for the captcha item.
	Uuid string `json:"uuid"`

	// Wav A Base64 encoded wav audio
	Wav string `json:"wav"`
}

// ChangePassword Changes your account password.
type ChangePassword struct {
	NewPassword       SensitiveString `json:"new_password"`
	NewPasswordVerify SensitiveString `json:"new_password_verify"`
	OldPassword       SensitiveString `json:"old_password"`
}

// Comment A comment.
type Comment struct {
	ApId DbUrl `json:"ap_id"`

	// ChildCount The total number of children in this comment branch.
	ChildCount float64 `json:"child_count"`
	Content    string  `json:"content"`

	// CreatorId The person id.
	CreatorId PersonId `json:"creator_id"`

	// Deleted Whether the comment has been deleted by its creator.
	Deleted bool `json:"deleted"`

	// Distinguished Whether the comment has been distinguished(speaking officially) by a mod.
	Distinguished bool    `json:"distinguished"`
	Downvotes     float64 `json:"downvotes"`

	// Id The comment id.
	Id CommentId `json:"id"`

	// LanguageId The language id.
	LanguageId LanguageId `json:"language_id"`

	// Local Whether the comment is local.
	Local bool `json:"local"`

	// Path The path / tree location of a comment, separated by dots, ending with the comment's id. Ex:
	// 0.24.27
	Path string `json:"path"`

	// PostId The post id.
	PostId    PostId `json:"post_id"`
	Published string `json:"published"`

	// Removed Whether the comment has been removed.
	Removed               bool    `json:"removed"`
	ReportCount           float64 `json:"report_count"`
	Score                 float64 `json:"score"`
	UnresolvedReportCount float64 `json:"unresolved_report_count"`
	Updated               *string `json:"updated,omitempty"`
	Upvotes               float64 `json:"upvotes"`
}

// CommentId The comment id.
type CommentId = float64

// CommentReply A comment reply.
type CommentReply struct {
	// CommentId The comment id.
	CommentId CommentId `json:"comment_id"`

	// Id The comment reply id.
	Id        CommentReplyId `json:"id"`
	Published string         `json:"published"`
	Read      bool           `json:"read"`

	// RecipientId The person id.
	RecipientId PersonId `json:"recipient_id"`
}

// CommentReplyId The comment reply id.
type CommentReplyId = float64

// CommentReplyView A comment reply view.
type CommentReplyView struct {
	BannedFromCommunity bool `json:"banned_from_community"`
	CanMod              bool `json:"can_mod"`

	// Comment A comment.
	Comment Comment `json:"comment"`

	// CommentReply A comment reply.
	CommentReply CommentReply `json:"comment_reply"`

	// Community A community.
	Community Community `json:"community"`

	// Creator A person.
	Creator                    Person   `json:"creator"`
	CreatorBannedFromCommunity bool     `json:"creator_banned_from_community"`
	CreatorBlocked             bool     `json:"creator_blocked"`
	CreatorIsAdmin             bool     `json:"creator_is_admin"`
	CreatorIsModerator         bool     `json:"creator_is_moderator"`
	MyVote                     *float64 `json:"my_vote,omitempty"`

	// Post A post.
	Post Post `json:"post"`

	// Recipient A person.
	Recipient Person `json:"recipient"`

	// Saved The time when the comment was saved.
	Saved *string `json:"saved,omitempty"`

	// Subscribed A type / status for a community subscribe.
	Subscribed SubscribedType `json:"subscribed"`
}

// CommentReport A comment report.
type CommentReport struct {
	// CommentId The comment id.
	CommentId CommentId `json:"comment_id"`

	// CreatorId The person id.
	CreatorId PersonId `json:"creator_id"`

	// Id The comment report id.
	Id                  CommentReportId `json:"id"`
	OriginalCommentText string          `json:"original_comment_text"`
	Published           string          `json:"published"`
	Reason              string          `json:"reason"`
	Resolved            bool            `json:"resolved"`

	// ResolverId The person id.
	ResolverId            *PersonId `json:"resolver_id,omitempty"`
	Updated               *string   `json:"updated,omitempty"`
	ViolatesInstanceRules bool      `json:"violates_instance_rules"`
}

// CommentReportId The comment report id.
type CommentReportId = float64

// CommentReportResponse The comment report response.
type CommentReportResponse struct {
	// CommentReportView A comment report view.
	CommentReportView CommentReportView `json:"comment_report_view"`
}

// CommentReportView A comment report view.
type CommentReportView struct {
	// Comment A comment.
	Comment Comment `json:"comment"`

	// CommentCreator A person.
	CommentCreator Person `json:"comment_creator"`

	// CommentReport A comment report.
	CommentReport CommentReport `json:"comment_report"`

	// Community A community.
	Community Community `json:"community"`

	// Creator A person.
	Creator                    Person   `json:"creator"`
	CreatorBannedFromCommunity bool     `json:"creator_banned_from_community"`
	CreatorBlocked             bool     `json:"creator_blocked"`
	CreatorIsAdmin             bool     `json:"creator_is_admin"`
	CreatorIsModerator         bool     `json:"creator_is_moderator"`
	MyVote                     *float64 `json:"my_vote,omitempty"`

	// Post A post.
	Post Post `json:"post"`

	// Resolver A person.
	Resolver *Person `json:"resolver,omitempty"`

	// Saved The time when the comment was saved.
	Saved *string `json:"saved,omitempty"`

	// Subscribed A type / status for a community subscribe.
	Subscribed SubscribedType `json:"subscribed"`
}

// CommentResponse A comment response.
type CommentResponse struct {
	// CommentView A comment view.
	CommentView  CommentView   `json:"comment_view"`
	RecipientIds []LocalUserId `json:"recipient_ids"`
}

// CommentSlimView A slimmer comment view, without the post, or community.
type CommentSlimView struct {
	BannedFromCommunity bool `json:"banned_from_community"`
	CanMod              bool `json:"can_mod"`

	// Comment A comment.
	Comment Comment `json:"comment"`

	// Creator A person.
	Creator                    Person   `json:"creator"`
	CreatorBannedFromCommunity bool     `json:"creator_banned_from_community"`
	CreatorBlocked             bool     `json:"creator_blocked"`
	CreatorIsAdmin             bool     `json:"creator_is_admin"`
	CreatorIsModerator         bool     `json:"creator_is_moderator"`
	MyVote                     *float64 `json:"my_vote,omitempty"`

	// Saved The time when the comment was saved.
	Saved *string `json:"saved,omitempty"`

	// Subscribed A type / status for a community subscribe.
	Subscribed SubscribedType `json:"subscribed"`
}

// CommentSortType The comment sort types. See here for descriptions: https://join-lemmy.org/docs/en/users/03-votes-and-ranking.html
type CommentSortType string

// CommentView A comment view.
type CommentView struct {
	BannedFromCommunity bool `json:"banned_from_community"`
	CanMod              bool `json:"can_mod"`

	// Comment A comment.
	Comment Comment `json:"comment"`

	// Community A community.
	Community Community `json:"community"`

	// Creator A person.
	Creator                    Person   `json:"creator"`
	CreatorBannedFromCommunity bool     `json:"creator_banned_from_community"`
	CreatorBlocked             bool     `json:"creator_blocked"`
	CreatorIsAdmin             bool     `json:"creator_is_admin"`
	CreatorIsModerator         bool     `json:"creator_is_moderator"`
	MyVote                     *float64 `json:"my_vote,omitempty"`

	// Post A post.
	Post Post `json:"post"`

	// Saved The time when the comment was saved.
	Saved *string `json:"saved,omitempty"`

	// Subscribed A type / status for a community subscribe.
	Subscribed SubscribedType `json:"subscribed"`
}

// Community A community.
type Community struct {
	ApId     DbUrl   `json:"ap_id"`
	Banner   *DbUrl  `json:"banner,omitempty"`
	Comments float64 `json:"comments"`

	// Deleted Whether the community has been deleted by its creator.
	Deleted bool `json:"deleted"`

	// Description A shorter, one-line description of the site.
	Description *string `json:"description,omitempty"`

	// Hidden Whether the community is hidden.
	Hidden bool   `json:"hidden"`
	Icon   *DbUrl `json:"icon,omitempty"`

	// Id The community id.
	Id CommunityId `json:"id"`

	// InstanceId The instance id.
	InstanceId InstanceId `json:"instance_id"`

	// Local Whether the community is local.
	Local bool   `json:"local"`
	Name  string `json:"name"`

	// Nsfw Whether its an NSFW community.
	Nsfw bool `json:"nsfw"`

	// PostingRestrictedToMods Whether posting is restricted to mods only.
	PostingRestrictedToMods bool    `json:"posting_restricted_to_mods"`
	Posts                   float64 `json:"posts"`
	Published               string  `json:"published"`

	// Removed Whether the community is removed by a mod.
	Removed     bool    `json:"removed"`
	ReportCount float64 `json:"report_count"`

	// Sidebar A sidebar for the community in markdown.
	Sidebar          *string `json:"sidebar,omitempty"`
	Subscribers      float64 `json:"subscribers"`
	SubscribersLocal float64 `json:"subscribers_local"`

	// Title A longer title, that can contain other characters, and doesn't have to be unique.
	Title                 string  `json:"title"`
	UnresolvedReportCount float64 `json:"unresolved_report_count"`
	Updated               *string `json:"updated,omitempty"`

	// UsersActiveDay The number of users with any activity in the last day.
	UsersActiveDay float64 `json:"users_active_day"`

	// UsersActiveHalfYear The number of users with any activity in the last year.
	UsersActiveHalfYear float64 `json:"users_active_half_year"`

	// UsersActiveMonth The number of users with any activity in the last month.
	UsersActiveMonth float64 `json:"users_active_month"`

	// UsersActiveWeek The number of users with any activity in the last week.
	UsersActiveWeek float64 `json:"users_active_week"`

	// Visibility Defines who can browse and interact with content in a community.
	Visibility CommunityVisibility `json:"visibility"`
}

// CommunityFollowerView A community follower.
type CommunityFollowerView struct {
	// Community A community.
	Community Community `json:"community"`

	// Follower A person.
	Follower Person `json:"follower"`
}

// CommunityId The community id.
type CommunityId = float64

// CommunityModeratorView A community moderator.
type CommunityModeratorView struct {
	// Community A community.
	Community Community `json:"community"`

	// Moderator A person.
	Moderator Person `json:"moderator"`
}

// CommunityReport A comment report.
type CommunityReport struct {
	// CommunityId The community id.
	CommunityId CommunityId `json:"community_id"`

	// CreatorId The person id.
	CreatorId PersonId `json:"creator_id"`

	// Id The community report id.
	Id                           CommunityReportId `json:"id"`
	OriginalCommunityBanner      *string           `json:"original_community_banner,omitempty"`
	OriginalCommunityDescription *string           `json:"original_community_description,omitempty"`
	OriginalCommunityIcon        *string           `json:"original_community_icon,omitempty"`
	OriginalCommunityName        string            `json:"original_community_name"`
	OriginalCommunitySidebar     *string           `json:"original_community_sidebar,omitempty"`
	OriginalCommunityTitle       string            `json:"original_community_title"`
	Published                    string            `json:"published"`
	Reason                       string            `json:"reason"`
	Resolved                     bool              `json:"resolved"`

	// ResolverId The person id.
	ResolverId *PersonId `json:"resolver_id,omitempty"`
	Updated    *string   `json:"updated,omitempty"`
}

// CommunityReportId The community report id.
type CommunityReportId = float64

// CommunityReportView A community report view.
type CommunityReportView struct {
	// Community A community.
	Community Community `json:"community"`

	// CommunityReport A comment report.
	CommunityReport CommunityReport `json:"community_report"`

	// Creator A person.
	Creator Person `json:"creator"`

	// Resolver A person.
	Resolver *Person `json:"resolver,omitempty"`

	// Subscribed A type / status for a community subscribe.
	Subscribed SubscribedType `json:"subscribed"`
}

// CommunityResponse A simple community response.
type CommunityResponse struct {
	// CommunityView A community view.
	CommunityView       CommunityView `json:"community_view"`
	DiscussionLanguages []LanguageId  `json:"discussion_languages"`
}

// CommunitySortType The community sort types. See here for descriptions: https://join-lemmy.org/docs/en/users/03-votes-and-ranking.html
type CommunitySortType string

// CommunityView A community view.
type CommunityView struct {
	BannedFromCommunity bool `json:"banned_from_community"`
	Blocked             bool `json:"blocked"`
	CanMod              bool `json:"can_mod"`

	// Community A community.
	Community Community `json:"community"`

	// Subscribed A type / status for a community subscribe.
	Subscribed SubscribedType `json:"subscribed"`
}

// CommunityVisibility Defines who can browse and interact with content in a community.
type CommunityVisibility string

// CreateComment Create a comment.
type CreateComment struct {
	Content string `json:"content"`

	// LanguageId The language id.
	LanguageId *LanguageId `json:"language_id,omitempty"`

	// ParentId The comment id.
	ParentId *CommentId `json:"parent_id,omitempty"`

	// PostId The post id.
	PostId PostId `json:"post_id"`
}

// CreateCommentLike Like a comment.
type CreateCommentLike struct {
	// CommentId The comment id.
	CommentId CommentId `json:"comment_id"`

	// Score Must be -1, 0, or 1 .
	Score float64 `json:"score"`
}

// CreateCommentReport Report a comment.
type CreateCommentReport struct {
	// CommentId The comment id.
	CommentId             CommentId `json:"comment_id"`
	Reason                string    `json:"reason"`
	ViolatesInstanceRules *bool     `json:"violates_instance_rules,omitempty"`
}

// CreateCommunity Create a community.
type CreateCommunity struct {
	// Banner A banner URL.
	Banner *string `json:"banner,omitempty"`

	// Description A shorter, one line description of your community.
	Description         *string       `json:"description,omitempty"`
	DiscussionLanguages *[]LanguageId `json:"discussion_languages,omitempty"`

	// Icon An icon URL.
	Icon *string `json:"icon,omitempty"`

	// Name The unique name.
	Name string `json:"name"`

	// Nsfw Whether its an NSFW community.
	Nsfw *bool `json:"nsfw,omitempty"`

	// PostingRestrictedToMods Whether to restrict posting only to moderators.
	PostingRestrictedToMods *bool `json:"posting_restricted_to_mods,omitempty"`

	// Sidebar A sidebar for the community in markdown.
	Sidebar *string `json:"sidebar,omitempty"`

	// Title A longer title.
	Title string `json:"title"`

	// Visibility Defines who can browse and interact with content in a community.
	Visibility *CommunityVisibility `json:"visibility,omitempty"`
}

// CreateCustomEmoji Create a custom emoji.
type CreateCustomEmoji struct {
	AltText   string   `json:"alt_text"`
	Category  string   `json:"category"`
	ImageUrl  string   `json:"image_url"`
	Keywords  []string `json:"keywords"`
	Shortcode string   `json:"shortcode"`
}

// CreateOAuthProvider Create an external auth method.
type CreateOAuthProvider struct {
	AccountLinkingEnabled *bool  `json:"account_linking_enabled,omitempty"`
	AuthorizationEndpoint string `json:"authorization_endpoint"`
	AutoVerifyEmail       *bool  `json:"auto_verify_email,omitempty"`
	ClientId              string `json:"client_id"`
	ClientSecret          string `json:"client_secret"`
	DisplayName           string `json:"display_name"`
	Enabled               *bool  `json:"enabled,omitempty"`
	IdClaim               string `json:"id_claim"`
	Issuer                string `json:"issuer"`
	Scopes                string `json:"scopes"`
	TokenEndpoint         string `json:"token_endpoint"`
	UsePkce               *bool  `json:"use_pkce,omitempty"`
	UserinfoEndpoint      string `json:"userinfo_endpoint"`
}

// CreatePost Create a post.
type CreatePost struct {
	// AltText An optional alt_text, usable for image posts.
	AltText *string `json:"alt_text,omitempty"`

	// Body An optional body for the post in markdown.
	Body *string `json:"body,omitempty"`

	// CommunityId The community id.
	CommunityId CommunityId `json:"community_id"`

	// CustomThumbnail Instead of fetching a thumbnail, use a custom one.
	CustomThumbnail *string `json:"custom_thumbnail,omitempty"`

	// Honeypot A honeypot to catch bots. Should be None.
	Honeypot *string `json:"honeypot,omitempty"`

	// LanguageId The language id.
	LanguageId *LanguageId `json:"language_id,omitempty"`
	Name       string      `json:"name"`
	Nsfw       *bool       `json:"nsfw,omitempty"`

	// ScheduledPublishTime Time when this post should be scheduled. Null means publish immediately.
	ScheduledPublishTime *float64 `json:"scheduled_publish_time,omitempty"`
	Tags                 *[]TagId `json:"tags,omitempty"`
	Url                  *string  `json:"url,omitempty"`
}

// CreatePostLike Like a post.
type CreatePostLike struct {
	// PostId The post id.
	PostId PostId `json:"post_id"`

	// Score Score must be -1, 0, or 1.
	Score float64 `json:"score"`
}

// CreatePostReport Create a post report.
type CreatePostReport struct {
	// PostId The post id.
	PostId                PostId `json:"post_id"`
	Reason                string `json:"reason"`
	ViolatesInstanceRules *bool  `json:"violates_instance_rules,omitempty"`
}

// CreatePrivateMessage Create a private message.
type CreatePrivateMessage struct {
	Content string `json:"content"`

	// RecipientId The person id.
	RecipientId PersonId `json:"recipient_id"`
}

// CreatePrivateMessageReport Create a report for a private message.
type CreatePrivateMessageReport struct {
	// PrivateMessageId The private message id.
	PrivateMessageId PrivateMessageId `json:"private_message_id"`
	Reason           string           `json:"reason"`
}

// CreateSite Creates a site. Should be done after first running lemmy.
type CreateSite struct {
	ActorNameMaxLength     *float64 `json:"actor_name_max_length,omitempty"`
	ApplicationEmailAdmins *bool    `json:"application_email_admins,omitempty"`
	ApplicationQuestion    *string  `json:"application_question,omitempty"`
	CaptchaDifficulty      *string  `json:"captcha_difficulty,omitempty"`
	CaptchaEnabled         *bool    `json:"captcha_enabled,omitempty"`

	// CommentDownvotes The federation mode for an item
	CommentDownvotes *FederationMode `json:"comment_downvotes,omitempty"`

	// CommentUpvotes The federation mode for an item
	CommentUpvotes             *FederationMode `json:"comment_upvotes,omitempty"`
	CommunityCreationAdminOnly *bool           `json:"community_creation_admin_only,omitempty"`
	ContentWarning             *string         `json:"content_warning,omitempty"`

	// DefaultCommentSortType The comment sort types. See here for descriptions: https://join-lemmy.org/docs/en/users/03-votes-and-ranking.html
	DefaultCommentSortType *CommentSortType `json:"default_comment_sort_type,omitempty"`

	// DefaultPostListingMode A post-view mode that changes how multiple post listings look.
	DefaultPostListingMode *PostListingMode `json:"default_post_listing_mode,omitempty"`

	// DefaultPostListingType A listing type for post and comment list fetches.
	DefaultPostListingType *ListingType `json:"default_post_listing_type,omitempty"`

	// DefaultPostSortType The post sort types. See here for descriptions: https://join-lemmy.org/docs/en/users/03-votes-and-ranking.html
	DefaultPostSortType         *PostSortType `json:"default_post_sort_type,omitempty"`
	DefaultPostTimeRangeSeconds *float64      `json:"default_post_time_range_seconds,omitempty"`
	DefaultTheme                *string       `json:"default_theme,omitempty"`
	Description                 *string       `json:"description,omitempty"`
	DisableDonationDialog       *bool         `json:"disable_donation_dialog,omitempty"`
	DiscussionLanguages         *[]LanguageId `json:"discussion_languages,omitempty"`
	FederationEnabled           *bool         `json:"federation_enabled,omitempty"`
	HideModlogModNames          *bool         `json:"hide_modlog_mod_names,omitempty"`
	LegalInformation            *string       `json:"legal_information,omitempty"`
	Name                        string        `json:"name"`
	OauthRegistration           *bool         `json:"oauth_registration,omitempty"`

	// PostDownvotes The federation mode for an item
	PostDownvotes *FederationMode `json:"post_downvotes,omitempty"`

	// PostUpvotes The federation mode for an item
	PostUpvotes                *FederationMode `json:"post_upvotes,omitempty"`
	PrivateInstance            *bool           `json:"private_instance,omitempty"`
	RateLimitComment           *float64        `json:"rate_limit_comment,omitempty"`
	RateLimitCommentPerSecond  *float64        `json:"rate_limit_comment_per_second,omitempty"`
	RateLimitImage             *float64        `json:"rate_limit_image,omitempty"`
	RateLimitImagePerSecond    *float64        `json:"rate_limit_image_per_second,omitempty"`
	RateLimitMessage           *float64        `json:"rate_limit_message,omitempty"`
	RateLimitMessagePerSecond  *float64        `json:"rate_limit_message_per_second,omitempty"`
	RateLimitPost              *float64        `json:"rate_limit_post,omitempty"`
	RateLimitPostPerSecond     *float64        `json:"rate_limit_post_per_second,omitempty"`
	RateLimitRegister          *float64        `json:"rate_limit_register,omitempty"`
	RateLimitRegisterPerSecond *float64        `json:"rate_limit_register_per_second,omitempty"`
	RateLimitSearch            *float64        `json:"rate_limit_search,omitempty"`
	RateLimitSearchPerSecond   *float64        `json:"rate_limit_search_per_second,omitempty"`

	// RegistrationMode The registration mode for your site. Determines what happens after a user signs up.
	RegistrationMode         *RegistrationMode `json:"registration_mode,omitempty"`
	RequireEmailVerification *bool             `json:"require_email_verification,omitempty"`
	Sidebar                  *string           `json:"sidebar,omitempty"`
	SlurFilterRegex          *string           `json:"slur_filter_regex,omitempty"`
}

// CreateTagline Create a tagline
type CreateTagline struct {
	Content string `json:"content"`
}

// CustomEmoji A custom emoji.
type CustomEmoji struct {
	AltText  string `json:"alt_text"`
	Category string `json:"category"`

	// Id The custom emoji id.
	Id        CustomEmojiId `json:"id"`
	ImageUrl  DbUrl         `json:"image_url"`
	Published string        `json:"published"`
	Shortcode string        `json:"shortcode"`
	Updated   *string       `json:"updated,omitempty"`
}

// CustomEmojiId The custom emoji id.
type CustomEmojiId = float64

// CustomEmojiKeyword A custom keyword for an emoji.
type CustomEmojiKeyword struct {
	// CustomEmojiId The custom emoji id.
	CustomEmojiId CustomEmojiId `json:"custom_emoji_id"`
	Keyword       string        `json:"keyword"`
}

// CustomEmojiResponse A response for a custom emoji.
type CustomEmojiResponse struct {
	// CustomEmoji A custom emoji view.
	CustomEmoji CustomEmojiView `json:"custom_emoji"`
}

// CustomEmojiView A custom emoji view.
type CustomEmojiView struct {
	// CustomEmoji A custom emoji.
	CustomEmoji CustomEmoji          `json:"custom_emoji"`
	Keywords    []CustomEmojiKeyword `json:"keywords"`
}

// DbUrl defines model for DbUrl.
type DbUrl = string

// DeleteAccount Delete your account.
type DeleteAccount struct {
	DeleteContent bool            `json:"delete_content"`
	Password      SensitiveString `json:"password"`
}

// DeleteComment Delete your own comment.
type DeleteComment struct {
	// CommentId The comment id.
	CommentId CommentId `json:"comment_id"`
	Deleted   bool      `json:"deleted"`
}

// DeleteCommunity Delete your own community.
type DeleteCommunity struct {
	// CommunityId The community id.
	CommunityId CommunityId `json:"community_id"`
	Deleted     bool        `json:"deleted"`
}

// DeleteCustomEmoji Delete a custom emoji.
type DeleteCustomEmoji struct {
	// Id The custom emoji id.
	Id CustomEmojiId `json:"id"`
}

// DeleteOAuthProvider Delete an external auth method.
type DeleteOAuthProvider struct {
	// Id The oauth provider id.
	Id OAuthProviderId `json:"id"`
}

// DeletePost Delete a post.
type DeletePost struct {
	Deleted bool `json:"deleted"`

	// PostId The post id.
	PostId PostId `json:"post_id"`
}

// DeletePrivateMessage Delete a private message.
type DeletePrivateMessage struct {
	Deleted bool `json:"deleted"`

	// PrivateMessageId The private message id.
	PrivateMessageId PrivateMessageId `json:"private_message_id"`
}

// DeleteTagline Delete a tagline
type DeleteTagline struct {
	// Id The tagline id.
	Id TaglineId `json:"id"`
}

// DistinguishComment Distinguish a comment (IE speak as moderator).
type DistinguishComment struct {
	// CommentId The comment id.
	CommentId     CommentId `json:"comment_id"`
	Distinguished bool      `json:"distinguished"`
}

// EditComment Edit a comment.
type EditComment struct {
	// CommentId The comment id.
	CommentId CommentId `json:"comment_id"`
	Content   *string   `json:"content,omitempty"`

	// LanguageId The language id.
	LanguageId *LanguageId `json:"language_id,omitempty"`
}

// EditCommunity Edit a community.
type EditCommunity struct {
	// CommunityId The community id.
	CommunityId CommunityId `json:"community_id"`

	// Description A shorter, one line description of your community.
	Description         *string       `json:"description,omitempty"`
	DiscussionLanguages *[]LanguageId `json:"discussion_languages,omitempty"`

	// Nsfw Whether its an NSFW community.
	Nsfw *bool `json:"nsfw,omitempty"`

	// PostingRestrictedToMods Whether to restrict posting only to moderators.
	PostingRestrictedToMods *bool `json:"posting_restricted_to_mods,omitempty"`

	// Sidebar A sidebar for the community in markdown.
	Sidebar *string `json:"sidebar,omitempty"`

	// Title A longer title.
	Title *string `json:"title,omitempty"`

	// Visibility Defines who can browse and interact with content in a community.
	Visibility *CommunityVisibility `json:"visibility,omitempty"`
}

// EditCustomEmoji Edit  a custom emoji.
type EditCustomEmoji struct {
	AltText  string `json:"alt_text"`
	Category string `json:"category"`

	// Id The custom emoji id.
	Id       CustomEmojiId `json:"id"`
	ImageUrl string        `json:"image_url"`
	Keywords []string      `json:"keywords"`
}

// EditOAuthProvider Edit an external auth method.
type EditOAuthProvider struct {
	AccountLinkingEnabled *bool   `json:"account_linking_enabled,omitempty"`
	AuthorizationEndpoint *string `json:"authorization_endpoint,omitempty"`
	AutoVerifyEmail       *bool   `json:"auto_verify_email,omitempty"`
	ClientSecret          *string `json:"client_secret,omitempty"`
	DisplayName           *string `json:"display_name,omitempty"`
	Enabled               *bool   `json:"enabled,omitempty"`

	// Id The oauth provider id.
	Id               OAuthProviderId `json:"id"`
	IdClaim          *string         `json:"id_claim,omitempty"`
	Scopes           *string         `json:"scopes,omitempty"`
	TokenEndpoint    *string         `json:"token_endpoint,omitempty"`
	UsePkce          *bool           `json:"use_pkce,omitempty"`
	UserinfoEndpoint *string         `json:"userinfo_endpoint,omitempty"`
}

// EditPost Edit a post.
type EditPost struct {
	// AltText An optional alt_text, usable for image posts.
	AltText *string `json:"alt_text,omitempty"`

	// Body An optional body for the post in markdown.
	Body *string `json:"body,omitempty"`

	// CustomThumbnail Instead of fetching a thumbnail, use a custom one.
	CustomThumbnail *string `json:"custom_thumbnail,omitempty"`

	// LanguageId The language id.
	LanguageId *LanguageId `json:"language_id,omitempty"`
	Name       *string     `json:"name,omitempty"`
	Nsfw       *bool       `json:"nsfw,omitempty"`

	// PostId The post id.
	PostId PostId `json:"post_id"`

	// ScheduledPublishTime Time when this post should be scheduled. Null means publish immediately.
	ScheduledPublishTime *float64 `json:"scheduled_publish_time,omitempty"`
	Tags                 *[]TagId `json:"tags,omitempty"`
	Url                  *string  `json:"url,omitempty"`
}

// EditPrivateMessage Edit a private message.
type EditPrivateMessage struct {
	Content string `json:"content"`

	// PrivateMessageId The private message id.
	PrivateMessageId PrivateMessageId `json:"private_message_id"`
}

// EditSite Edits a site.
type EditSite struct {
	// ActorNameMaxLength The max length of actor names.
	ActorNameMaxLength *float64 `json:"actor_name_max_length,omitempty"`

	// ApplicationEmailAdmins Whether to email admins when receiving a new application.
	ApplicationEmailAdmins *bool `json:"application_email_admins,omitempty"`

	// ApplicationQuestion Your application question form. This is in markdown, and can be many questions.
	ApplicationQuestion *string `json:"application_question,omitempty"`

	// BlockedUrls A list of blocked URLs
	BlockedUrls *[]string `json:"blocked_urls,omitempty"`

	// CaptchaDifficulty The captcha difficulty. Can be easy, medium, or hard
	CaptchaDifficulty *string `json:"captcha_difficulty,omitempty"`

	// CaptchaEnabled Whether to enable captchas for signups.
	CaptchaEnabled *bool `json:"captcha_enabled,omitempty"`

	// CommentDownvotes The federation mode for an item
	CommentDownvotes *FederationMode `json:"comment_downvotes,omitempty"`

	// CommentUpvotes The federation mode for an item
	CommentUpvotes *FederationMode `json:"comment_upvotes,omitempty"`

	// CommunityCreationAdminOnly Limits community creation to admins only.
	CommunityCreationAdminOnly *bool `json:"community_creation_admin_only,omitempty"`

	// ContentWarning If present, nsfw content is visible by default. Should be displayed by frontends/clients
	// when the site is first opened by a user.
	ContentWarning *string `json:"content_warning,omitempty"`

	// DefaultCommentSortType The comment sort types. See here for descriptions: https://join-lemmy.org/docs/en/users/03-votes-and-ranking.html
	DefaultCommentSortType *CommentSortType `json:"default_comment_sort_type,omitempty"`

	// DefaultPostListingMode A post-view mode that changes how multiple post listings look.
	DefaultPostListingMode *PostListingMode `json:"default_post_listing_mode,omitempty"`

	// DefaultPostListingType A listing type for post and comment list fetches.
	DefaultPostListingType *ListingType `json:"default_post_listing_type,omitempty"`

	// DefaultPostSortType The post sort types. See here for descriptions: https://join-lemmy.org/docs/en/users/03-votes-and-ranking.html
	DefaultPostSortType *PostSortType `json:"default_post_sort_type,omitempty"`

	// DefaultPostTimeRangeSeconds A default time range limit to apply to post sorts, in seconds. 0 means none.
	DefaultPostTimeRangeSeconds *float64 `json:"default_post_time_range_seconds,omitempty"`

	// DefaultTheme The default theme. Usually "browser"
	DefaultTheme *string `json:"default_theme,omitempty"`

	// Description A shorter, one line description of your site.
	Description *string `json:"description,omitempty"`

	// DisableDonationDialog If this is true, users will never see the dialog asking to support Lemmy development with
	// donations.
	DisableDonationDialog *bool `json:"disable_donation_dialog,omitempty"`

	// DisallowNsfwContent Block NSFW content being created
	DisallowNsfwContent *bool `json:"disallow_nsfw_content,omitempty"`

	// DiscussionLanguages A list of allowed discussion languages.
	DiscussionLanguages *[]LanguageId `json:"discussion_languages,omitempty"`

	// FederationEnabled Whether to enable federation.
	FederationEnabled *bool `json:"federation_enabled,omitempty"`

	// HideModlogModNames Whether to hide moderator names from the modlog.
	HideModlogModNames *bool `json:"hide_modlog_mod_names,omitempty"`

	// LegalInformation An optional page of legal information
	LegalInformation *string `json:"legal_information,omitempty"`
	Name             *string `json:"name,omitempty"`

	// OauthRegistration Whether or not external auth methods can auto-register users.
	OauthRegistration *bool `json:"oauth_registration,omitempty"`

	// PostDownvotes The federation mode for an item
	PostDownvotes *FederationMode `json:"post_downvotes,omitempty"`

	// PostUpvotes The federation mode for an item
	PostUpvotes *FederationMode `json:"post_upvotes,omitempty"`

	// PrivateInstance Whether your instance is public, or private.
	PrivateInstance *bool `json:"private_instance,omitempty"`

	// RateLimitComment The number of comments allowed in a given time frame.
	RateLimitComment          *float64 `json:"rate_limit_comment,omitempty"`
	RateLimitCommentPerSecond *float64 `json:"rate_limit_comment_per_second,omitempty"`

	// RateLimitImage The number of image uploads allowed in a given time frame.
	RateLimitImage          *float64 `json:"rate_limit_image,omitempty"`
	RateLimitImagePerSecond *float64 `json:"rate_limit_image_per_second,omitempty"`

	// RateLimitMessage The number of messages allowed in a given time frame.
	RateLimitMessage          *float64 `json:"rate_limit_message,omitempty"`
	RateLimitMessagePerSecond *float64 `json:"rate_limit_message_per_second,omitempty"`

	// RateLimitPost The number of posts allowed in a given time frame.
	RateLimitPost          *float64 `json:"rate_limit_post,omitempty"`
	RateLimitPostPerSecond *float64 `json:"rate_limit_post_per_second,omitempty"`

	// RateLimitRegister The number of registrations allowed in a given time frame.
	RateLimitRegister          *float64 `json:"rate_limit_register,omitempty"`
	RateLimitRegisterPerSecond *float64 `json:"rate_limit_register_per_second,omitempty"`

	// RateLimitSearch The number of searches allowed in a given time frame.
	RateLimitSearch          *float64 `json:"rate_limit_search,omitempty"`
	RateLimitSearchPerSecond *float64 `json:"rate_limit_search_per_second,omitempty"`

	// RegistrationMode The registration mode for your site. Determines what happens after a user signs up.
	RegistrationMode *RegistrationMode `json:"registration_mode,omitempty"`

	// ReportsEmailAdmins Whether to email admins for new reports.
	ReportsEmailAdmins *bool `json:"reports_email_admins,omitempty"`

	// RequireEmailVerification Whether to require email verification.
	RequireEmailVerification *bool `json:"require_email_verification,omitempty"`

	// Sidebar A sidebar for the site, in markdown.
	Sidebar *string `json:"sidebar,omitempty"`

	// SlurFilterRegex A regex string of items to filter.
	SlurFilterRegex *string `json:"slur_filter_regex,omitempty"`
}

// FeaturePost Feature a post (stickies / pins to the top).
type FeaturePost struct {
	// FeatureType The feature type for a post.
	FeatureType PostFeatureType `json:"feature_type"`
	Featured    bool            `json:"featured"`

	// PostId The post id.
	PostId PostId `json:"post_id"`
}

// FederatedInstances A list of federated instances.
type FederatedInstances struct {
	Allowed []InstanceWithFederationState `json:"allowed"`
	Blocked []InstanceWithFederationState `json:"blocked"`
	Linked  []InstanceWithFederationState `json:"linked"`
}

// FederationMode The federation mode for an item
type FederationMode string

// FollowCommunity Follow / subscribe to a community.
type FollowCommunity struct {
	// CommunityId The community id.
	CommunityId CommunityId `json:"community_id"`
	Follow      bool        `json:"follow"`
}

// GenerateTotpSecretResponse defines model for GenerateTotpSecretResponse.
type GenerateTotpSecretResponse struct {
	TotpSecretUrl SensitiveString `json:"totp_secret_url"`
}

// GetCaptchaResponse A wrapper for the captcha response.
type GetCaptchaResponse struct {
	// Ok A captcha response.
	Ok *CaptchaResponse `json:"ok,omitempty"`
}

// GetCommentsResponse The comment list response.
type GetCommentsResponse struct {
	Comments []CommentView `json:"comments"`
}

// GetCommentsSlimResponse A slimmer comment list response, without the post or community.
type GetCommentsSlimResponse struct {
	Comments []CommentSlimView `json:"comments"`
}

// GetCommunityPendingFollowsCountResponse defines model for GetCommunityPendingFollowsCountResponse.
type GetCommunityPendingFollowsCountResponse struct {
	Count float64 `json:"count"`
}

// GetCommunityResponse The community response.
type GetCommunityResponse struct {
	// CommunityView A community view.
	CommunityView       CommunityView            `json:"community_view"`
	DiscussionLanguages []LanguageId             `json:"discussion_languages"`
	Moderators          []CommunityModeratorView `json:"moderators"`

	// Site The site.
	Site *Site `json:"site,omitempty"`
}

// GetFederatedInstancesResponse A response of federated instances.
type GetFederatedInstancesResponse struct {
	// FederatedInstances A list of federated instances.
	FederatedInstances *FederatedInstances `json:"federated_instances,omitempty"`
}

// GetModlogResponse The modlog fetch response.
type GetModlogResponse struct {
	Modlog []ModlogCombinedView `json:"modlog"`
}

// GetPersonDetailsResponse A person's details response.
type GetPersonDetailsResponse struct {
	Moderates []CommunityModeratorView `json:"moderates"`

	// PersonView A person view.
	PersonView PersonView `json:"person_view"`

	// Site The site.
	Site *Site `json:"site,omitempty"`
}

// GetPostResponse The post response.
type GetPostResponse struct {
	// CommunityView A community view.
	CommunityView CommunityView `json:"community_view"`

	// CrossPosts A list of cross-posts, or other times / communities this link has been posted to.
	CrossPosts []PostView `json:"cross_posts"`

	// PostView A post view.
	PostView PostView `json:"post_view"`
}

// GetPostsResponse The post list response.
type GetPostsResponse struct {
	// NextPage currently this is just a wrapper around post id, but should be seen as opaque from the client's
	// perspective. stringified since we might want to use arbitrary info later, with a P prepended to
	// prevent ossification (api users love to make assumptions (e.g. parse stuff that looks like
	// numbers as numbers) about apis that aren't part of the spec
	NextPage *PaginationCursor `json:"next_page,omitempty"`
	Posts    []PostView        `json:"posts"`
}

// GetReportCountResponse A response for the number of reports.
type GetReportCountResponse struct {
	Count float64 `json:"count"`
}

// GetSiteMetadataResponse The site metadata response.
type GetSiteMetadataResponse struct {
	// Metadata Site metadata, from its opengraph tags.
	Metadata LinkMetadata `json:"metadata"`
}

// GetSiteResponse An expanded response for a site.
type GetSiteResponse struct {
	AdminOauthProviders []OAuthProvider         `json:"admin_oauth_providers"`
	Admins              []PersonView            `json:"admins"`
	AllLanguages        []Language              `json:"all_languages"`
	BlockedUrls         []LocalSiteUrlBlocklist `json:"blocked_urls"`
	DiscussionLanguages []LanguageId            `json:"discussion_languages"`
	ImageUploadDisabled bool                    `json:"image_upload_disabled"`

	// OauthProviders A list of external auth methods your site supports.
	OauthProviders []PublicOAuthProvider `json:"oauth_providers"`

	// SiteView A site view.
	SiteView SiteView `json:"site_view"`

	// Tagline A tagline, shown at the top of your site.
	Tagline *Tagline `json:"tagline,omitempty"`
	Version string   `json:"version"`
}

// GetUnreadCountResponse A response containing a count of unread notifications.
type GetUnreadCountResponse struct {
	Count float64 `json:"count"`
}

// GetUnreadRegistrationApplicationCountResponse The count of unread registration applications.
type GetUnreadRegistrationApplicationCountResponse struct {
	RegistrationApplications float64 `json:"registration_applications"`
}

// HideCommunity Hide a community from the main view.
type HideCommunity struct {
	// CommunityId The community id.
	CommunityId CommunityId `json:"community_id"`
	Hidden      bool        `json:"hidden"`
	Reason      *string     `json:"reason,omitempty"`
}

// HidePost Hide a post from list views
type HidePost struct {
	Hide bool `json:"hide"`

	// PostId The post id.
	PostId PostId `json:"post_id"`
}

// ImageDetails defines model for ImageDetails.
type ImageDetails struct {
	Blurhash    *string `json:"blurhash,omitempty"`
	ContentType string  `json:"content_type"`
	Height      float64 `json:"height"`
	Link        DbUrl   `json:"link"`
	Width       float64 `json:"width"`
}

// InboxCombinedPaginationCursor like PaginationCursor but for the report_combined table
type InboxCombinedPaginationCursor = string

// InboxCombinedView defines model for InboxCombinedView.
type InboxCombinedView struct {
	union json.RawMessage
}

// InboxCombinedView0 defines model for .
type InboxCombinedView0 struct {
	BannedFromCommunity bool `json:"banned_from_community"`
	CanMod              bool `json:"can_mod"`

	// Comment A comment.
	Comment Comment `json:"comment"`

	// CommentReply A comment reply.
	CommentReply CommentReply `json:"comment_reply"`

	// Community A community.
	Community Community `json:"community"`

	// Creator A person.
	Creator                    Person   `json:"creator"`
	CreatorBannedFromCommunity bool     `json:"creator_banned_from_community"`
	CreatorBlocked             bool     `json:"creator_blocked"`
	CreatorIsAdmin             bool     `json:"creator_is_admin"`
	CreatorIsModerator         bool     `json:"creator_is_moderator"`
	MyVote                     *float64 `json:"my_vote,omitempty"`

	// Post A post.
	Post Post `json:"post"`

	// Recipient A person.
	Recipient Person `json:"recipient"`

	// Saved The time when the comment was saved.
	Saved *string `json:"saved,omitempty"`

	// Subscribed A type / status for a community subscribe.
	Subscribed SubscribedType         `json:"subscribed"`
	Type       InboxCombinedView0Type `json:"type_"`
}

// InboxCombinedView0Type defines model for InboxCombinedView.0.Type.
type InboxCombinedView0Type string

// InboxCombinedView1 defines model for .
type InboxCombinedView1 struct {
	BannedFromCommunity bool `json:"banned_from_community"`
	CanMod              bool `json:"can_mod"`

	// Comment A comment.
	Comment Comment `json:"comment"`

	// Community A community.
	Community Community `json:"community"`

	// Creator A person.
	Creator                    Person   `json:"creator"`
	CreatorBannedFromCommunity bool     `json:"creator_banned_from_community"`
	CreatorBlocked             bool     `json:"creator_blocked"`
	CreatorIsAdmin             bool     `json:"creator_is_admin"`
	CreatorIsModerator         bool     `json:"creator_is_moderator"`
	MyVote                     *float64 `json:"my_vote,omitempty"`

	// PersonCommentMention A person mention.
	PersonCommentMention PersonCommentMention `json:"person_comment_mention"`

	// Post A post.
	Post Post `json:"post"`

	// Recipient A person.
	Recipient Person `json:"recipient"`

	// Saved The time when the comment was saved.
	Saved *string `json:"saved,omitempty"`

	// Subscribed A type / status for a community subscribe.
	Subscribed SubscribedType         `json:"subscribed"`
	Type       InboxCombinedView1Type `json:"type_"`
}

// InboxCombinedView1Type defines model for InboxCombinedView.1.Type.
type InboxCombinedView1Type string

// InboxCombinedView2 defines model for .
type InboxCombinedView2 struct {
	BannedFromCommunity bool `json:"banned_from_community"`
	CanMod              bool `json:"can_mod"`

	// Community A community.
	Community Community `json:"community"`

	// Creator A person.
	Creator                    Person        `json:"creator"`
	CreatorBannedFromCommunity bool          `json:"creator_banned_from_community"`
	CreatorBlocked             bool          `json:"creator_blocked"`
	CreatorIsAdmin             bool          `json:"creator_is_admin"`
	CreatorIsModerator         bool          `json:"creator_is_moderator"`
	Hidden                     bool          `json:"hidden"`
	ImageDetails               *ImageDetails `json:"image_details,omitempty"`
	MyVote                     *float64      `json:"my_vote,omitempty"`

	// PersonPostMention A person mention.
	PersonPostMention PersonPostMention `json:"person_post_mention"`

	// Post A post.
	Post Post `json:"post"`

	// PostTags we wrap this in a struct so we can implement FromSqlRow<Json> for it
	PostTags PostTags `json:"post_tags"`
	Read     bool     `json:"read"`

	// Recipient A person.
	Recipient Person `json:"recipient"`

	// Saved The time when the post was saved.
	Saved *string `json:"saved,omitempty"`

	// Subscribed A type / status for a community subscribe.
	Subscribed     SubscribedType         `json:"subscribed"`
	Type           InboxCombinedView2Type `json:"type_"`
	UnreadComments float64                `json:"unread_comments"`
}

// InboxCombinedView2Type defines model for InboxCombinedView.2.Type.
type InboxCombinedView2Type string

// InboxCombinedView3 defines model for .
type InboxCombinedView3 struct {
	// Creator A person.
	Creator Person `json:"creator"`

	// PrivateMessage A private message.
	PrivateMessage PrivateMessage `json:"private_message"`

	// Recipient A person.
	Recipient Person                 `json:"recipient"`
	Type      InboxCombinedView3Type `json:"type_"`
}

// InboxCombinedView3Type defines model for InboxCombinedView.3.Type.
type InboxCombinedView3Type string

// InboxDataType A list of possible types for the inbox.
type InboxDataType string

// Instance A federated instance / site.
type Instance struct {
	Domain string `json:"domain"`

	// Id The instance id.
	Id        InstanceId `json:"id"`
	Published string     `json:"published"`
	Software  *string    `json:"software,omitempty"`
	Updated   *string    `json:"updated,omitempty"`
	Version   *string    `json:"version,omitempty"`
}

// InstanceId The instance id.
type InstanceId = float64

// InstanceWithFederationState defines model for InstanceWithFederationState.
type InstanceWithFederationState struct {
	Domain          string                   `json:"domain"`
	FederationState *ReadableFederationState `json:"federation_state,omitempty"`

	// Id The instance id.
	Id        InstanceId `json:"id"`
	Published string     `json:"published"`
	Software  *string    `json:"software,omitempty"`
	Updated   *string    `json:"updated,omitempty"`
	Version   *string    `json:"version,omitempty"`
}

// Language A language.
type Language struct {
	Code string `json:"code"`

	// Id The language id.
	Id   LanguageId `json:"id"`
	Name string     `json:"name"`
}

// LanguageId The language id.
type LanguageId = float64

// LinkMetadata Site metadata, from its opengraph tags.
type LinkMetadata struct {
	ContentType   *string `json:"content_type,omitempty"`
	Description   *string `json:"description,omitempty"`
	EmbedVideoUrl *DbUrl  `json:"embed_video_url,omitempty"`
	Image         *DbUrl  `json:"image,omitempty"`
	Title         *string `json:"title,omitempty"`
}

// ListCommentLikesResponse The comment likes response
type ListCommentLikesResponse struct {
	CommentLikes []VoteView `json:"comment_likes"`
}

// ListCommunitiesResponse The response for listing communities.
type ListCommunitiesResponse struct {
	Communities []CommunityView `json:"communities"`
}

// ListCommunityPendingFollowsResponse defines model for ListCommunityPendingFollowsResponse.
type ListCommunityPendingFollowsResponse struct {
	Items []PendingFollow `json:"items"`
}

// ListCustomEmojisResponse A response for custom emojis.
type ListCustomEmojisResponse struct {
	CustomEmojis []CustomEmojiView `json:"custom_emojis"`
}

// ListInboxResponse Get your inbox (replies, comment mentions, post mentions, and messages)
type ListInboxResponse struct {
	Inbox []InboxCombinedView `json:"inbox"`
}

// ListMediaResponse defines model for ListMediaResponse.
type ListMediaResponse struct {
	Images []LocalImageView `json:"images"`
}

// ListPersonContentResponse A person's content response.
type ListPersonContentResponse struct {
	Content []PersonContentCombinedView `json:"content"`
}

// ListPersonSavedResponse A person's saved content response.
type ListPersonSavedResponse struct {
	Saved []PersonContentCombinedView `json:"saved"`
}

// ListPostLikesResponse The post likes response
type ListPostLikesResponse struct {
	PostLikes []VoteView `json:"post_likes"`
}

// ListRegistrationApplicationsResponse The list of registration applications.
type ListRegistrationApplicationsResponse struct {
	RegistrationApplications []RegistrationApplicationView `json:"registration_applications"`
}

// ListReportsResponse The post reports response.
type ListReportsResponse struct {
	Reports []ReportCombinedView `json:"reports"`
}

// ListTaglinesResponse A response for taglines.
type ListTaglinesResponse struct {
	Taglines []Tagline `json:"taglines"`
}

// ListingType A listing type for post and comment list fetches.
type ListingType string

// LocalImage defines model for LocalImage.
type LocalImage struct {
	// LocalUserId The local user id.
	LocalUserId *LocalUserId `json:"local_user_id,omitempty"`
	PictrsAlias string       `json:"pictrs_alias"`
	Published   string       `json:"published"`
}

// LocalImageView A local image view.
type LocalImageView struct {
	LocalImage LocalImage `json:"local_image"`

	// Person A person.
	Person Person `json:"person"`
}

// LocalSite The local site.
type LocalSite struct {
	// ActorNameMaxLength The max actor name length.
	ActorNameMaxLength float64 `json:"actor_name_max_length"`

	// ApplicationEmailAdmins Whether new applications email admins.
	ApplicationEmailAdmins bool `json:"application_email_admins"`

	// ApplicationQuestion An optional registration application questionnaire in markdown.
	ApplicationQuestion *string `json:"application_question,omitempty"`

	// CaptchaDifficulty The captcha difficulty.
	CaptchaDifficulty string `json:"captcha_difficulty"`

	// CaptchaEnabled Whether captcha is enabled.
	CaptchaEnabled bool `json:"captcha_enabled"`

	// CommentDownvotes The federation mode for an item
	CommentDownvotes FederationMode `json:"comment_downvotes"`

	// CommentUpvotes The federation mode for an item
	CommentUpvotes FederationMode `json:"comment_upvotes"`
	Comments       float64        `json:"comments"`
	Communities    float64        `json:"communities"`

	// CommunityCreationAdminOnly Whether only admins can create communities.
	CommunityCreationAdminOnly bool `json:"community_creation_admin_only"`

	// DefaultCommentSortType The comment sort types. See here for descriptions: https://join-lemmy.org/docs/en/users/03-votes-and-ranking.html
	DefaultCommentSortType CommentSortType `json:"default_comment_sort_type"`

	// DefaultPostListingMode A post-view mode that changes how multiple post listings look.
	DefaultPostListingMode PostListingMode `json:"default_post_listing_mode"`

	// DefaultPostListingType A listing type for post and comment list fetches.
	DefaultPostListingType ListingType `json:"default_post_listing_type"`

	// DefaultPostSortType The post sort types. See here for descriptions: https://join-lemmy.org/docs/en/users/03-votes-and-ranking.html
	DefaultPostSortType PostSortType `json:"default_post_sort_type"`

	// DefaultPostTimeRangeSeconds A default time range limit to apply to post sorts, in seconds.
	DefaultPostTimeRangeSeconds *float64 `json:"default_post_time_range_seconds,omitempty"`

	// DefaultTheme The default front-end theme.
	DefaultTheme string `json:"default_theme"`

	// DisableDonationDialog If this is true, users will never see the dialog asking to support Lemmy development with
	// donations.
	DisableDonationDialog bool `json:"disable_donation_dialog"`

	// DisallowNsfwContent Block NSFW content being created
	DisallowNsfwContent bool `json:"disallow_nsfw_content"`

	// FederationEnabled Whether federation is enabled.
	FederationEnabled bool `json:"federation_enabled"`

	// FederationSignedFetch Whether to sign outgoing Activitypub fetches with private key of local instance. Some
	// Fediverse instances and platforms require this.
	FederationSignedFetch bool `json:"federation_signed_fetch"`

	// HideModlogModNames Whether to hide mod names on the modlog.
	HideModlogModNames bool `json:"hide_modlog_mod_names"`

	// Id The local site id.
	Id LocalSiteId `json:"id"`

	// LegalInformation An optional legal disclaimer page.
	LegalInformation *string `json:"legal_information,omitempty"`

	// OauthRegistration Whether or not external auth methods can auto-register users.
	OauthRegistration bool `json:"oauth_registration"`

	// PostDownvotes The federation mode for an item
	PostDownvotes FederationMode `json:"post_downvotes"`

	// PostUpvotes The federation mode for an item
	PostUpvotes FederationMode `json:"post_upvotes"`
	Posts       float64        `json:"posts"`

	// PrivateInstance Whether the instance is private or public.
	PrivateInstance bool   `json:"private_instance"`
	Published       string `json:"published"`

	// RegistrationMode The registration mode for your site. Determines what happens after a user signs up.
	RegistrationMode RegistrationMode `json:"registration_mode"`

	// ReportsEmailAdmins Whether to email admins on new reports.
	ReportsEmailAdmins bool `json:"reports_email_admins"`

	// RequireEmailVerification Whether emails are required.
	RequireEmailVerification bool `json:"require_email_verification"`

	// SiteId The site id.
	SiteId SiteId `json:"site_id"`

	// SiteSetup True if the site is set up.
	SiteSetup bool `json:"site_setup"`

	// SlurFilterRegex An optional regex to filter words.
	SlurFilterRegex *string `json:"slur_filter_regex,omitempty"`
	Updated         *string `json:"updated,omitempty"`
	Users           float64 `json:"users"`

	// UsersActiveDay The number of users with any activity in the last day.
	UsersActiveDay float64 `json:"users_active_day"`

	// UsersActiveHalfYear The number of users with any activity in the last half year.
	UsersActiveHalfYear float64 `json:"users_active_half_year"`

	// UsersActiveMonth The number of users with any activity in the last month.
	UsersActiveMonth float64 `json:"users_active_month"`

	// UsersActiveWeek The number of users with any activity in the last week.
	UsersActiveWeek float64 `json:"users_active_week"`
}

// LocalSiteId The local site id.
type LocalSiteId = float64

// LocalSiteRateLimit Rate limits for your site. Given in count / length of time.
type LocalSiteRateLimit struct {
	Comment                     float64 `json:"comment"`
	CommentPerSecond            float64 `json:"comment_per_second"`
	Image                       float64 `json:"image"`
	ImagePerSecond              float64 `json:"image_per_second"`
	ImportUserSettings          float64 `json:"import_user_settings"`
	ImportUserSettingsPerSecond float64 `json:"import_user_settings_per_second"`

	// LocalSiteId The local site id.
	LocalSiteId       LocalSiteId `json:"local_site_id"`
	Message           float64     `json:"message"`
	MessagePerSecond  float64     `json:"message_per_second"`
	Post              float64     `json:"post"`
	PostPerSecond     float64     `json:"post_per_second"`
	Published         string      `json:"published"`
	Register          float64     `json:"register"`
	RegisterPerSecond float64     `json:"register_per_second"`
	Search            float64     `json:"search"`
	SearchPerSecond   float64     `json:"search_per_second"`
	Updated           *string     `json:"updated,omitempty"`
}

// LocalSiteUrlBlocklist defines model for LocalSiteUrlBlocklist.
type LocalSiteUrlBlocklist struct {
	Id        float64 `json:"id"`
	Published string  `json:"published"`
	Updated   *string `json:"updated,omitempty"`
	Url       string  `json:"url"`
}

// LocalUser A local user.
type LocalUser struct {
	// AcceptedApplication Whether their registration application has been accepted.
	AcceptedApplication bool `json:"accepted_application"`

	// Admin Whether the person is an admin.
	Admin bool `json:"admin"`

	// AutoMarkFetchedPostsAsRead Whether to automatically mark fetched posts as read.
	AutoMarkFetchedPostsAsRead bool `json:"auto_mark_fetched_posts_as_read"`
	BlurNsfw                   bool `json:"blur_nsfw"`

	// CollapseBotComments Whether to auto-collapse bot comments.
	CollapseBotComments bool `json:"collapse_bot_comments"`

	// DefaultCommentSortType The comment sort types. See here for descriptions: https://join-lemmy.org/docs/en/users/03-votes-and-ranking.html
	DefaultCommentSortType CommentSortType `json:"default_comment_sort_type"`

	// DefaultListingType A listing type for post and comment list fetches.
	DefaultListingType ListingType `json:"default_listing_type"`

	// DefaultPostSortType The post sort types. See here for descriptions: https://join-lemmy.org/docs/en/users/03-votes-and-ranking.html
	DefaultPostSortType PostSortType `json:"default_post_sort_type"`

	// DefaultPostTimeRangeSeconds A default time range limit to apply to post sorts, in seconds.
	DefaultPostTimeRangeSeconds *float64         `json:"default_post_time_range_seconds,omitempty"`
	Email                       *SensitiveString `json:"email,omitempty"`

	// EmailVerified Whether their email has been verified.
	EmailVerified bool `json:"email_verified"`

	// EnableAnimatedImages Whether user avatars and inline images in the UI that are gifs should be allowed to play or
	// should be paused
	EnableAnimatedImages bool `json:"enable_animated_images"`

	// EnableKeyboardNavigation Whether to allow keyboard navigation (for browsing and interacting with posts and comments).
	EnableKeyboardNavigation bool `json:"enable_keyboard_navigation"`

	// EnablePrivateMessages Whether a user can send / receive private messages
	EnablePrivateMessages bool `json:"enable_private_messages"`

	// HideMedia Whether to hide posts containing images/videos
	HideMedia bool `json:"hide_media"`

	// Id The local user id.
	Id LocalUserId `json:"id"`

	// InfiniteScrollEnabled Whether infinite scroll is enabled.
	InfiniteScrollEnabled bool   `json:"infinite_scroll_enabled"`
	InterfaceLanguage     string `json:"interface_language"`

	// LastDonationNotification The last time a donation request was shown to this user. If this is more than a year ago,
	// a new notification request should be shown.
	LastDonationNotification string `json:"last_donation_notification"`

	// OpenLinksInNewTab Open links in a new tab.
	OpenLinksInNewTab bool `json:"open_links_in_new_tab"`

	// PersonId The person id.
	PersonId PersonId `json:"person_id"`

	// PostListingMode A post-view mode that changes how multiple post listings look.
	PostListingMode          PostListingMode `json:"post_listing_mode"`
	SendNotificationsToEmail bool            `json:"send_notifications_to_email"`

	// ShowAvatars Whether to show avatars.
	ShowAvatars bool `json:"show_avatars"`

	// ShowBotAccounts Whether to show bot accounts.
	ShowBotAccounts bool `json:"show_bot_accounts"`
	ShowDownvotes   bool `json:"show_downvotes"`

	// ShowNsfw Whether to show NSFW content.
	ShowNsfw bool `json:"show_nsfw"`

	// ShowReadPosts Whether to show read posts.
	ShowReadPosts        bool   `json:"show_read_posts"`
	ShowScore            bool   `json:"show_score"`
	ShowUpvotePercentage bool   `json:"show_upvote_percentage"`
	ShowUpvotes          bool   `json:"show_upvotes"`
	Theme                string `json:"theme"`
	Totp2faEnabled       bool   `json:"totp_2fa_enabled"`
}

// LocalUserId The local user id.
type LocalUserId = float64

// LocalUserView A local user view.
type LocalUserView struct {
	// LocalUser A local user.
	LocalUser LocalUser `json:"local_user"`

	// Person A person.
	Person Person `json:"person"`
}

// LockPost Lock a post (prevent new comments).
type LockPost struct {
	Locked bool `json:"locked"`

	// PostId The post id.
	PostId PostId `json:"post_id"`
}

// Login Logging into lemmy.
type Login struct {
	Password SensitiveString `json:"password"`

	// Totp2faToken May be required, if totp is enabled for their account.
	Totp2faToken    *string         `json:"totp_2fa_token,omitempty"`
	UsernameOrEmail SensitiveString `json:"username_or_email"`
}

// LoginResponse A response for your login.
type LoginResponse struct {
	Jwt *SensitiveString `json:"jwt,omitempty"`

	// RegistrationCreated If registration applications are required, this will return true for a signup response.
	RegistrationCreated bool `json:"registration_created"`

	// VerifyEmailSent If email verifications are required, this will return true for a signup response.
	VerifyEmailSent bool `json:"verify_email_sent"`
}

// LoginToken Stores data related to a specific user login session.
type LoginToken struct {
	// Ip IP address where login was made from, allows invalidating logins by IP address.
	// Could be stored in truncated format, or store derived information for better privacy.
	Ip *string `json:"ip,omitempty"`

	// Published Time of login
	Published string  `json:"published"`
	UserAgent *string `json:"user_agent,omitempty"`

	// UserId The local user id.
	UserId LocalUserId `json:"user_id"`
}

// MarkCommentReplyAsRead Mark a comment reply as read.
type MarkCommentReplyAsRead struct {
	// CommentReplyId The comment reply id.
	CommentReplyId CommentReplyId `json:"comment_reply_id"`
	Read           bool           `json:"read"`
}

// MarkManyPostsAsRead Mark several posts as read.
type MarkManyPostsAsRead struct {
	PostIds []PostId `json:"post_ids"`
}

// MarkPersonCommentMentionAsRead Mark a person mention as read.
type MarkPersonCommentMentionAsRead struct {
	// PersonCommentMentionId The person comment mention id.
	PersonCommentMentionId PersonCommentMentionId `json:"person_comment_mention_id"`
	Read                   bool                   `json:"read"`
}

// MarkPersonPostMentionAsRead Mark a person mention as read.
type MarkPersonPostMentionAsRead struct {
	// PersonPostMentionId The person post mention id.
	PersonPostMentionId PersonPostMentionId `json:"person_post_mention_id"`
	Read                bool                `json:"read"`
}

// MarkPostAsRead Mark a post as read.
type MarkPostAsRead struct {
	// PostId The post id.
	PostId PostId `json:"post_id"`
	Read   bool   `json:"read"`
}

// MarkPrivateMessageAsRead Mark a private message as read.
type MarkPrivateMessageAsRead struct {
	// PrivateMessageId The private message id.
	PrivateMessageId PrivateMessageId `json:"private_message_id"`
	Read             bool             `json:"read"`
}

// ModAdd When someone is added as a site moderator.
type ModAdd struct {
	Id ModAddId `json:"id"`

	// ModPersonId The person id.
	ModPersonId PersonId `json:"mod_person_id"`

	// OtherPersonId The person id.
	OtherPersonId PersonId `json:"other_person_id"`
	Published     string   `json:"published"`
	Removed       bool     `json:"removed"`
}

// ModAddCommunity When someone is added as a community moderator.
type ModAddCommunity struct {
	// CommunityId The community id.
	CommunityId CommunityId       `json:"community_id"`
	Id          ModAddCommunityId `json:"id"`

	// ModPersonId The person id.
	ModPersonId PersonId `json:"mod_person_id"`

	// OtherPersonId The person id.
	OtherPersonId PersonId `json:"other_person_id"`
	Published     string   `json:"published"`
	Removed       bool     `json:"removed"`
}

// ModAddCommunityId defines model for ModAddCommunityId.
type ModAddCommunityId = float64

// ModAddCommunityView When someone is added as a community moderator.
type ModAddCommunityView struct {
	// Community A community.
	Community Community `json:"community"`

	// ModAddCommunity When someone is added as a community moderator.
	ModAddCommunity ModAddCommunity `json:"mod_add_community"`

	// Moderator A person.
	Moderator *Person `json:"moderator,omitempty"`

	// OtherPerson A person.
	OtherPerson Person `json:"other_person"`
}

// ModAddId defines model for ModAddId.
type ModAddId = float64

// ModAddView When someone is added as a site moderator.
type ModAddView struct {
	// ModAdd When someone is added as a site moderator.
	ModAdd ModAdd `json:"mod_add"`

	// Moderator A person.
	Moderator *Person `json:"moderator,omitempty"`

	// OtherPerson A person.
	OtherPerson Person `json:"other_person"`
}

// ModBan When someone is banned from the site.
type ModBan struct {
	Banned  bool     `json:"banned"`
	Expires *string  `json:"expires,omitempty"`
	Id      ModBanId `json:"id"`

	// ModPersonId The person id.
	ModPersonId PersonId `json:"mod_person_id"`

	// OtherPersonId The person id.
	OtherPersonId PersonId `json:"other_person_id"`
	Published     string   `json:"published"`
	Reason        *string  `json:"reason,omitempty"`
}

// ModBanFromCommunity When someone is banned from a community.
type ModBanFromCommunity struct {
	Banned bool `json:"banned"`

	// CommunityId The community id.
	CommunityId CommunityId           `json:"community_id"`
	Expires     *string               `json:"expires,omitempty"`
	Id          ModBanFromCommunityId `json:"id"`

	// ModPersonId The person id.
	ModPersonId PersonId `json:"mod_person_id"`

	// OtherPersonId The person id.
	OtherPersonId PersonId `json:"other_person_id"`
	Published     string   `json:"published"`
	Reason        *string  `json:"reason,omitempty"`
}

// ModBanFromCommunityId defines model for ModBanFromCommunityId.
type ModBanFromCommunityId = float64

// ModBanFromCommunityView When someone is banned from a community.
type ModBanFromCommunityView struct {
	// Community A community.
	Community Community `json:"community"`

	// ModBanFromCommunity When someone is banned from a community.
	ModBanFromCommunity ModBanFromCommunity `json:"mod_ban_from_community"`

	// Moderator A person.
	Moderator *Person `json:"moderator,omitempty"`

	// OtherPerson A person.
	OtherPerson Person `json:"other_person"`
}

// ModBanId defines model for ModBanId.
type ModBanId = float64

// ModBanView When someone is banned from the site.
type ModBanView struct {
	// ModBan When someone is banned from the site.
	ModBan ModBan `json:"mod_ban"`

	// Moderator A person.
	Moderator *Person `json:"moderator,omitempty"`

	// OtherPerson A person.
	OtherPerson Person `json:"other_person"`
}

// ModFeaturePost When a moderator features a post on a community (pins it to the top).
type ModFeaturePost struct {
	Featured            bool             `json:"featured"`
	Id                  ModFeaturePostId `json:"id"`
	IsFeaturedCommunity bool             `json:"is_featured_community"`

	// ModPersonId The person id.
	ModPersonId PersonId `json:"mod_person_id"`

	// PostId The post id.
	PostId    PostId `json:"post_id"`
	Published string `json:"published"`
}

// ModFeaturePostId defines model for ModFeaturePostId.
type ModFeaturePostId = float64

// ModFeaturePostView When a moderator features a post on a community (pins it to the top).
type ModFeaturePostView struct {
	// Community A community.
	Community Community `json:"community"`

	// ModFeaturePost When a moderator features a post on a community (pins it to the top).
	ModFeaturePost ModFeaturePost `json:"mod_feature_post"`

	// Moderator A person.
	Moderator *Person `json:"moderator,omitempty"`

	// OtherPerson A person.
	OtherPerson Person `json:"other_person"`

	// Post A post.
	Post Post `json:"post"`
}

// ModHideCommunity When a community is hidden from public view.
type ModHideCommunity struct {
	// CommunityId The community id.
	CommunityId CommunityId        `json:"community_id"`
	Hidden      bool               `json:"hidden"`
	Id          ModHideCommunityId `json:"id"`

	// ModPersonId The person id.
	ModPersonId PersonId `json:"mod_person_id"`
	Published   string   `json:"published"`
	Reason      *string  `json:"reason,omitempty"`
}

// ModHideCommunityId defines model for ModHideCommunityId.
type ModHideCommunityId = float64

// ModHideCommunityView When a community is hidden from public view.
type ModHideCommunityView struct {
	// Admin A person.
	Admin *Person `json:"admin,omitempty"`

	// Community A community.
	Community Community `json:"community"`

	// ModHideCommunity When a community is hidden from public view.
	ModHideCommunity ModHideCommunity `json:"mod_hide_community"`
}

// ModLockPost When a moderator locks a post (prevents new comments being made).
type ModLockPost struct {
	Id     ModLockPostId `json:"id"`
	Locked bool          `json:"locked"`

	// ModPersonId The person id.
	ModPersonId PersonId `json:"mod_person_id"`

	// PostId The post id.
	PostId    PostId `json:"post_id"`
	Published string `json:"published"`
}

// ModLockPostId defines model for ModLockPostId.
type ModLockPostId = float64

// ModLockPostView When a moderator locks a post (prevents new comments being made).
type ModLockPostView struct {
	// Community A community.
	Community Community `json:"community"`

	// ModLockPost When a moderator locks a post (prevents new comments being made).
	ModLockPost ModLockPost `json:"mod_lock_post"`

	// Moderator A person.
	Moderator *Person `json:"moderator,omitempty"`

	// OtherPerson A person.
	OtherPerson Person `json:"other_person"`

	// Post A post.
	Post Post `json:"post"`
}

// ModRemoveComment When a moderator removes a comment.
type ModRemoveComment struct {
	// CommentId The comment id.
	CommentId CommentId          `json:"comment_id"`
	Id        ModRemoveCommentId `json:"id"`

	// ModPersonId The person id.
	ModPersonId PersonId `json:"mod_person_id"`
	Published   string   `json:"published"`
	Reason      *string  `json:"reason,omitempty"`
	Removed     bool     `json:"removed"`
}

// ModRemoveCommentId defines model for ModRemoveCommentId.
type ModRemoveCommentId = float64

// ModRemoveCommentView When a moderator removes a comment.
type ModRemoveCommentView struct {
	// Comment A comment.
	Comment Comment `json:"comment"`

	// Community A community.
	Community Community `json:"community"`

	// ModRemoveComment When a moderator removes a comment.
	ModRemoveComment ModRemoveComment `json:"mod_remove_comment"`

	// Moderator A person.
	Moderator *Person `json:"moderator,omitempty"`

	// OtherPerson A person.
	OtherPerson Person `json:"other_person"`

	// Post A post.
	Post Post `json:"post"`
}

// ModRemoveCommunity When a moderator removes a community.
type ModRemoveCommunity struct {
	// CommunityId The community id.
	CommunityId CommunityId          `json:"community_id"`
	Id          ModRemoveCommunityId `json:"id"`

	// ModPersonId The person id.
	ModPersonId PersonId `json:"mod_person_id"`
	Published   string   `json:"published"`
	Reason      *string  `json:"reason,omitempty"`
	Removed     bool     `json:"removed"`
}

// ModRemoveCommunityId defines model for ModRemoveCommunityId.
type ModRemoveCommunityId = float64

// ModRemoveCommunityView When a moderator removes a community.
type ModRemoveCommunityView struct {
	// Community A community.
	Community Community `json:"community"`

	// ModRemoveCommunity When a moderator removes a community.
	ModRemoveCommunity ModRemoveCommunity `json:"mod_remove_community"`

	// Moderator A person.
	Moderator *Person `json:"moderator,omitempty"`
}

// ModRemovePost When a moderator removes a post.
type ModRemovePost struct {
	Id ModRemovePostId `json:"id"`

	// ModPersonId The person id.
	ModPersonId PersonId `json:"mod_person_id"`

	// PostId The post id.
	PostId    PostId  `json:"post_id"`
	Published string  `json:"published"`
	Reason    *string `json:"reason,omitempty"`
	Removed   bool    `json:"removed"`
}

// ModRemovePostId defines model for ModRemovePostId.
type ModRemovePostId = float64

// ModRemovePostView When a moderator removes a post.
type ModRemovePostView struct {
	// Community A community.
	Community Community `json:"community"`

	// ModRemovePost When a moderator removes a post.
	ModRemovePost ModRemovePost `json:"mod_remove_post"`

	// Moderator A person.
	Moderator *Person `json:"moderator,omitempty"`

	// OtherPerson A person.
	OtherPerson Person `json:"other_person"`

	// Post A post.
	Post Post `json:"post"`
}

// ModTransferCommunity When a moderator transfers a community to a new owner.
type ModTransferCommunity struct {
	// CommunityId The community id.
	CommunityId CommunityId            `json:"community_id"`
	Id          ModTransferCommunityId `json:"id"`

	// ModPersonId The person id.
	ModPersonId PersonId `json:"mod_person_id"`

	// OtherPersonId The person id.
	OtherPersonId PersonId `json:"other_person_id"`
	Published     string   `json:"published"`
}

// ModTransferCommunityId defines model for ModTransferCommunityId.
type ModTransferCommunityId = float64

// ModTransferCommunityView When a moderator transfers a community to a new owner.
type ModTransferCommunityView struct {
	// Community A community.
	Community Community `json:"community"`

	// ModTransferCommunity When a moderator transfers a community to a new owner.
	ModTransferCommunity ModTransferCommunity `json:"mod_transfer_community"`

	// Moderator A person.
	Moderator *Person `json:"moderator,omitempty"`

	// OtherPerson A person.
	OtherPerson Person `json:"other_person"`
}

// ModlogActionType A list of possible types for the various modlog actions.
type ModlogActionType string

// ModlogCombinedPaginationCursor like PaginationCursor but for the modlog_combined
type ModlogCombinedPaginationCursor = string

// ModlogCombinedView defines model for ModlogCombinedView.
type ModlogCombinedView struct {
	union json.RawMessage
}

// ModlogCombinedView0 defines model for .
type ModlogCombinedView0 struct {
	// Admin A person.
	Admin              *Person            `json:"admin,omitempty"`
	AdminAllowInstance AdminAllowInstance `json:"admin_allow_instance"`

	// Instance A federated instance / site.
	Instance Instance                `json:"instance"`
	Type     ModlogCombinedView0Type `json:"type_"`
}

// ModlogCombinedView0Type defines model for ModlogCombinedView.0.Type.
type ModlogCombinedView0Type string

// ModlogCombinedView1 defines model for .
type ModlogCombinedView1 struct {
	// Admin A person.
	Admin              *Person            `json:"admin,omitempty"`
	AdminBlockInstance AdminBlockInstance `json:"admin_block_instance"`

	// Instance A federated instance / site.
	Instance Instance                `json:"instance"`
	Type     ModlogCombinedView1Type `json:"type_"`
}

// ModlogCombinedView1Type defines model for ModlogCombinedView.1.Type.
type ModlogCombinedView1Type string

// ModlogCombinedView2 defines model for .
type ModlogCombinedView2 struct {
	// Admin A person.
	Admin *Person `json:"admin,omitempty"`

	// AdminPurgeComment When an admin purges a comment.
	AdminPurgeComment AdminPurgeComment `json:"admin_purge_comment"`

	// Post A post.
	Post Post                    `json:"post"`
	Type ModlogCombinedView2Type `json:"type_"`
}

// ModlogCombinedView2Type defines model for ModlogCombinedView.2.Type.
type ModlogCombinedView2Type string

// ModlogCombinedView3 defines model for .
type ModlogCombinedView3 struct {
	// Admin A person.
	Admin *Person `json:"admin,omitempty"`

	// AdminPurgeCommunity When an admin purges a community.
	AdminPurgeCommunity AdminPurgeCommunity     `json:"admin_purge_community"`
	Type                ModlogCombinedView3Type `json:"type_"`
}

// ModlogCombinedView3Type defines model for ModlogCombinedView.3.Type.
type ModlogCombinedView3Type string

// ModlogCombinedView4 defines model for .
type ModlogCombinedView4 struct {
	// Admin A person.
	Admin *Person `json:"admin,omitempty"`

	// AdminPurgePerson When an admin purges a person.
	AdminPurgePerson AdminPurgePerson        `json:"admin_purge_person"`
	Type             ModlogCombinedView4Type `json:"type_"`
}

// ModlogCombinedView4Type defines model for ModlogCombinedView.4.Type.
type ModlogCombinedView4Type string

// ModlogCombinedView5 defines model for .
type ModlogCombinedView5 struct {
	// Admin A person.
	Admin *Person `json:"admin,omitempty"`

	// AdminPurgePost When an admin purges a post.
	AdminPurgePost AdminPurgePost `json:"admin_purge_post"`

	// Community A community.
	Community Community               `json:"community"`
	Type      ModlogCombinedView5Type `json:"type_"`
}

// ModlogCombinedView5Type defines model for ModlogCombinedView.5.Type.
type ModlogCombinedView5Type string

// ModlogCombinedView6 defines model for .
type ModlogCombinedView6 struct {
	// ModAdd When someone is added as a site moderator.
	ModAdd ModAdd `json:"mod_add"`

	// Moderator A person.
	Moderator *Person `json:"moderator,omitempty"`

	// OtherPerson A person.
	OtherPerson Person                  `json:"other_person"`
	Type        ModlogCombinedView6Type `json:"type_"`
}

// ModlogCombinedView6Type defines model for ModlogCombinedView.6.Type.
type ModlogCombinedView6Type string

// ModlogCombinedView7 defines model for .
type ModlogCombinedView7 struct {
	// Community A community.
	Community Community `json:"community"`

	// ModAddCommunity When someone is added as a community moderator.
	ModAddCommunity ModAddCommunity `json:"mod_add_community"`

	// Moderator A person.
	Moderator *Person `json:"moderator,omitempty"`

	// OtherPerson A person.
	OtherPerson Person                  `json:"other_person"`
	Type        ModlogCombinedView7Type `json:"type_"`
}

// ModlogCombinedView7Type defines model for ModlogCombinedView.7.Type.
type ModlogCombinedView7Type string

// ModlogCombinedView8 defines model for .
type ModlogCombinedView8 struct {
	// ModBan When someone is banned from the site.
	ModBan ModBan `json:"mod_ban"`

	// Moderator A person.
	Moderator *Person `json:"moderator,omitempty"`

	// OtherPerson A person.
	OtherPerson Person                  `json:"other_person"`
	Type        ModlogCombinedView8Type `json:"type_"`
}

// ModlogCombinedView8Type defines model for ModlogCombinedView.8.Type.
type ModlogCombinedView8Type string

// ModlogCombinedView9 defines model for .
type ModlogCombinedView9 struct {
	// Community A community.
	Community Community `json:"community"`

	// ModBanFromCommunity When someone is banned from a community.
	ModBanFromCommunity ModBanFromCommunity `json:"mod_ban_from_community"`

	// Moderator A person.
	Moderator *Person `json:"moderator,omitempty"`

	// OtherPerson A person.
	OtherPerson Person                  `json:"other_person"`
	Type        ModlogCombinedView9Type `json:"type_"`
}

// ModlogCombinedView9Type defines model for ModlogCombinedView.9.Type.
type ModlogCombinedView9Type string

// ModlogCombinedView10 defines model for .
type ModlogCombinedView10 struct {
	// Community A community.
	Community Community `json:"community"`

	// ModFeaturePost When a moderator features a post on a community (pins it to the top).
	ModFeaturePost ModFeaturePost `json:"mod_feature_post"`

	// Moderator A person.
	Moderator *Person `json:"moderator,omitempty"`

	// OtherPerson A person.
	OtherPerson Person `json:"other_person"`

	// Post A post.
	Post Post                     `json:"post"`
	Type ModlogCombinedView10Type `json:"type_"`
}

// ModlogCombinedView10Type defines model for ModlogCombinedView.10.Type.
type ModlogCombinedView10Type string

// ModlogCombinedView11 defines model for .
type ModlogCombinedView11 struct {
	// Admin A person.
	Admin *Person `json:"admin,omitempty"`

	// Community A community.
	Community Community `json:"community"`

	// ModHideCommunity When a community is hidden from public view.
	ModHideCommunity ModHideCommunity         `json:"mod_hide_community"`
	Type             ModlogCombinedView11Type `json:"type_"`
}

// ModlogCombinedView11Type defines model for ModlogCombinedView.11.Type.
type ModlogCombinedView11Type string

// ModlogCombinedView12 defines model for .
type ModlogCombinedView12 struct {
	// Community A community.
	Community Community `json:"community"`

	// ModLockPost When a moderator locks a post (prevents new comments being made).
	ModLockPost ModLockPost `json:"mod_lock_post"`

	// Moderator A person.
	Moderator *Person `json:"moderator,omitempty"`

	// OtherPerson A person.
	OtherPerson Person `json:"other_person"`

	// Post A post.
	Post Post                     `json:"post"`
	Type ModlogCombinedView12Type `json:"type_"`
}

// ModlogCombinedView12Type defines model for ModlogCombinedView.12.Type.
type ModlogCombinedView12Type string

// ModlogCombinedView13 defines model for .
type ModlogCombinedView13 struct {
	// Comment A comment.
	Comment Comment `json:"comment"`

	// Community A community.
	Community Community `json:"community"`

	// ModRemoveComment When a moderator removes a comment.
	ModRemoveComment ModRemoveComment `json:"mod_remove_comment"`

	// Moderator A person.
	Moderator *Person `json:"moderator,omitempty"`

	// OtherPerson A person.
	OtherPerson Person `json:"other_person"`

	// Post A post.
	Post Post                     `json:"post"`
	Type ModlogCombinedView13Type `json:"type_"`
}

// ModlogCombinedView13Type defines model for ModlogCombinedView.13.Type.
type ModlogCombinedView13Type string

// ModlogCombinedView14 defines model for .
type ModlogCombinedView14 struct {
	// Community A community.
	Community Community `json:"community"`

	// ModRemoveCommunity When a moderator removes a community.
	ModRemoveCommunity ModRemoveCommunity `json:"mod_remove_community"`

	// Moderator A person.
	Moderator *Person                  `json:"moderator,omitempty"`
	Type      ModlogCombinedView14Type `json:"type_"`
}

// ModlogCombinedView14Type defines model for ModlogCombinedView.14.Type.
type ModlogCombinedView14Type string

// ModlogCombinedView15 defines model for .
type ModlogCombinedView15 struct {
	// Community A community.
	Community Community `json:"community"`

	// ModRemovePost When a moderator removes a post.
	ModRemovePost ModRemovePost `json:"mod_remove_post"`

	// Moderator A person.
	Moderator *Person `json:"moderator,omitempty"`

	// OtherPerson A person.
	OtherPerson Person `json:"other_person"`

	// Post A post.
	Post Post                     `json:"post"`
	Type ModlogCombinedView15Type `json:"type_"`
}

// ModlogCombinedView15Type defines model for ModlogCombinedView.15.Type.
type ModlogCombinedView15Type string

// ModlogCombinedView16 defines model for .
type ModlogCombinedView16 struct {
	// Community A community.
	Community Community `json:"community"`

	// ModTransferCommunity When a moderator transfers a community to a new owner.
	ModTransferCommunity ModTransferCommunity `json:"mod_transfer_community"`

	// Moderator A person.
	Moderator *Person `json:"moderator,omitempty"`

	// OtherPerson A person.
	OtherPerson Person                   `json:"other_person"`
	Type        ModlogCombinedView16Type `json:"type_"`
}

// ModlogCombinedView16Type defines model for ModlogCombinedView.16.Type.
type ModlogCombinedView16Type string

// MyUserInfo Your user info.
type MyUserInfo struct {
	CommunityBlocks     []Community             `json:"community_blocks"`
	DiscussionLanguages []LanguageId            `json:"discussion_languages"`
	Follows             []CommunityFollowerView `json:"follows"`
	InstanceBlocks      []Instance              `json:"instance_blocks"`

	// LocalUserView A local user view.
	LocalUserView LocalUserView            `json:"local_user_view"`
	Moderates     []CommunityModeratorView `json:"moderates"`
	PersonBlocks  []Person                 `json:"person_blocks"`
}

// OAuthProvider oauth provider with client_secret - should never be sent to the client
type OAuthProvider struct {
	// AccountLinkingEnabled Allows linking an OAUTH account to an existing user account by matching emails
	AccountLinkingEnabled bool `json:"account_linking_enabled"`

	// AuthorizationEndpoint The authorization endpoint is used to interact with the resource owner and obtain an
	// authorization grant. This is usually provided by the OAUTH provider.
	AuthorizationEndpoint string `json:"authorization_endpoint"`

	// AutoVerifyEmail Automatically sets email as verified on registration
	AutoVerifyEmail bool `json:"auto_verify_email"`

	// ClientId The client_id is provided by the OAuth 2.0 provider and is a unique identifier to this
	// service
	ClientId string `json:"client_id"`

	// DisplayName The OAuth 2.0 provider name displayed to the user on the Login page
	DisplayName string `json:"display_name"`

	// Enabled switch to enable or disable an oauth provider
	Enabled bool `json:"enabled"`

	// Id The oauth provider id.
	Id OAuthProviderId `json:"id"`

	// IdClaim The OAuth 2.0 claim containing the unique user ID returned by the provider. Usually this
	// should be set to "sub".
	IdClaim string `json:"id_claim"`

	// Issuer The issuer url of the OAUTH provider.
	Issuer    string `json:"issuer"`
	Published string `json:"published"`

	// Scopes Lists the scopes requested from users. Users will have to grant access to the requested scope
	// at sign up.
	Scopes string `json:"scopes"`

	// TokenEndpoint The token endpoint is used by the client to obtain an access token by presenting its
	// authorization grant or refresh token. This is usually provided by the OAUTH provider.
	TokenEndpoint string  `json:"token_endpoint"`
	Updated       *string `json:"updated,omitempty"`

	// UsePkce switch to enable or disable PKCE
	UsePkce bool `json:"use_pkce"`

	// UserinfoEndpoint The UserInfo Endpoint is an OAuth 2.0 Protected Resource that returns Claims about the
	// authenticated End-User. This is defined in the OIDC specification.
	UserinfoEndpoint string `json:"userinfo_endpoint"`
}

// OAuthProviderId The oauth provider id.
type OAuthProviderId = float64

// PaginationCursor currently this is just a wrapper around post id, but should be seen as opaque from the client's
// perspective. stringified since we might want to use arbitrary info later, with a P prepended to
// prevent ossification (api users love to make assumptions (e.g. parse stuff that looks like
// numbers as numbers) about apis that aren't part of the spec
type PaginationCursor = string

// PasswordChangeAfterReset Change your password after receiving a reset request.
type PasswordChangeAfterReset struct {
	Password       SensitiveString `json:"password"`
	PasswordVerify SensitiveString `json:"password_verify"`
	Token          SensitiveString `json:"token"`
}

// PasswordReset Reset your password via email.
type PasswordReset struct {
	Email SensitiveString `json:"email"`
}

// PendingFollow defines model for PendingFollow.
type PendingFollow struct {
	// Community A community.
	Community     Community `json:"community"`
	IsNewInstance bool      `json:"is_new_instance"`

	// Person A person.
	Person Person `json:"person"`

	// Subscribed A type / status for a community subscribe.
	Subscribed SubscribedType `json:"subscribed"`
}

// Person A person.
type Person struct {
	ApId   DbUrl  `json:"ap_id"`
	Avatar *DbUrl `json:"avatar,omitempty"`

	// BanExpires When their ban, if it exists, expires, if at all.
	BanExpires *string `json:"ban_expires,omitempty"`

	// Banned Whether the person is banned.
	Banned bool   `json:"banned"`
	Banner *DbUrl `json:"banner,omitempty"`

	// Bio An optional bio, in markdown.
	Bio *string `json:"bio,omitempty"`

	// BotAccount Whether the person is a bot account.
	BotAccount   bool    `json:"bot_account"`
	CommentCount float64 `json:"comment_count"`

	// Deleted Whether the person is deleted.
	Deleted bool `json:"deleted"`

	// DisplayName A shorter display name.
	DisplayName *string `json:"display_name,omitempty"`

	// Id The person id.
	Id PersonId `json:"id"`

	// InstanceId The instance id.
	InstanceId InstanceId `json:"instance_id"`

	// Local Whether the person is local to our site.
	Local bool `json:"local"`

	// MatrixUserId A matrix id, usually given an
	MatrixUserId *string `json:"matrix_user_id,omitempty"`
	Name         string  `json:"name"`
	PostCount    float64 `json:"post_count"`
	Published    string  `json:"published"`
	Updated      *string `json:"updated,omitempty"`
}

// PersonCommentMention A person mention.
type PersonCommentMention struct {
	// CommentId The comment id.
	CommentId CommentId `json:"comment_id"`

	// Id The person comment mention id.
	Id        PersonCommentMentionId `json:"id"`
	Published string                 `json:"published"`
	Read      bool                   `json:"read"`

	// RecipientId The person id.
	RecipientId PersonId `json:"recipient_id"`
}

// PersonCommentMentionId The person comment mention id.
type PersonCommentMentionId = float64

// PersonCommentMentionView A person comment mention view.
type PersonCommentMentionView struct {
	BannedFromCommunity bool `json:"banned_from_community"`
	CanMod              bool `json:"can_mod"`

	// Comment A comment.
	Comment Comment `json:"comment"`

	// Community A community.
	Community Community `json:"community"`

	// Creator A person.
	Creator                    Person   `json:"creator"`
	CreatorBannedFromCommunity bool     `json:"creator_banned_from_community"`
	CreatorBlocked             bool     `json:"creator_blocked"`
	CreatorIsAdmin             bool     `json:"creator_is_admin"`
	CreatorIsModerator         bool     `json:"creator_is_moderator"`
	MyVote                     *float64 `json:"my_vote,omitempty"`

	// PersonCommentMention A person mention.
	PersonCommentMention PersonCommentMention `json:"person_comment_mention"`

	// Post A post.
	Post Post `json:"post"`

	// Recipient A person.
	Recipient Person `json:"recipient"`

	// Saved The time when the comment was saved.
	Saved *string `json:"saved,omitempty"`

	// Subscribed A type / status for a community subscribe.
	Subscribed SubscribedType `json:"subscribed"`
}

// PersonContentCombinedPaginationCursor like PaginationCursor but for the person_content_combined table
type PersonContentCombinedPaginationCursor = string

// PersonContentCombinedView defines model for PersonContentCombinedView.
type PersonContentCombinedView struct {
	union json.RawMessage
}

// PersonContentCombinedView0 defines model for .
type PersonContentCombinedView0 struct {
	BannedFromCommunity bool `json:"banned_from_community"`
	CanMod              bool `json:"can_mod"`

	// Community A community.
	Community Community `json:"community"`

	// Creator A person.
	Creator                    Person        `json:"creator"`
	CreatorBannedFromCommunity bool          `json:"creator_banned_from_community"`
	CreatorBlocked             bool          `json:"creator_blocked"`
	CreatorIsAdmin             bool          `json:"creator_is_admin"`
	CreatorIsModerator         bool          `json:"creator_is_moderator"`
	Hidden                     bool          `json:"hidden"`
	ImageDetails               *ImageDetails `json:"image_details,omitempty"`
	MyVote                     *float64      `json:"my_vote,omitempty"`

	// Post A post.
	Post Post `json:"post"`
	Read bool `json:"read"`

	// Saved The time when the post was saved.
	Saved *string `json:"saved,omitempty"`

	// Subscribed A type / status for a community subscribe.
	Subscribed SubscribedType `json:"subscribed"`

	// Tags we wrap this in a struct so we can implement FromSqlRow<Json> for it
	Tags           PostTags                       `json:"tags"`
	Type           PersonContentCombinedView0Type `json:"type_"`
	UnreadComments float64                        `json:"unread_comments"`
}

// PersonContentCombinedView0Type defines model for PersonContentCombinedView.0.Type.
type PersonContentCombinedView0Type string

// PersonContentCombinedView1 defines model for .
type PersonContentCombinedView1 struct {
	BannedFromCommunity bool `json:"banned_from_community"`
	CanMod              bool `json:"can_mod"`

	// Comment A comment.
	Comment Comment `json:"comment"`

	// Community A community.
	Community Community `json:"community"`

	// Creator A person.
	Creator                    Person   `json:"creator"`
	CreatorBannedFromCommunity bool     `json:"creator_banned_from_community"`
	CreatorBlocked             bool     `json:"creator_blocked"`
	CreatorIsAdmin             bool     `json:"creator_is_admin"`
	CreatorIsModerator         bool     `json:"creator_is_moderator"`
	MyVote                     *float64 `json:"my_vote,omitempty"`

	// Post A post.
	Post Post `json:"post"`

	// Saved The time when the comment was saved.
	Saved *string `json:"saved,omitempty"`

	// Subscribed A type / status for a community subscribe.
	Subscribed SubscribedType                 `json:"subscribed"`
	Type       PersonContentCombinedView1Type `json:"type_"`
}

// PersonContentCombinedView1Type defines model for PersonContentCombinedView.1.Type.
type PersonContentCombinedView1Type string

// PersonContentType A list of possible types for a person's content.
type PersonContentType string

// PersonId The person id.
type PersonId = float64

// PersonPostMention A person mention.
type PersonPostMention struct {
	// Id The person post mention id.
	Id PersonPostMentionId `json:"id"`

	// PostId The post id.
	PostId    PostId `json:"post_id"`
	Published string `json:"published"`
	Read      bool   `json:"read"`

	// RecipientId The person id.
	RecipientId PersonId `json:"recipient_id"`
}

// PersonPostMentionId The person post mention id.
type PersonPostMentionId = float64

// PersonPostMentionView A person post mention view.
type PersonPostMentionView struct {
	BannedFromCommunity bool `json:"banned_from_community"`
	CanMod              bool `json:"can_mod"`

	// Community A community.
	Community Community `json:"community"`

	// Creator A person.
	Creator                    Person        `json:"creator"`
	CreatorBannedFromCommunity bool          `json:"creator_banned_from_community"`
	CreatorBlocked             bool          `json:"creator_blocked"`
	CreatorIsAdmin             bool          `json:"creator_is_admin"`
	CreatorIsModerator         bool          `json:"creator_is_moderator"`
	Hidden                     bool          `json:"hidden"`
	ImageDetails               *ImageDetails `json:"image_details,omitempty"`
	MyVote                     *float64      `json:"my_vote,omitempty"`

	// PersonPostMention A person mention.
	PersonPostMention PersonPostMention `json:"person_post_mention"`

	// Post A post.
	Post Post `json:"post"`

	// PostTags we wrap this in a struct so we can implement FromSqlRow<Json> for it
	PostTags PostTags `json:"post_tags"`
	Read     bool     `json:"read"`

	// Recipient A person.
	Recipient Person `json:"recipient"`

	// Saved The time when the post was saved.
	Saved *string `json:"saved,omitempty"`

	// Subscribed A type / status for a community subscribe.
	Subscribed     SubscribedType `json:"subscribed"`
	UnreadComments float64        `json:"unread_comments"`
}

// PersonSavedCombinedPaginationCursor like PaginationCursor but for the person_saved_combined table
type PersonSavedCombinedPaginationCursor = string

// PersonView A person view.
type PersonView struct {
	IsAdmin bool `json:"is_admin"`

	// Person A person.
	Person Person `json:"person"`
}

// Post A post.
type Post struct {
	// AltText An optional alt_text, usable for image posts.
	AltText *string `json:"alt_text,omitempty"`
	ApId    DbUrl   `json:"ap_id"`

	// Body An optional post body, in markdown.
	Body     *string `json:"body,omitempty"`
	Comments float64 `json:"comments"`

	// CommunityId The community id.
	CommunityId CommunityId `json:"community_id"`

	// CreatorId The person id.
	CreatorId PersonId `json:"creator_id"`

	// Deleted Whether the post is deleted.
	Deleted   bool    `json:"deleted"`
	Downvotes float64 `json:"downvotes"`

	// EmbedDescription A description for the link.
	EmbedDescription *string `json:"embed_description,omitempty"`

	// EmbedTitle A title for the link.
	EmbedTitle    *string `json:"embed_title,omitempty"`
	EmbedVideoUrl *DbUrl  `json:"embed_video_url,omitempty"`

	// FeaturedCommunity Whether the post is featured to its community.
	FeaturedCommunity bool `json:"featured_community"`

	// FeaturedLocal Whether the post is featured to its site.
	FeaturedLocal bool `json:"featured_local"`

	// Id The post id.
	Id PostId `json:"id"`

	// LanguageId The language id.
	LanguageId LanguageId `json:"language_id"`

	// Local Whether the post is local.
	Local bool `json:"local"`

	// Locked Whether the post is locked.
	Locked bool   `json:"locked"`
	Name   string `json:"name"`

	// NewestCommentTime The time of the newest comment in the post.
	NewestCommentTime string `json:"newest_comment_time"`

	// Nsfw Whether the post is NSFW.
	Nsfw      bool   `json:"nsfw"`
	Published string `json:"published"`

	// Removed Whether the post is removed.
	Removed     bool    `json:"removed"`
	ReportCount float64 `json:"report_count"`

	// ScheduledPublishTime Time at which the post will be published. None means publish immediately.
	ScheduledPublishTime  *string `json:"scheduled_publish_time,omitempty"`
	Score                 float64 `json:"score"`
	ThumbnailUrl          *DbUrl  `json:"thumbnail_url,omitempty"`
	UnresolvedReportCount float64 `json:"unresolved_report_count"`
	Updated               *string `json:"updated,omitempty"`
	Upvotes               float64 `json:"upvotes"`
	Url                   *DbUrl  `json:"url,omitempty"`
	UrlContentType        *string `json:"url_content_type,omitempty"`
}

// PostFeatureType The feature type for a post.
type PostFeatureType string

// PostId The post id.
type PostId = float64

// PostListingMode A post-view mode that changes how multiple post listings look.
type PostListingMode string

// PostReport A post report.
type PostReport struct {
	// CreatorId The person id.
	CreatorId PersonId `json:"creator_id"`

	// Id The post report id.
	Id PostReportId `json:"id"`

	// OriginalPostBody The original post body.
	OriginalPostBody *string `json:"original_post_body,omitempty"`

	// OriginalPostName The original post title.
	OriginalPostName string `json:"original_post_name"`
	OriginalPostUrl  *DbUrl `json:"original_post_url,omitempty"`

	// PostId The post id.
	PostId    PostId `json:"post_id"`
	Published string `json:"published"`
	Reason    string `json:"reason"`
	Resolved  bool   `json:"resolved"`

	// ResolverId The person id.
	ResolverId            *PersonId `json:"resolver_id,omitempty"`
	Updated               *string   `json:"updated,omitempty"`
	ViolatesInstanceRules bool      `json:"violates_instance_rules"`
}

// PostReportId The post report id.
type PostReportId = float64

// PostReportResponse The post report response.
type PostReportResponse struct {
	// PostReportView A post report view.
	PostReportView PostReportView `json:"post_report_view"`
}

// PostReportView A post report view.
type PostReportView struct {
	// Community A community.
	Community Community `json:"community"`

	// Creator A person.
	Creator                    Person   `json:"creator"`
	CreatorBannedFromCommunity bool     `json:"creator_banned_from_community"`
	CreatorBlocked             bool     `json:"creator_blocked"`
	CreatorIsAdmin             bool     `json:"creator_is_admin"`
	CreatorIsModerator         bool     `json:"creator_is_moderator"`
	Hidden                     bool     `json:"hidden"`
	MyVote                     *float64 `json:"my_vote,omitempty"`

	// Post A post.
	Post Post `json:"post"`

	// PostCreator A person.
	PostCreator Person `json:"post_creator"`

	// PostReport A post report.
	PostReport PostReport `json:"post_report"`
	Read       bool       `json:"read"`

	// Resolver A person.
	Resolver *Person `json:"resolver,omitempty"`

	// Saved The time when the post was saved.
	Saved *string `json:"saved,omitempty"`

	// Subscribed A type / status for a community subscribe.
	Subscribed     SubscribedType `json:"subscribed"`
	UnreadComments float64        `json:"unread_comments"`
}

// PostResponse defines model for PostResponse.
type PostResponse struct {
	// PostView A post view.
	PostView PostView `json:"post_view"`
}

// PostSortType The post sort types. See here for descriptions: https://join-lemmy.org/docs/en/users/03-votes-and-ranking.html
type PostSortType string

// PostTags we wrap this in a struct so we can implement FromSqlRow<Json> for it
type PostTags struct {
	Tags []Tag `json:"tags"`
}

// PostView A post view.
type PostView struct {
	BannedFromCommunity bool `json:"banned_from_community"`
	CanMod              bool `json:"can_mod"`

	// Community A community.
	Community Community `json:"community"`

	// Creator A person.
	Creator                    Person        `json:"creator"`
	CreatorBannedFromCommunity bool          `json:"creator_banned_from_community"`
	CreatorBlocked             bool          `json:"creator_blocked"`
	CreatorIsAdmin             bool          `json:"creator_is_admin"`
	CreatorIsModerator         bool          `json:"creator_is_moderator"`
	Hidden                     bool          `json:"hidden"`
	ImageDetails               *ImageDetails `json:"image_details,omitempty"`
	MyVote                     *float64      `json:"my_vote,omitempty"`

	// Post A post.
	Post Post `json:"post"`
	Read bool `json:"read"`

	// Saved The time when the post was saved.
	Saved *string `json:"saved,omitempty"`

	// Subscribed A type / status for a community subscribe.
	Subscribed SubscribedType `json:"subscribed"`

	// Tags we wrap this in a struct so we can implement FromSqlRow<Json> for it
	Tags           PostTags `json:"tags"`
	UnreadComments float64  `json:"unread_comments"`
}

// PrivateMessage A private message.
type PrivateMessage struct {
	ApId    DbUrl  `json:"ap_id"`
	Content string `json:"content"`

	// CreatorId The person id.
	CreatorId PersonId `json:"creator_id"`
	Deleted   bool     `json:"deleted"`

	// Id The private message id.
	Id        PrivateMessageId `json:"id"`
	Local     bool             `json:"local"`
	Published string           `json:"published"`
	Read      bool             `json:"read"`

	// RecipientId The person id.
	RecipientId PersonId `json:"recipient_id"`
	Removed     bool     `json:"removed"`
	Updated     *string  `json:"updated,omitempty"`
}

// PrivateMessageId The private message id.
type PrivateMessageId = float64

// PrivateMessageReport The private message report.
type PrivateMessageReport struct {
	// CreatorId The person id.
	CreatorId PersonId `json:"creator_id"`

	// Id The private message report id.
	Id PrivateMessageReportId `json:"id"`

	// OriginalPmText The original text.
	OriginalPmText string `json:"original_pm_text"`

	// PrivateMessageId The private message id.
	PrivateMessageId PrivateMessageId `json:"private_message_id"`
	Published        string           `json:"published"`
	Reason           string           `json:"reason"`
	Resolved         bool             `json:"resolved"`

	// ResolverId The person id.
	ResolverId *PersonId `json:"resolver_id,omitempty"`
	Updated    *string   `json:"updated,omitempty"`
}

// PrivateMessageReportId The private message report id.
type PrivateMessageReportId = float64

// PrivateMessageReportResponse A private message report response.
type PrivateMessageReportResponse struct {
	// PrivateMessageReportView A private message report view.
	PrivateMessageReportView PrivateMessageReportView `json:"private_message_report_view"`
}

// PrivateMessageReportView A private message report view.
type PrivateMessageReportView struct {
	// Creator A person.
	Creator Person `json:"creator"`

	// PrivateMessage A private message.
	PrivateMessage PrivateMessage `json:"private_message"`

	// PrivateMessageCreator A person.
	PrivateMessageCreator Person `json:"private_message_creator"`

	// PrivateMessageReport The private message report.
	PrivateMessageReport PrivateMessageReport `json:"private_message_report"`

	// Resolver A person.
	Resolver *Person `json:"resolver,omitempty"`
}

// PrivateMessageResponse A single private message response.
type PrivateMessageResponse struct {
	// PrivateMessageView A private message view.
	PrivateMessageView PrivateMessageView `json:"private_message_view"`
}

// PrivateMessageView A private message view.
type PrivateMessageView struct {
	// Creator A person.
	Creator Person `json:"creator"`

	// PrivateMessage A private message.
	PrivateMessage PrivateMessage `json:"private_message"`

	// Recipient A person.
	Recipient Person `json:"recipient"`
}

// PublicOAuthProvider oauth provider with client_secret - should never be sent to the client
type PublicOAuthProvider = OAuthProvider

// PurgeComment Purges a comment from the database. This will delete all content attached to that comment.
type PurgeComment struct {
	// CommentId The comment id.
	CommentId CommentId `json:"comment_id"`
	Reason    *string   `json:"reason,omitempty"`
}

// PurgeCommunity Purges a community from the database. This will delete all content attached to that community.
type PurgeCommunity struct {
	// CommunityId The community id.
	CommunityId CommunityId `json:"community_id"`
	Reason      *string     `json:"reason,omitempty"`
}

// PurgePerson Purges a person from the database. This will delete all content attached to that person.
type PurgePerson struct {
	// PersonId The person id.
	PersonId PersonId `json:"person_id"`
	Reason   *string  `json:"reason,omitempty"`
}

// PurgePost Purges a post from the database. This will delete all content attached to that post.
type PurgePost struct {
	// PostId The post id.
	PostId PostId  `json:"post_id"`
	Reason *string `json:"reason,omitempty"`
}

// ReadableFederationState defines model for ReadableFederationState.
type ReadableFederationState struct {
	// FailCount how many failed attempts have been made to send the next activity
	FailCount float64 `json:"fail_count"`

	// InstanceId The instance id.
	InstanceId InstanceId `json:"instance_id"`

	// LastRetry timestamp of the last retry attempt (when the last failing activity was resent)
	LastRetry                   *string     `json:"last_retry,omitempty"`
	LastSuccessfulId            *ActivityId `json:"last_successful_id,omitempty"`
	LastSuccessfulPublishedTime *string     `json:"last_successful_published_time,omitempty"`

	// NextRetry timestamp of the next retry attempt (null if fail count is 0)
	NextRetry *string `json:"next_retry,omitempty"`
}

// Register Register / Sign up to lemmy.
type Register struct {
	// Answer An answer is mandatory if require application is enabled on the server
	Answer *string `json:"answer,omitempty"`

	// CaptchaAnswer Your captcha answer.
	CaptchaAnswer *string `json:"captcha_answer,omitempty"`

	// CaptchaUuid The UUID of the captcha item.
	CaptchaUuid *string          `json:"captcha_uuid,omitempty"`
	Email       *SensitiveString `json:"email,omitempty"`

	// Honeypot A form field to trick signup bots. Should be None.
	Honeypot       *string         `json:"honeypot,omitempty"`
	Password       SensitiveString `json:"password"`
	PasswordVerify SensitiveString `json:"password_verify"`
	ShowNsfw       *bool           `json:"show_nsfw,omitempty"`
	Username       string          `json:"username"`
}

// RegistrationApplication A registration application.
type RegistrationApplication struct {
	// AdminId The person id.
	AdminId    *PersonId `json:"admin_id,omitempty"`
	Answer     string    `json:"answer"`
	DenyReason *string   `json:"deny_reason,omitempty"`

	// Id The registration application id.
	Id RegistrationApplicationId `json:"id"`

	// LocalUserId The local user id.
	LocalUserId LocalUserId `json:"local_user_id"`
	Published   string      `json:"published"`
}

// RegistrationApplicationId The registration application id.
type RegistrationApplicationId = float64

// RegistrationApplicationResponse The response of an action done to a registration application.
type RegistrationApplicationResponse struct {
	// RegistrationApplication A registration application view.
	RegistrationApplication RegistrationApplicationView `json:"registration_application"`
}

// RegistrationApplicationView A registration application view.
type RegistrationApplicationView struct {
	// Admin A person.
	Admin *Person `json:"admin,omitempty"`

	// Creator A person.
	Creator Person `json:"creator"`

	// CreatorLocalUser A local user.
	CreatorLocalUser LocalUser `json:"creator_local_user"`

	// RegistrationApplication A registration application.
	RegistrationApplication RegistrationApplication `json:"registration_application"`
}

// RegistrationMode The registration mode for your site. Determines what happens after a user signs up.
type RegistrationMode string

// RemoveComment Remove a comment (only doable by mods).
type RemoveComment struct {
	// CommentId The comment id.
	CommentId CommentId `json:"comment_id"`
	Reason    *string   `json:"reason,omitempty"`
	Removed   bool      `json:"removed"`
}

// RemoveCommunity Remove a community (only doable by moderators).
type RemoveCommunity struct {
	// CommunityId The community id.
	CommunityId CommunityId `json:"community_id"`
	Reason      *string     `json:"reason,omitempty"`
	Removed     bool        `json:"removed"`
}

// RemovePost Remove a post (only doable by mods).
type RemovePost struct {
	// PostId The post id.
	PostId  PostId  `json:"post_id"`
	Reason  *string `json:"reason,omitempty"`
	Removed bool    `json:"removed"`
}

// ReportCombinedPaginationCursor like PaginationCursor but for the report_combined table
type ReportCombinedPaginationCursor = string

// ReportCombinedView defines model for ReportCombinedView.
type ReportCombinedView struct {
	union json.RawMessage
}

// ReportCombinedView0 defines model for .
type ReportCombinedView0 struct {
	// Community A community.
	Community Community `json:"community"`

	// Creator A person.
	Creator                    Person   `json:"creator"`
	CreatorBannedFromCommunity bool     `json:"creator_banned_from_community"`
	CreatorBlocked             bool     `json:"creator_blocked"`
	CreatorIsAdmin             bool     `json:"creator_is_admin"`
	CreatorIsModerator         bool     `json:"creator_is_moderator"`
	Hidden                     bool     `json:"hidden"`
	MyVote                     *float64 `json:"my_vote,omitempty"`

	// Post A post.
	Post Post `json:"post"`

	// PostCreator A person.
	PostCreator Person `json:"post_creator"`

	// PostReport A post report.
	PostReport PostReport `json:"post_report"`
	Read       bool       `json:"read"`

	// Resolver A person.
	Resolver *Person `json:"resolver,omitempty"`

	// Saved The time when the post was saved.
	Saved *string `json:"saved,omitempty"`

	// Subscribed A type / status for a community subscribe.
	Subscribed     SubscribedType          `json:"subscribed"`
	Type           ReportCombinedView0Type `json:"type_"`
	UnreadComments float64                 `json:"unread_comments"`
}

// ReportCombinedView0Type defines model for ReportCombinedView.0.Type.
type ReportCombinedView0Type string

// ReportCombinedView1 defines model for .
type ReportCombinedView1 struct {
	// Comment A comment.
	Comment Comment `json:"comment"`

	// CommentCreator A person.
	CommentCreator Person `json:"comment_creator"`

	// CommentReport A comment report.
	CommentReport CommentReport `json:"comment_report"`

	// Community A community.
	Community Community `json:"community"`

	// Creator A person.
	Creator                    Person   `json:"creator"`
	CreatorBannedFromCommunity bool     `json:"creator_banned_from_community"`
	CreatorBlocked             bool     `json:"creator_blocked"`
	CreatorIsAdmin             bool     `json:"creator_is_admin"`
	CreatorIsModerator         bool     `json:"creator_is_moderator"`
	MyVote                     *float64 `json:"my_vote,omitempty"`

	// Post A post.
	Post Post `json:"post"`

	// Resolver A person.
	Resolver *Person `json:"resolver,omitempty"`

	// Saved The time when the comment was saved.
	Saved *string `json:"saved,omitempty"`

	// Subscribed A type / status for a community subscribe.
	Subscribed SubscribedType          `json:"subscribed"`
	Type       ReportCombinedView1Type `json:"type_"`
}

// ReportCombinedView1Type defines model for ReportCombinedView.1.Type.
type ReportCombinedView1Type string

// ReportCombinedView2 defines model for .
type ReportCombinedView2 struct {
	// Creator A person.
	Creator Person `json:"creator"`

	// PrivateMessage A private message.
	PrivateMessage PrivateMessage `json:"private_message"`

	// PrivateMessageCreator A person.
	PrivateMessageCreator Person `json:"private_message_creator"`

	// PrivateMessageReport The private message report.
	PrivateMessageReport PrivateMessageReport `json:"private_message_report"`

	// Resolver A person.
	Resolver *Person                 `json:"resolver,omitempty"`
	Type     ReportCombinedView2Type `json:"type_"`
}

// ReportCombinedView2Type defines model for ReportCombinedView.2.Type.
type ReportCombinedView2Type string

// ReportCombinedView3 defines model for .
type ReportCombinedView3 struct {
	// Community A community.
	Community Community `json:"community"`

	// CommunityReport A comment report.
	CommunityReport CommunityReport `json:"community_report"`

	// Creator A person.
	Creator Person `json:"creator"`

	// Resolver A person.
	Resolver *Person `json:"resolver,omitempty"`

	// Subscribed A type / status for a community subscribe.
	Subscribed SubscribedType          `json:"subscribed"`
	Type       ReportCombinedView3Type `json:"type_"`
}

// ReportCombinedView3Type defines model for ReportCombinedView.3.Type.
type ReportCombinedView3Type string

// ReportType A list of possible types for reports.
type ReportType string

// ResendVerificationEmail Make a request to resend your verification email.
type ResendVerificationEmail struct {
	Email SensitiveString `json:"email"`
}

// ResolveCommentReport Resolve a comment report (only doable by mods).
type ResolveCommentReport struct {
	// ReportId The comment report id.
	ReportId CommentReportId `json:"report_id"`
	Resolved bool            `json:"resolved"`
}

// ResolveObjectResponse The response of an apub object fetch.
type ResolveObjectResponse struct {
	// Comment A comment view.
	Comment *CommentView `json:"comment,omitempty"`

	// Community A community view.
	Community *CommunityView `json:"community,omitempty"`

	// Person A person view.
	Person *PersonView `json:"person,omitempty"`

	// Post A post view.
	Post *PostView `json:"post,omitempty"`
}

// ResolvePostReport Resolve a post report (mods only).
type ResolvePostReport struct {
	// ReportId The post report id.
	ReportId PostReportId `json:"report_id"`
	Resolved bool         `json:"resolved"`
}

// ResolvePrivateMessageReport Resolve a private message report.
type ResolvePrivateMessageReport struct {
	// ReportId The private message report id.
	ReportId PrivateMessageReportId `json:"report_id"`
	Resolved bool                   `json:"resolved"`
}

// SaveComment Save / bookmark a comment.
type SaveComment struct {
	// CommentId The comment id.
	CommentId CommentId `json:"comment_id"`
	Save      bool      `json:"save"`
}

// SavePost Save / bookmark a post.
type SavePost struct {
	// PostId The post id.
	PostId PostId `json:"post_id"`
	Save   bool   `json:"save"`
}

// SaveUserSettings Saves settings for your user.
type SaveUserSettings struct {
	// AutoMarkFetchedPostsAsRead Whether to automatically mark fetched posts as read.
	AutoMarkFetchedPostsAsRead *bool `json:"auto_mark_fetched_posts_as_read,omitempty"`

	// Bio Your bio / info, in markdown.
	Bio *string `json:"bio,omitempty"`

	// BlurNsfw Blur nsfw posts.
	BlurNsfw *bool `json:"blur_nsfw,omitempty"`

	// BotAccount Whether this account is a bot account. Users can hide these accounts easily if they wish.
	BotAccount *bool `json:"bot_account,omitempty"`

	// CollapseBotComments Whether to auto-collapse bot comments.
	CollapseBotComments *bool `json:"collapse_bot_comments,omitempty"`

	// DefaultCommentSortType The comment sort types. See here for descriptions: https://join-lemmy.org/docs/en/users/03-votes-and-ranking.html
	DefaultCommentSortType *CommentSortType `json:"default_comment_sort_type,omitempty"`

	// DefaultListingType A listing type for post and comment list fetches.
	DefaultListingType *ListingType `json:"default_listing_type,omitempty"`

	// DefaultPostSortType The post sort types. See here for descriptions: https://join-lemmy.org/docs/en/users/03-votes-and-ranking.html
	DefaultPostSortType *PostSortType `json:"default_post_sort_type,omitempty"`

	// DefaultPostTimeRangeSeconds A default time range limit to apply to post sorts, in seconds. 0 means none.
	DefaultPostTimeRangeSeconds *float64 `json:"default_post_time_range_seconds,omitempty"`

	// DiscussionLanguages A list of languages you are able to see discussion in.
	DiscussionLanguages *[]LanguageId `json:"discussion_languages,omitempty"`

	// DisplayName Your display name, which can contain strange characters, and does not need to be unique.
	DisplayName *string          `json:"display_name,omitempty"`
	Email       *SensitiveString `json:"email,omitempty"`

	// EnableAnimatedImages Whether user avatars or inline images in the UI that are gifs should be allowed to play or
	// should be paused
	EnableAnimatedImages *bool `json:"enable_animated_images,omitempty"`

	// EnableKeyboardNavigation Whether to allow keyboard navigation (for browsing and interacting with posts and comments).
	EnableKeyboardNavigation *bool `json:"enable_keyboard_navigation,omitempty"`

	// EnablePrivateMessages Whether a user can send / receive private messages
	EnablePrivateMessages *bool `json:"enable_private_messages,omitempty"`

	// HideMedia Whether to hide posts containing images/videos.
	HideMedia *bool `json:"hide_media,omitempty"`

	// InfiniteScrollEnabled Enable infinite scroll
	InfiniteScrollEnabled *bool `json:"infinite_scroll_enabled,omitempty"`

	// InterfaceLanguage The language of the lemmy interface
	InterfaceLanguage *string `json:"interface_language,omitempty"`

	// MatrixUserId Your matrix user id. Ex:
	MatrixUserId *string `json:"matrix_user_id,omitempty"`

	// OpenLinksInNewTab Open links in a new tab
	OpenLinksInNewTab *bool `json:"open_links_in_new_tab,omitempty"`

	// PostListingMode A post-view mode that changes how multiple post listings look.
	PostListingMode *PostListingMode `json:"post_listing_mode,omitempty"`

	// SendNotificationsToEmail Sends notifications to your email.
	SendNotificationsToEmail *bool `json:"send_notifications_to_email,omitempty"`

	// ShowAvatars Whether to show or hide avatars.
	ShowAvatars *bool `json:"show_avatars,omitempty"`

	// ShowBotAccounts Whether to show bot accounts.
	ShowBotAccounts *bool `json:"show_bot_accounts,omitempty"`
	ShowDownvotes   *bool `json:"show_downvotes,omitempty"`

	// ShowNsfw Show nsfw posts.
	ShowNsfw *bool `json:"show_nsfw,omitempty"`

	// ShowReadPosts Whether to show read posts.
	ShowReadPosts *bool `json:"show_read_posts,omitempty"`

	// ShowScores Some vote display mode settings
	ShowScores           *bool `json:"show_scores,omitempty"`
	ShowUpvotePercentage *bool `json:"show_upvote_percentage,omitempty"`
	ShowUpvotes          *bool `json:"show_upvotes,omitempty"`

	// Theme Your user's theme.
	Theme *string `json:"theme,omitempty"`
}

// SearchCombinedPaginationCursor like PaginationCursor but for the modlog_combined
type SearchCombinedPaginationCursor = string

// SearchCombinedView defines model for SearchCombinedView.
type SearchCombinedView struct {
	union json.RawMessage
}

// SearchCombinedView0 defines model for .
type SearchCombinedView0 struct {
	BannedFromCommunity bool `json:"banned_from_community"`
	CanMod              bool `json:"can_mod"`

	// Community A community.
	Community Community `json:"community"`

	// Creator A person.
	Creator                    Person        `json:"creator"`
	CreatorBannedFromCommunity bool          `json:"creator_banned_from_community"`
	CreatorBlocked             bool          `json:"creator_blocked"`
	CreatorIsAdmin             bool          `json:"creator_is_admin"`
	CreatorIsModerator         bool          `json:"creator_is_moderator"`
	Hidden                     bool          `json:"hidden"`
	ImageDetails               *ImageDetails `json:"image_details,omitempty"`
	MyVote                     *float64      `json:"my_vote,omitempty"`

	// Post A post.
	Post Post `json:"post"`
	Read bool `json:"read"`

	// Saved The time when the post was saved.
	Saved *string `json:"saved,omitempty"`

	// Subscribed A type / status for a community subscribe.
	Subscribed SubscribedType `json:"subscribed"`

	// Tags we wrap this in a struct so we can implement FromSqlRow<Json> for it
	Tags           PostTags                `json:"tags"`
	Type           SearchCombinedView0Type `json:"type_"`
	UnreadComments float64                 `json:"unread_comments"`
}

// SearchCombinedView0Type defines model for SearchCombinedView.0.Type.
type SearchCombinedView0Type string

// SearchCombinedView1 defines model for .
type SearchCombinedView1 struct {
	BannedFromCommunity bool `json:"banned_from_community"`
	CanMod              bool `json:"can_mod"`

	// Comment A comment.
	Comment Comment `json:"comment"`

	// Community A community.
	Community Community `json:"community"`

	// Creator A person.
	Creator                    Person   `json:"creator"`
	CreatorBannedFromCommunity bool     `json:"creator_banned_from_community"`
	CreatorBlocked             bool     `json:"creator_blocked"`
	CreatorIsAdmin             bool     `json:"creator_is_admin"`
	CreatorIsModerator         bool     `json:"creator_is_moderator"`
	MyVote                     *float64 `json:"my_vote,omitempty"`

	// Post A post.
	Post Post `json:"post"`

	// Saved The time when the comment was saved.
	Saved *string `json:"saved,omitempty"`

	// Subscribed A type / status for a community subscribe.
	Subscribed SubscribedType          `json:"subscribed"`
	Type       SearchCombinedView1Type `json:"type_"`
}

// SearchCombinedView1Type defines model for SearchCombinedView.1.Type.
type SearchCombinedView1Type string

// SearchCombinedView2 defines model for .
type SearchCombinedView2 struct {
	BannedFromCommunity bool `json:"banned_from_community"`
	Blocked             bool `json:"blocked"`
	CanMod              bool `json:"can_mod"`

	// Community A community.
	Community Community `json:"community"`

	// Subscribed A type / status for a community subscribe.
	Subscribed SubscribedType          `json:"subscribed"`
	Type       SearchCombinedView2Type `json:"type_"`
}

// SearchCombinedView2Type defines model for SearchCombinedView.2.Type.
type SearchCombinedView2Type string

// SearchCombinedView3 defines model for .
type SearchCombinedView3 struct {
	IsAdmin bool `json:"is_admin"`

	// Person A person.
	Person Person                  `json:"person"`
	Type   SearchCombinedView3Type `json:"type_"`
}

// SearchCombinedView3Type defines model for SearchCombinedView.3.Type.
type SearchCombinedView3Type string

// SearchResponse The search response, containing lists of the return type possibilities
type SearchResponse struct {
	Results []SearchCombinedView `json:"results"`
}

// SearchSortType The search sort types.
type SearchSortType string

// SearchType The type of content returned from a search.
type SearchType string

// SensitiveString defines model for SensitiveString.
type SensitiveString = string

// Site The site.
type Site struct {
	ApId   DbUrl  `json:"ap_id"`
	Banner *DbUrl `json:"banner,omitempty"`

	// ContentWarning If present, nsfw content is visible by default. Should be displayed by frontends/clients
	// when the site is first opened by a user.
	ContentWarning *string `json:"content_warning,omitempty"`

	// Description A shorter, one-line description of the site.
	Description *string `json:"description,omitempty"`
	Icon        *DbUrl  `json:"icon,omitempty"`

	// Id The site id.
	Id       SiteId `json:"id"`
	InboxUrl DbUrl  `json:"inbox_url"`

	// InstanceId The instance id.
	InstanceId InstanceId `json:"instance_id"`

	// LastRefreshedAt The time the site was last refreshed.
	LastRefreshedAt string `json:"last_refreshed_at"`
	Name            string `json:"name"`
	PublicKey       string `json:"public_key"`
	Published       string `json:"published"`

	// Sidebar A sidebar for the site in markdown.
	Sidebar *string `json:"sidebar,omitempty"`
	Updated *string `json:"updated,omitempty"`
}

// SiteId The site id.
type SiteId = float64

// SiteResponse The response for a site.
type SiteResponse struct {
	// SiteView A site view.
	SiteView SiteView `json:"site_view"`

	// Taglines deprecated, use field `tagline` or /api/v4/tagline/list
	Taglines []float32 `json:"taglines"`
}

// SiteView A site view.
type SiteView struct {
	// LocalSite The local site.
	LocalSite LocalSite `json:"local_site"`

	// LocalSiteRateLimit Rate limits for your site. Given in count / length of time.
	LocalSiteRateLimit LocalSiteRateLimit `json:"local_site_rate_limit"`

	// Site The site.
	Site Site `json:"site"`
}

// SubscribedType A type / status for a community subscribe.
type SubscribedType string

// SuccessResponse A response that completes successfully.
type SuccessResponse struct {
	Success bool `json:"success"`
}

// Tag A tag that can be assigned to a post within a community.
// The tag object is created by the community moderators.
// The assignment happens by the post creator and can be updated by the community moderators.
//
// A tag is a federatable object that gives additional context to another object, which can be
// displayed and filtered on currently, we only have community post tags, which is a tag that is
// created by post authors as well as mods  of a community, to categorize a post. in the future we
// may add more tag types, depending on the requirements, this will lead to either expansion of
// this table (community_id optional, addition of tag_type enum) or split of this table / creation
// of new tables.
type Tag struct {
	ApId DbUrl `json:"ap_id"`

	// CommunityId The community id.
	CommunityId CommunityId `json:"community_id"`
	Deleted     bool        `json:"deleted"`

	// Id The internal tag id.
	Id        TagId   `json:"id"`
	Name      string  `json:"name"`
	Published string  `json:"published"`
	Updated   *string `json:"updated,omitempty"`
}

// TagId The internal tag id.
type TagId = float64

// Tagline A tagline, shown at the top of your site.
type Tagline struct {
	Content   string  `json:"content"`
	Id        float64 `json:"id"`
	Published string  `json:"published"`
	Updated   *string `json:"updated,omitempty"`
}

// TaglineId The tagline id.
type TaglineId = float64

// TaglineResponse defines model for TaglineResponse.
type TaglineResponse struct {
	// Tagline A tagline, shown at the top of your site.
	Tagline Tagline `json:"tagline"`
}

// TransferCommunity Transfer a community to a new owner.
type TransferCommunity struct {
	// CommunityId The community id.
	CommunityId CommunityId `json:"community_id"`

	// PersonId The person id.
	PersonId PersonId `json:"person_id"`
}

// UpdateTagline Update a tagline
type UpdateTagline struct {
	Content string `json:"content"`

	// Id The tagline id.
	Id TaglineId `json:"id"`
}

// UpdateTotp defines model for UpdateTotp.
type UpdateTotp struct {
	Enabled   bool   `json:"enabled"`
	TotpToken string `json:"totp_token"`
}

// UpdateTotpResponse defines model for UpdateTotpResponse.
type UpdateTotpResponse struct {
	Enabled bool `json:"enabled"`
}

// UploadImageResponse defines model for UploadImageResponse.
type UploadImageResponse struct {
	Filename string `json:"filename"`
	ImageUrl string `json:"image_url"`
}

// UserBlockInstanceParams Block an instance as user
type UserBlockInstanceParams struct {
	Block bool `json:"block"`

	// InstanceId The instance id.
	InstanceId InstanceId `json:"instance_id"`
}

// VerifyEmail Verify your email.
type VerifyEmail struct {
	Token string `json:"token"`
}

// VoteView A vote view for checking a post or comments votes.
type VoteView struct {
	// Creator A person.
	Creator                    Person  `json:"creator"`
	CreatorBannedFromCommunity bool    `json:"creator_banned_from_community"`
	Score                      float64 `json:"score"`
}

// ListPersonSavedParams defines parameters for ListPersonSaved.
type ListPersonSavedParams struct {
	PageBack   *bool                                `form:"page_back,omitempty" json:"page_back,omitempty"`
	PageCursor *PersonSavedCombinedPaginationCursor `form:"page_cursor,omitempty" json:"page_cursor,omitempty"`
	Type       *PersonContentType                   `form:"type_,omitempty" json:"type_,omitempty"`
}

// UploadUserAvatarMultipartBody defines parameters for UploadUserAvatar.
type UploadUserAvatarMultipartBody struct {
	Image openapi_types.File `json:"image"`
}

// UploadUserBannerMultipartBody defines parameters for UploadUserBanner.
type UploadUserBannerMultipartBody struct {
	Image openapi_types.File `json:"image"`
}

// ListInboxParams defines parameters for ListInbox.
type ListInboxParams struct {
	PageBack   *bool                          `form:"page_back,omitempty" json:"page_back,omitempty"`
	PageCursor *InboxCombinedPaginationCursor `form:"page_cursor,omitempty" json:"page_cursor,omitempty"`
	UnreadOnly *bool                          `form:"unread_only,omitempty" json:"unread_only,omitempty"`
	Type       *InboxDataType                 `form:"type_,omitempty" json:"type_,omitempty"`
}

// ListMediaParams defines parameters for ListMedia.
type ListMediaParams struct {
	Limit *float64 `form:"limit,omitempty" json:"limit,omitempty"`
	Page  *float64 `form:"page,omitempty" json:"page,omitempty"`
}

// GetReportCountParams defines parameters for GetReportCount.
type GetReportCountParams struct {
	CommunityId *CommunityId `form:"community_id,omitempty" json:"community_id,omitempty"`
}

// ImportSettingsJSONBody defines parameters for ImportSettings.
type ImportSettingsJSONBody = interface{}

// ListAllMediaParams defines parameters for ListAllMedia.
type ListAllMediaParams struct {
	Limit *float64 `form:"limit,omitempty" json:"limit,omitempty"`
	Page  *float64 `form:"page,omitempty" json:"page,omitempty"`
}

// GetRegistrationApplicationParams defines parameters for GetRegistrationApplication.
type GetRegistrationApplicationParams struct {
	PersonId PersonId `form:"person_id" json:"person_id"`
}

// ListRegistrationApplicationsParams defines parameters for ListRegistrationApplications.
type ListRegistrationApplicationsParams struct {
	Limit *float64 `form:"limit,omitempty" json:"limit,omitempty"`
	Page  *float64 `form:"page,omitempty" json:"page,omitempty"`

	// UnreadOnly Only shows the unread applications (IE those without an admin actor)
	UnreadOnly *bool `form:"unread_only,omitempty" json:"unread_only,omitempty"`
}

// ListTaglinesParams defines parameters for ListTaglines.
type ListTaglinesParams struct {
	Limit *float64 `form:"limit,omitempty" json:"limit,omitempty"`
	Page  *float64 `form:"page,omitempty" json:"page,omitempty"`
}

// GetCommentParams defines parameters for GetComment.
type GetCommentParams struct {
	Id CommentId `form:"id" json:"id"`
}

// ListCommentLikesParams defines parameters for ListCommentLikes.
type ListCommentLikesParams struct {
	Limit     *float64  `form:"limit,omitempty" json:"limit,omitempty"`
	Page      *float64  `form:"page,omitempty" json:"page,omitempty"`
	CommentId CommentId `form:"comment_id" json:"comment_id"`
}

// GetCommentsParams defines parameters for GetComments.
type GetCommentsParams struct {
	DislikedOnly  *bool        `form:"disliked_only,omitempty" json:"disliked_only,omitempty"`
	LikedOnly     *bool        `form:"liked_only,omitempty" json:"liked_only,omitempty"`
	ParentId      *CommentId   `form:"parent_id,omitempty" json:"parent_id,omitempty"`
	PostId        *PostId      `form:"post_id,omitempty" json:"post_id,omitempty"`
	CommunityName *string      `form:"community_name,omitempty" json:"community_name,omitempty"`
	CommunityId   *CommunityId `form:"community_id,omitempty" json:"community_id,omitempty"`
	Limit         *float64     `form:"limit,omitempty" json:"limit,omitempty"`
	Page          *float64     `form:"page,omitempty" json:"page,omitempty"`
	MaxDepth      *float64     `form:"max_depth,omitempty" json:"max_depth,omitempty"`

	// TimeRangeSeconds Filter to within a given time range, in seconds.
	// IE 60 would give results for the past minute.
	TimeRangeSeconds *float64         `form:"time_range_seconds,omitempty" json:"time_range_seconds,omitempty"`
	Sort             *CommentSortType `form:"sort,omitempty" json:"sort,omitempty"`
	Type             *ListingType     `form:"type_,omitempty" json:"type_,omitempty"`
}

// GetCommentsSlimParams defines parameters for GetCommentsSlim.
type GetCommentsSlimParams struct {
	DislikedOnly  *bool        `form:"disliked_only,omitempty" json:"disliked_only,omitempty"`
	LikedOnly     *bool        `form:"liked_only,omitempty" json:"liked_only,omitempty"`
	ParentId      *CommentId   `form:"parent_id,omitempty" json:"parent_id,omitempty"`
	PostId        *PostId      `form:"post_id,omitempty" json:"post_id,omitempty"`
	CommunityName *string      `form:"community_name,omitempty" json:"community_name,omitempty"`
	CommunityId   *CommunityId `form:"community_id,omitempty" json:"community_id,omitempty"`
	Limit         *float64     `form:"limit,omitempty" json:"limit,omitempty"`
	Page          *float64     `form:"page,omitempty" json:"page,omitempty"`
	MaxDepth      *float64     `form:"max_depth,omitempty" json:"max_depth,omitempty"`

	// TimeRangeSeconds Filter to within a given time range, in seconds.
	// IE 60 would give results for the past minute.
	TimeRangeSeconds *float64         `form:"time_range_seconds,omitempty" json:"time_range_seconds,omitempty"`
	Sort             *CommentSortType `form:"sort,omitempty" json:"sort,omitempty"`
	Type             *ListingType     `form:"type_,omitempty" json:"type_,omitempty"`
}

// GetCommunityParams defines parameters for GetCommunity.
type GetCommunityParams struct {
	// Name Example: star_trek , or star_trek@xyz.tld
	Name *string      `form:"name,omitempty" json:"name,omitempty"`
	Id   *CommunityId `form:"id,omitempty" json:"id,omitempty"`
}

// UploadCommunityBannerMultipartBody defines parameters for UploadCommunityBanner.
type UploadCommunityBannerMultipartBody struct {
	Image openapi_types.File `json:"image"`
}

// UploadCommunityIconMultipartBody defines parameters for UploadCommunityIcon.
type UploadCommunityIconMultipartBody struct {
	Image openapi_types.File `json:"image"`
}

// ListCommunitiesParams defines parameters for ListCommunities.
type ListCommunitiesParams struct {
	Limit    *float64 `form:"limit,omitempty" json:"limit,omitempty"`
	Page     *float64 `form:"page,omitempty" json:"page,omitempty"`
	ShowNsfw *bool    `form:"show_nsfw,omitempty" json:"show_nsfw,omitempty"`

	// TimeRangeSeconds Filter to within a given time range, in seconds.
	// IE 60 would give results for the past minute.
	TimeRangeSeconds *float64           `form:"time_range_seconds,omitempty" json:"time_range_seconds,omitempty"`
	Sort             *CommunitySortType `form:"sort,omitempty" json:"sort,omitempty"`
	Type             *ListingType       `form:"type_,omitempty" json:"type_,omitempty"`
}

// GetCommunityPendingFollowsCountParams defines parameters for GetCommunityPendingFollowsCount.
type GetCommunityPendingFollowsCountParams struct {
	CommunityId CommunityId `form:"community_id" json:"community_id"`
}

// ListCommunityPendingFollowsParams defines parameters for ListCommunityPendingFollows.
type ListCommunityPendingFollowsParams struct {
	Limit          *float64 `form:"limit,omitempty" json:"limit,omitempty"`
	Page           *float64 `form:"page,omitempty" json:"page,omitempty"`
	AllCommunities *bool    `form:"all_communities,omitempty" json:"all_communities,omitempty"`

	// PendingOnly Only shows the unapproved applications
	PendingOnly *bool `form:"pending_only,omitempty" json:"pending_only,omitempty"`
}

// GetRandomCommunityParams defines parameters for GetRandomCommunity.
type GetRandomCommunityParams struct {
	ShowNsfw *bool        `form:"show_nsfw,omitempty" json:"show_nsfw,omitempty"`
	Type     *ListingType `form:"type_,omitempty" json:"type_,omitempty"`
}

// ListCustomEmojisParams defines parameters for ListCustomEmojis.
type ListCustomEmojisParams struct {
	IgnorePageLimits *bool    `form:"ignore_page_limits,omitempty" json:"ignore_page_limits,omitempty"`
	Category         *string  `form:"category,omitempty" json:"category,omitempty"`
	Limit            *float64 `form:"limit,omitempty" json:"limit,omitempty"`
	Page             *float64 `form:"page,omitempty" json:"page,omitempty"`
}

// DeleteImageParams defines parameters for DeleteImage.
type DeleteImageParams struct {
	Filename string `form:"filename" json:"filename"`
}

// UploadImageMultipartBody defines parameters for UploadImage.
type UploadImageMultipartBody struct {
	Image openapi_types.File `json:"image"`
}

// GetModlogParams defines parameters for GetModlog.
type GetModlogParams struct {
	PageBack   *bool                           `form:"page_back,omitempty" json:"page_back,omitempty"`
	PageCursor *ModlogCombinedPaginationCursor `form:"page_cursor,omitempty" json:"page_cursor,omitempty"`

	// CommentId Filter by comment.
	CommentId *CommentId `form:"comment_id,omitempty" json:"comment_id,omitempty"`

	// PostId Filter by post. Will include comments of that post.
	PostId *PostId `form:"post_id,omitempty" json:"post_id,omitempty"`

	// OtherPersonId Filter by the other / modded person.
	OtherPersonId *PersonId `form:"other_person_id,omitempty" json:"other_person_id,omitempty"`

	// ListingType Filter by listing type. When not using All, it will remove the non-community modlog entries,
	// such as site bans, instance blocks, adding an admin, etc.
	ListingType *ListingType `form:"listing_type,omitempty" json:"listing_type,omitempty"`

	// Type Filter by the modlog action type.
	Type *ModlogActionType `form:"type_,omitempty" json:"type_,omitempty"`

	// CommunityId Filter by the community.
	CommunityId *CommunityId `form:"community_id,omitempty" json:"community_id,omitempty"`

	// ModPersonId Filter by the moderator.
	ModPersonId *PersonId `form:"mod_person_id,omitempty" json:"mod_person_id,omitempty"`
}

// GetPersonDetailsParams defines parameters for GetPersonDetails.
type GetPersonDetailsParams struct {
	// Username Example: dessalines , or dessalines@xyz.tld
	Username *string   `form:"username,omitempty" json:"username,omitempty"`
	PersonId *PersonId `form:"person_id,omitempty" json:"person_id,omitempty"`
}

// ListPersonContentParams defines parameters for ListPersonContent.
type ListPersonContentParams struct {
	PageBack   *bool                                  `form:"page_back,omitempty" json:"page_back,omitempty"`
	PageCursor *PersonContentCombinedPaginationCursor `form:"page_cursor,omitempty" json:"page_cursor,omitempty"`

	// Username Example: dessalines , or dessalines@xyz.tld
	Username *string            `form:"username,omitempty" json:"username,omitempty"`
	PersonId *PersonId          `form:"person_id,omitempty" json:"person_id,omitempty"`
	Type     *PersonContentType `form:"type_,omitempty" json:"type_,omitempty"`
}

// GetPostParams defines parameters for GetPost.
type GetPostParams struct {
	CommentId *CommentId `form:"comment_id,omitempty" json:"comment_id,omitempty"`
	Id        *PostId    `form:"id,omitempty" json:"id,omitempty"`
}

// ListPostLikesParams defines parameters for ListPostLikes.
type ListPostLikesParams struct {
	Limit  *float64 `form:"limit,omitempty" json:"limit,omitempty"`
	Page   *float64 `form:"page,omitempty" json:"page,omitempty"`
	PostId PostId   `form:"post_id" json:"post_id"`
}

// GetPostsParams defines parameters for GetPosts.
type GetPostsParams struct {
	PageBack   *bool             `form:"page_back,omitempty" json:"page_back,omitempty"`
	PageCursor *PaginationCursor `form:"page_cursor,omitempty" json:"page_cursor,omitempty"`

	// NoCommentsOnly If true, then only show posts with no comments
	NoCommentsOnly *bool `form:"no_comments_only,omitempty" json:"no_comments_only,omitempty"`

	// MarkAsRead Whether to automatically mark fetched posts as read.
	MarkAsRead *bool `form:"mark_as_read,omitempty" json:"mark_as_read,omitempty"`

	// HideMedia If false, then show posts with media attached (even if your user setting is to hide them)
	HideMedia *bool `form:"hide_media,omitempty" json:"hide_media,omitempty"`

	// ShowNsfw If true, then show the nsfw posts (even if your user setting is to hide them)
	ShowNsfw *bool `form:"show_nsfw,omitempty" json:"show_nsfw,omitempty"`

	// ShowRead If true, then show the read posts (even if your user setting is to hide them)
	ShowRead      *bool        `form:"show_read,omitempty" json:"show_read,omitempty"`
	ShowHidden    *bool        `form:"show_hidden,omitempty" json:"show_hidden,omitempty"`
	DislikedOnly  *bool        `form:"disliked_only,omitempty" json:"disliked_only,omitempty"`
	LikedOnly     *bool        `form:"liked_only,omitempty" json:"liked_only,omitempty"`
	ReadOnly      *bool        `form:"read_only,omitempty" json:"read_only,omitempty"`
	SavedOnly     *bool        `form:"saved_only,omitempty" json:"saved_only,omitempty"`
	CommunityName *string      `form:"community_name,omitempty" json:"community_name,omitempty"`
	CommunityId   *CommunityId `form:"community_id,omitempty" json:"community_id,omitempty"`
	Limit         *float64     `form:"limit,omitempty" json:"limit,omitempty"`

	// Page DEPRECATED, use page_cursor
	Page *float64 `form:"page,omitempty" json:"page,omitempty"`

	// TimeRangeSeconds Filter to within a given time range, in seconds.
	// IE 60 would give results for the past minute.
	// Use Zero to override the local_site and local_user time_range.
	TimeRangeSeconds *float64      `form:"time_range_seconds,omitempty" json:"time_range_seconds,omitempty"`
	Sort             *PostSortType `form:"sort,omitempty" json:"sort,omitempty"`
	Type             *ListingType  `form:"type_,omitempty" json:"type_,omitempty"`
}

// GetSiteMetadataParams defines parameters for GetSiteMetadata.
type GetSiteMetadataParams struct {
	Url string `form:"url" json:"url"`
}

// ListReportsParams defines parameters for ListReports.
type ListReportsParams struct {
	// MyReportsOnly If true, view all your created reports. Works for non-admins/mods also.
	MyReportsOnly *bool `form:"my_reports_only,omitempty" json:"my_reports_only,omitempty"`

	// ShowCommunityRuleViolations Only for admins: also show reports with `violates_instance_rules=false`
	ShowCommunityRuleViolations *bool                           `form:"show_community_rule_violations,omitempty" json:"show_community_rule_violations,omitempty"`
	PageBack                    *bool                           `form:"page_back,omitempty" json:"page_back,omitempty"`
	PageCursor                  *ReportCombinedPaginationCursor `form:"page_cursor,omitempty" json:"page_cursor,omitempty"`

	// CommunityId if no community is given, it returns reports for all communities moderated by the auth user
	CommunityId *CommunityId `form:"community_id,omitempty" json:"community_id,omitempty"`

	// PostId Filter by the post id. Can return either comment or post reports.
	PostId *PostId `form:"post_id,omitempty" json:"post_id,omitempty"`

	// Type Filter the type of report.
	Type *ReportType `form:"type_,omitempty" json:"type_,omitempty"`

	// UnresolvedOnly Only shows the unresolved reports
	UnresolvedOnly *bool `form:"unresolved_only,omitempty" json:"unresolved_only,omitempty"`
}

// ResolveObjectParams defines parameters for ResolveObject.
type ResolveObjectParams struct {
	// Q Can be the full url, or a shortened version like: !fediverse@lemmy.ml
	Q string `form:"q" json:"q"`
}

// SearchParams defines parameters for Search.
type SearchParams struct {
	PageBack     *bool                           `form:"page_back,omitempty" json:"page_back,omitempty"`
	PageCursor   *SearchCombinedPaginationCursor `form:"page_cursor,omitempty" json:"page_cursor,omitempty"`
	DislikedOnly *bool                           `form:"disliked_only,omitempty" json:"disliked_only,omitempty"`
	LikedOnly    *bool                           `form:"liked_only,omitempty" json:"liked_only,omitempty"`
	PostUrlOnly  *bool                           `form:"post_url_only,omitempty" json:"post_url_only,omitempty"`
	TitleOnly    *bool                           `form:"title_only,omitempty" json:"title_only,omitempty"`
	ListingType  *ListingType                    `form:"listing_type,omitempty" json:"listing_type,omitempty"`

	// TimeRangeSeconds Filter to within a given time range, in seconds.
	// IE 60 would give results for the past minute.
	TimeRangeSeconds *float64        `form:"time_range_seconds,omitempty" json:"time_range_seconds,omitempty"`
	Sort             *SearchSortType `form:"sort,omitempty" json:"sort,omitempty"`
	Type             *SearchType     `form:"type_,omitempty" json:"type_,omitempty"`
	CreatorId        *PersonId       `form:"creator_id,omitempty" json:"creator_id,omitempty"`
	CommunityName    *string         `form:"community_name,omitempty" json:"community_name,omitempty"`
	CommunityId      *CommunityId    `form:"community_id,omitempty" json:"community_id,omitempty"`
	SearchTerm       *string         `form:"search_term,omitempty" json:"search_term,omitempty"`
}

// UploadSiteBannerMultipartBody defines parameters for UploadSiteBanner.
type UploadSiteBannerMultipartBody struct {
	Image openapi_types.File `json:"image"`
}

// UploadSiteIconMultipartBody defines parameters for UploadSiteIcon.
type UploadSiteIconMultipartBody struct {
	Image openapi_types.File `json:"image"`
}

// ChangePasswordJSONRequestBody defines body for ChangePassword for application/json ContentType.
type ChangePasswordJSONRequestBody = ChangePassword

// LoginJSONRequestBody defines body for Login for application/json ContentType.
type LoginJSONRequestBody = Login

// PasswordChangeAfterResetJSONRequestBody defines body for PasswordChangeAfterReset for application/json ContentType.
type PasswordChangeAfterResetJSONRequestBody = PasswordChangeAfterReset

// PasswordResetJSONRequestBody defines body for PasswordReset for application/json ContentType.
type PasswordResetJSONRequestBody = PasswordReset

// RegisterJSONRequestBody defines body for Register for application/json ContentType.
type RegisterJSONRequestBody = Register

// ResendVerificationEmailJSONRequestBody defines body for ResendVerificationEmail for application/json ContentType.
type ResendVerificationEmailJSONRequestBody = ResendVerificationEmail

// UpdateTotpJSONRequestBody defines body for UpdateTotp for application/json ContentType.
type UpdateTotpJSONRequestBody = UpdateTotp

// VerifyEmailJSONRequestBody defines body for VerifyEmail for application/json ContentType.
type VerifyEmailJSONRequestBody = VerifyEmail

// UploadUserAvatarMultipartRequestBody defines body for UploadUserAvatar for multipart/form-data ContentType.
type UploadUserAvatarMultipartRequestBody UploadUserAvatarMultipartBody

// UploadUserBannerMultipartRequestBody defines body for UploadUserBanner for multipart/form-data ContentType.
type UploadUserBannerMultipartRequestBody UploadUserBannerMultipartBody

// BlockCommunityJSONRequestBody defines body for BlockCommunity for application/json ContentType.
type BlockCommunityJSONRequestBody = BlockCommunity

// UserBlockInstanceJSONRequestBody defines body for UserBlockInstance for application/json ContentType.
type UserBlockInstanceJSONRequestBody = UserBlockInstanceParams

// BlockPersonJSONRequestBody defines body for BlockPerson for application/json ContentType.
type BlockPersonJSONRequestBody = BlockPerson

// DeleteAccountJSONRequestBody defines body for DeleteAccount for application/json ContentType.
type DeleteAccountJSONRequestBody = DeleteAccount

// MarkCommentMentionAsReadJSONRequestBody defines body for MarkCommentMentionAsRead for application/json ContentType.
type MarkCommentMentionAsReadJSONRequestBody = MarkPersonCommentMentionAsRead

// MarkPostMentionAsReadJSONRequestBody defines body for MarkPostMentionAsRead for application/json ContentType.
type MarkPostMentionAsReadJSONRequestBody = MarkPersonPostMentionAsRead

// ImportSettingsJSONRequestBody defines body for ImportSettings for application/json ContentType.
type ImportSettingsJSONRequestBody = ImportSettingsJSONBody

// SaveUserSettingsJSONRequestBody defines body for SaveUserSettings for application/json ContentType.
type SaveUserSettingsJSONRequestBody = SaveUserSettings

// AddAdminJSONRequestBody defines body for AddAdmin for application/json ContentType.
type AddAdminJSONRequestBody = AddAdmin

// BanPersonJSONRequestBody defines body for BanPerson for application/json ContentType.
type BanPersonJSONRequestBody = BanPerson

// AdminAllowInstanceJSONRequestBody defines body for AdminAllowInstance for application/json ContentType.
type AdminAllowInstanceJSONRequestBody = AdminAllowInstanceParams

// AdminBlockInstanceJSONRequestBody defines body for AdminBlockInstance for application/json ContentType.
type AdminBlockInstanceJSONRequestBody = AdminBlockInstanceParams

// PurgeCommentJSONRequestBody defines body for PurgeComment for application/json ContentType.
type PurgeCommentJSONRequestBody = PurgeComment

// PurgeCommunityJSONRequestBody defines body for PurgeCommunity for application/json ContentType.
type PurgeCommunityJSONRequestBody = PurgeCommunity

// PurgePersonJSONRequestBody defines body for PurgePerson for application/json ContentType.
type PurgePersonJSONRequestBody = PurgePerson

// PurgePostJSONRequestBody defines body for PurgePost for application/json ContentType.
type PurgePostJSONRequestBody = PurgePost

// ApproveRegistrationApplicationJSONRequestBody defines body for ApproveRegistrationApplication for application/json ContentType.
type ApproveRegistrationApplicationJSONRequestBody = ApproveRegistrationApplication

// CreateTaglineJSONRequestBody defines body for CreateTagline for application/json ContentType.
type CreateTaglineJSONRequestBody = CreateTagline

// EditTaglineJSONRequestBody defines body for EditTagline for application/json ContentType.
type EditTaglineJSONRequestBody = UpdateTagline

// DeleteTaglineJSONRequestBody defines body for DeleteTagline for application/json ContentType.
type DeleteTaglineJSONRequestBody = DeleteTagline

// CreateCommentJSONRequestBody defines body for CreateComment for application/json ContentType.
type CreateCommentJSONRequestBody = CreateComment

// EditCommentJSONRequestBody defines body for EditComment for application/json ContentType.
type EditCommentJSONRequestBody = EditComment

// DeleteCommentJSONRequestBody defines body for DeleteComment for application/json ContentType.
type DeleteCommentJSONRequestBody = DeleteComment

// DistinguishCommentJSONRequestBody defines body for DistinguishComment for application/json ContentType.
type DistinguishCommentJSONRequestBody = DistinguishComment

// LikeCommentJSONRequestBody defines body for LikeComment for application/json ContentType.
type LikeCommentJSONRequestBody = CreateCommentLike

// MarkCommentReplyAsReadJSONRequestBody defines body for MarkCommentReplyAsRead for application/json ContentType.
type MarkCommentReplyAsReadJSONRequestBody = MarkCommentReplyAsRead

// RemoveCommentJSONRequestBody defines body for RemoveComment for application/json ContentType.
type RemoveCommentJSONRequestBody = RemoveComment

// CreateCommentReportJSONRequestBody defines body for CreateCommentReport for application/json ContentType.
type CreateCommentReportJSONRequestBody = CreateCommentReport

// ResolveCommentReportJSONRequestBody defines body for ResolveCommentReport for application/json ContentType.
type ResolveCommentReportJSONRequestBody = ResolveCommentReport

// SaveCommentJSONRequestBody defines body for SaveComment for application/json ContentType.
type SaveCommentJSONRequestBody = SaveComment

// CreateCommunityJSONRequestBody defines body for CreateCommunity for application/json ContentType.
type CreateCommunityJSONRequestBody = CreateCommunity

// EditCommunityJSONRequestBody defines body for EditCommunity for application/json ContentType.
type EditCommunityJSONRequestBody = EditCommunity

// BanFromCommunityJSONRequestBody defines body for BanFromCommunity for application/json ContentType.
type BanFromCommunityJSONRequestBody = BanFromCommunity

// UploadCommunityBannerMultipartRequestBody defines body for UploadCommunityBanner for multipart/form-data ContentType.
type UploadCommunityBannerMultipartRequestBody UploadCommunityBannerMultipartBody

// DeleteCommunityJSONRequestBody defines body for DeleteCommunity for application/json ContentType.
type DeleteCommunityJSONRequestBody = DeleteCommunity

// FollowCommunityJSONRequestBody defines body for FollowCommunity for application/json ContentType.
type FollowCommunityJSONRequestBody = FollowCommunity

// HideCommunityJSONRequestBody defines body for HideCommunity for application/json ContentType.
type HideCommunityJSONRequestBody = HideCommunity

// UploadCommunityIconMultipartRequestBody defines body for UploadCommunityIcon for multipart/form-data ContentType.
type UploadCommunityIconMultipartRequestBody UploadCommunityIconMultipartBody

// AddModToCommunityJSONRequestBody defines body for AddModToCommunity for application/json ContentType.
type AddModToCommunityJSONRequestBody = AddModToCommunity

// ApproveCommunityPendingFollowJSONRequestBody defines body for ApproveCommunityPendingFollow for application/json ContentType.
type ApproveCommunityPendingFollowJSONRequestBody = ApproveCommunityPendingFollower

// RemoveCommunityJSONRequestBody defines body for RemoveCommunity for application/json ContentType.
type RemoveCommunityJSONRequestBody = RemoveCommunity

// TransferCommunityJSONRequestBody defines body for TransferCommunity for application/json ContentType.
type TransferCommunityJSONRequestBody = TransferCommunity

// CreateCustomEmojiJSONRequestBody defines body for CreateCustomEmoji for application/json ContentType.
type CreateCustomEmojiJSONRequestBody = CreateCustomEmoji

// EditCustomEmojiJSONRequestBody defines body for EditCustomEmoji for application/json ContentType.
type EditCustomEmojiJSONRequestBody = EditCustomEmoji

// DeleteCustomEmojiJSONRequestBody defines body for DeleteCustomEmoji for application/json ContentType.
type DeleteCustomEmojiJSONRequestBody = DeleteCustomEmoji

// UploadImageMultipartRequestBody defines body for UploadImage for multipart/form-data ContentType.
type UploadImageMultipartRequestBody UploadImageMultipartBody

// AuthenticateWithOAuthJSONRequestBody defines body for AuthenticateWithOAuth for application/json ContentType.
type AuthenticateWithOAuthJSONRequestBody = AuthenticateWithOauth

// CreateOAuthProviderJSONRequestBody defines body for CreateOAuthProvider for application/json ContentType.
type CreateOAuthProviderJSONRequestBody = CreateOAuthProvider

// EditOAuthProviderJSONRequestBody defines body for EditOAuthProvider for application/json ContentType.
type EditOAuthProviderJSONRequestBody = EditOAuthProvider

// DeleteOAuthProviderJSONRequestBody defines body for DeleteOAuthProvider for application/json ContentType.
type DeleteOAuthProviderJSONRequestBody = DeleteOAuthProvider

// CreatePostJSONRequestBody defines body for CreatePost for application/json ContentType.
type CreatePostJSONRequestBody = CreatePost

// EditPostJSONRequestBody defines body for EditPost for application/json ContentType.
type EditPostJSONRequestBody = EditPost

// DeletePostJSONRequestBody defines body for DeletePost for application/json ContentType.
type DeletePostJSONRequestBody = DeletePost

// FeaturePostJSONRequestBody defines body for FeaturePost for application/json ContentType.
type FeaturePostJSONRequestBody = FeaturePost

// HidePostJSONRequestBody defines body for HidePost for application/json ContentType.
type HidePostJSONRequestBody = HidePost

// LikePostJSONRequestBody defines body for LikePost for application/json ContentType.
type LikePostJSONRequestBody = CreatePostLike

// LockPostJSONRequestBody defines body for LockPost for application/json ContentType.
type LockPostJSONRequestBody = LockPost

// MarkPostAsReadJSONRequestBody defines body for MarkPostAsRead for application/json ContentType.
type MarkPostAsReadJSONRequestBody = MarkPostAsRead

// MarkManyPostAsReadJSONRequestBody defines body for MarkManyPostAsRead for application/json ContentType.
type MarkManyPostAsReadJSONRequestBody = MarkManyPostsAsRead

// RemovePostJSONRequestBody defines body for RemovePost for application/json ContentType.
type RemovePostJSONRequestBody = RemovePost

// CreatePostReportJSONRequestBody defines body for CreatePostReport for application/json ContentType.
type CreatePostReportJSONRequestBody = CreatePostReport

// ResolvePostReportJSONRequestBody defines body for ResolvePostReport for application/json ContentType.
type ResolvePostReportJSONRequestBody = ResolvePostReport

// SavePostJSONRequestBody defines body for SavePost for application/json ContentType.
type SavePostJSONRequestBody = SavePost

// CreatePrivateMessageJSONRequestBody defines body for CreatePrivateMessage for application/json ContentType.
type CreatePrivateMessageJSONRequestBody = CreatePrivateMessage

// EditPrivateMessageJSONRequestBody defines body for EditPrivateMessage for application/json ContentType.
type EditPrivateMessageJSONRequestBody = EditPrivateMessage

// DeletePrivateMessageJSONRequestBody defines body for DeletePrivateMessage for application/json ContentType.
type DeletePrivateMessageJSONRequestBody = DeletePrivateMessage

// MarkPrivateMessageAsReadJSONRequestBody defines body for MarkPrivateMessageAsRead for application/json ContentType.
type MarkPrivateMessageAsReadJSONRequestBody = MarkPrivateMessageAsRead

// CreatePrivateMessageReportJSONRequestBody defines body for CreatePrivateMessageReport for application/json ContentType.
type CreatePrivateMessageReportJSONRequestBody = CreatePrivateMessageReport

// ResolvePrivateMessageReportJSONRequestBody defines body for ResolvePrivateMessageReport for application/json ContentType.
type ResolvePrivateMessageReportJSONRequestBody = ResolvePrivateMessageReport

// CreateSiteJSONRequestBody defines body for CreateSite for application/json ContentType.
type CreateSiteJSONRequestBody = CreateSite

// EditSiteJSONRequestBody defines body for EditSite for application/json ContentType.
type EditSiteJSONRequestBody = EditSite

// UploadSiteBannerMultipartRequestBody defines body for UploadSiteBanner for multipart/form-data ContentType.
type UploadSiteBannerMultipartRequestBody UploadSiteBannerMultipartBody

// UploadSiteIconMultipartRequestBody defines body for UploadSiteIcon for multipart/form-data ContentType.
type UploadSiteIconMultipartRequestBody UploadSiteIconMultipartBody

// AsInboxCombinedView0 returns the union data inside the InboxCombinedView as a InboxCombinedView0
func (t InboxCombinedView) AsInboxCombinedView0() (InboxCombinedView0, error) {
	var body InboxCombinedView0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInboxCombinedView0 overwrites any union data inside the InboxCombinedView as the provided InboxCombinedView0
func (t *InboxCombinedView) FromInboxCombinedView0(v InboxCombinedView0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInboxCombinedView0 performs a merge with any union data inside the InboxCombinedView, using the provided InboxCombinedView0
func (t *InboxCombinedView) MergeInboxCombinedView0(v InboxCombinedView0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsInboxCombinedView1 returns the union data inside the InboxCombinedView as a InboxCombinedView1
func (t InboxCombinedView) AsInboxCombinedView1() (InboxCombinedView1, error) {
	var body InboxCombinedView1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInboxCombinedView1 overwrites any union data inside the InboxCombinedView as the provided InboxCombinedView1
func (t *InboxCombinedView) FromInboxCombinedView1(v InboxCombinedView1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInboxCombinedView1 performs a merge with any union data inside the InboxCombinedView, using the provided InboxCombinedView1
func (t *InboxCombinedView) MergeInboxCombinedView1(v InboxCombinedView1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsInboxCombinedView2 returns the union data inside the InboxCombinedView as a InboxCombinedView2
func (t InboxCombinedView) AsInboxCombinedView2() (InboxCombinedView2, error) {
	var body InboxCombinedView2
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInboxCombinedView2 overwrites any union data inside the InboxCombinedView as the provided InboxCombinedView2
func (t *InboxCombinedView) FromInboxCombinedView2(v InboxCombinedView2) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInboxCombinedView2 performs a merge with any union data inside the InboxCombinedView, using the provided InboxCombinedView2
func (t *InboxCombinedView) MergeInboxCombinedView2(v InboxCombinedView2) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsInboxCombinedView3 returns the union data inside the InboxCombinedView as a InboxCombinedView3
func (t InboxCombinedView) AsInboxCombinedView3() (InboxCombinedView3, error) {
	var body InboxCombinedView3
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInboxCombinedView3 overwrites any union data inside the InboxCombinedView as the provided InboxCombinedView3
func (t *InboxCombinedView) FromInboxCombinedView3(v InboxCombinedView3) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInboxCombinedView3 performs a merge with any union data inside the InboxCombinedView, using the provided InboxCombinedView3
func (t *InboxCombinedView) MergeInboxCombinedView3(v InboxCombinedView3) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t InboxCombinedView) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *InboxCombinedView) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsModlogCombinedView0 returns the union data inside the ModlogCombinedView as a ModlogCombinedView0
func (t ModlogCombinedView) AsModlogCombinedView0() (ModlogCombinedView0, error) {
	var body ModlogCombinedView0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromModlogCombinedView0 overwrites any union data inside the ModlogCombinedView as the provided ModlogCombinedView0
func (t *ModlogCombinedView) FromModlogCombinedView0(v ModlogCombinedView0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeModlogCombinedView0 performs a merge with any union data inside the ModlogCombinedView, using the provided ModlogCombinedView0
func (t *ModlogCombinedView) MergeModlogCombinedView0(v ModlogCombinedView0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsModlogCombinedView1 returns the union data inside the ModlogCombinedView as a ModlogCombinedView1
func (t ModlogCombinedView) AsModlogCombinedView1() (ModlogCombinedView1, error) {
	var body ModlogCombinedView1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromModlogCombinedView1 overwrites any union data inside the ModlogCombinedView as the provided ModlogCombinedView1
func (t *ModlogCombinedView) FromModlogCombinedView1(v ModlogCombinedView1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeModlogCombinedView1 performs a merge with any union data inside the ModlogCombinedView, using the provided ModlogCombinedView1
func (t *ModlogCombinedView) MergeModlogCombinedView1(v ModlogCombinedView1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsModlogCombinedView2 returns the union data inside the ModlogCombinedView as a ModlogCombinedView2
func (t ModlogCombinedView) AsModlogCombinedView2() (ModlogCombinedView2, error) {
	var body ModlogCombinedView2
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromModlogCombinedView2 overwrites any union data inside the ModlogCombinedView as the provided ModlogCombinedView2
func (t *ModlogCombinedView) FromModlogCombinedView2(v ModlogCombinedView2) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeModlogCombinedView2 performs a merge with any union data inside the ModlogCombinedView, using the provided ModlogCombinedView2
func (t *ModlogCombinedView) MergeModlogCombinedView2(v ModlogCombinedView2) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsModlogCombinedView3 returns the union data inside the ModlogCombinedView as a ModlogCombinedView3
func (t ModlogCombinedView) AsModlogCombinedView3() (ModlogCombinedView3, error) {
	var body ModlogCombinedView3
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromModlogCombinedView3 overwrites any union data inside the ModlogCombinedView as the provided ModlogCombinedView3
func (t *ModlogCombinedView) FromModlogCombinedView3(v ModlogCombinedView3) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeModlogCombinedView3 performs a merge with any union data inside the ModlogCombinedView, using the provided ModlogCombinedView3
func (t *ModlogCombinedView) MergeModlogCombinedView3(v ModlogCombinedView3) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsModlogCombinedView4 returns the union data inside the ModlogCombinedView as a ModlogCombinedView4
func (t ModlogCombinedView) AsModlogCombinedView4() (ModlogCombinedView4, error) {
	var body ModlogCombinedView4
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromModlogCombinedView4 overwrites any union data inside the ModlogCombinedView as the provided ModlogCombinedView4
func (t *ModlogCombinedView) FromModlogCombinedView4(v ModlogCombinedView4) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeModlogCombinedView4 performs a merge with any union data inside the ModlogCombinedView, using the provided ModlogCombinedView4
func (t *ModlogCombinedView) MergeModlogCombinedView4(v ModlogCombinedView4) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsModlogCombinedView5 returns the union data inside the ModlogCombinedView as a ModlogCombinedView5
func (t ModlogCombinedView) AsModlogCombinedView5() (ModlogCombinedView5, error) {
	var body ModlogCombinedView5
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromModlogCombinedView5 overwrites any union data inside the ModlogCombinedView as the provided ModlogCombinedView5
func (t *ModlogCombinedView) FromModlogCombinedView5(v ModlogCombinedView5) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeModlogCombinedView5 performs a merge with any union data inside the ModlogCombinedView, using the provided ModlogCombinedView5
func (t *ModlogCombinedView) MergeModlogCombinedView5(v ModlogCombinedView5) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsModlogCombinedView6 returns the union data inside the ModlogCombinedView as a ModlogCombinedView6
func (t ModlogCombinedView) AsModlogCombinedView6() (ModlogCombinedView6, error) {
	var body ModlogCombinedView6
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromModlogCombinedView6 overwrites any union data inside the ModlogCombinedView as the provided ModlogCombinedView6
func (t *ModlogCombinedView) FromModlogCombinedView6(v ModlogCombinedView6) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeModlogCombinedView6 performs a merge with any union data inside the ModlogCombinedView, using the provided ModlogCombinedView6
func (t *ModlogCombinedView) MergeModlogCombinedView6(v ModlogCombinedView6) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsModlogCombinedView7 returns the union data inside the ModlogCombinedView as a ModlogCombinedView7
func (t ModlogCombinedView) AsModlogCombinedView7() (ModlogCombinedView7, error) {
	var body ModlogCombinedView7
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromModlogCombinedView7 overwrites any union data inside the ModlogCombinedView as the provided ModlogCombinedView7
func (t *ModlogCombinedView) FromModlogCombinedView7(v ModlogCombinedView7) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeModlogCombinedView7 performs a merge with any union data inside the ModlogCombinedView, using the provided ModlogCombinedView7
func (t *ModlogCombinedView) MergeModlogCombinedView7(v ModlogCombinedView7) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsModlogCombinedView8 returns the union data inside the ModlogCombinedView as a ModlogCombinedView8
func (t ModlogCombinedView) AsModlogCombinedView8() (ModlogCombinedView8, error) {
	var body ModlogCombinedView8
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromModlogCombinedView8 overwrites any union data inside the ModlogCombinedView as the provided ModlogCombinedView8
func (t *ModlogCombinedView) FromModlogCombinedView8(v ModlogCombinedView8) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeModlogCombinedView8 performs a merge with any union data inside the ModlogCombinedView, using the provided ModlogCombinedView8
func (t *ModlogCombinedView) MergeModlogCombinedView8(v ModlogCombinedView8) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsModlogCombinedView9 returns the union data inside the ModlogCombinedView as a ModlogCombinedView9
func (t ModlogCombinedView) AsModlogCombinedView9() (ModlogCombinedView9, error) {
	var body ModlogCombinedView9
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromModlogCombinedView9 overwrites any union data inside the ModlogCombinedView as the provided ModlogCombinedView9
func (t *ModlogCombinedView) FromModlogCombinedView9(v ModlogCombinedView9) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeModlogCombinedView9 performs a merge with any union data inside the ModlogCombinedView, using the provided ModlogCombinedView9
func (t *ModlogCombinedView) MergeModlogCombinedView9(v ModlogCombinedView9) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsModlogCombinedView10 returns the union data inside the ModlogCombinedView as a ModlogCombinedView10
func (t ModlogCombinedView) AsModlogCombinedView10() (ModlogCombinedView10, error) {
	var body ModlogCombinedView10
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromModlogCombinedView10 overwrites any union data inside the ModlogCombinedView as the provided ModlogCombinedView10
func (t *ModlogCombinedView) FromModlogCombinedView10(v ModlogCombinedView10) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeModlogCombinedView10 performs a merge with any union data inside the ModlogCombinedView, using the provided ModlogCombinedView10
func (t *ModlogCombinedView) MergeModlogCombinedView10(v ModlogCombinedView10) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsModlogCombinedView11 returns the union data inside the ModlogCombinedView as a ModlogCombinedView11
func (t ModlogCombinedView) AsModlogCombinedView11() (ModlogCombinedView11, error) {
	var body ModlogCombinedView11
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromModlogCombinedView11 overwrites any union data inside the ModlogCombinedView as the provided ModlogCombinedView11
func (t *ModlogCombinedView) FromModlogCombinedView11(v ModlogCombinedView11) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeModlogCombinedView11 performs a merge with any union data inside the ModlogCombinedView, using the provided ModlogCombinedView11
func (t *ModlogCombinedView) MergeModlogCombinedView11(v ModlogCombinedView11) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsModlogCombinedView12 returns the union data inside the ModlogCombinedView as a ModlogCombinedView12
func (t ModlogCombinedView) AsModlogCombinedView12() (ModlogCombinedView12, error) {
	var body ModlogCombinedView12
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromModlogCombinedView12 overwrites any union data inside the ModlogCombinedView as the provided ModlogCombinedView12
func (t *ModlogCombinedView) FromModlogCombinedView12(v ModlogCombinedView12) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeModlogCombinedView12 performs a merge with any union data inside the ModlogCombinedView, using the provided ModlogCombinedView12
func (t *ModlogCombinedView) MergeModlogCombinedView12(v ModlogCombinedView12) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsModlogCombinedView13 returns the union data inside the ModlogCombinedView as a ModlogCombinedView13
func (t ModlogCombinedView) AsModlogCombinedView13() (ModlogCombinedView13, error) {
	var body ModlogCombinedView13
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromModlogCombinedView13 overwrites any union data inside the ModlogCombinedView as the provided ModlogCombinedView13
func (t *ModlogCombinedView) FromModlogCombinedView13(v ModlogCombinedView13) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeModlogCombinedView13 performs a merge with any union data inside the ModlogCombinedView, using the provided ModlogCombinedView13
func (t *ModlogCombinedView) MergeModlogCombinedView13(v ModlogCombinedView13) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsModlogCombinedView14 returns the union data inside the ModlogCombinedView as a ModlogCombinedView14
func (t ModlogCombinedView) AsModlogCombinedView14() (ModlogCombinedView14, error) {
	var body ModlogCombinedView14
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromModlogCombinedView14 overwrites any union data inside the ModlogCombinedView as the provided ModlogCombinedView14
func (t *ModlogCombinedView) FromModlogCombinedView14(v ModlogCombinedView14) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeModlogCombinedView14 performs a merge with any union data inside the ModlogCombinedView, using the provided ModlogCombinedView14
func (t *ModlogCombinedView) MergeModlogCombinedView14(v ModlogCombinedView14) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsModlogCombinedView15 returns the union data inside the ModlogCombinedView as a ModlogCombinedView15
func (t ModlogCombinedView) AsModlogCombinedView15() (ModlogCombinedView15, error) {
	var body ModlogCombinedView15
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromModlogCombinedView15 overwrites any union data inside the ModlogCombinedView as the provided ModlogCombinedView15
func (t *ModlogCombinedView) FromModlogCombinedView15(v ModlogCombinedView15) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeModlogCombinedView15 performs a merge with any union data inside the ModlogCombinedView, using the provided ModlogCombinedView15
func (t *ModlogCombinedView) MergeModlogCombinedView15(v ModlogCombinedView15) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsModlogCombinedView16 returns the union data inside the ModlogCombinedView as a ModlogCombinedView16
func (t ModlogCombinedView) AsModlogCombinedView16() (ModlogCombinedView16, error) {
	var body ModlogCombinedView16
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromModlogCombinedView16 overwrites any union data inside the ModlogCombinedView as the provided ModlogCombinedView16
func (t *ModlogCombinedView) FromModlogCombinedView16(v ModlogCombinedView16) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeModlogCombinedView16 performs a merge with any union data inside the ModlogCombinedView, using the provided ModlogCombinedView16
func (t *ModlogCombinedView) MergeModlogCombinedView16(v ModlogCombinedView16) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ModlogCombinedView) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ModlogCombinedView) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsPersonContentCombinedView0 returns the union data inside the PersonContentCombinedView as a PersonContentCombinedView0
func (t PersonContentCombinedView) AsPersonContentCombinedView0() (PersonContentCombinedView0, error) {
	var body PersonContentCombinedView0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPersonContentCombinedView0 overwrites any union data inside the PersonContentCombinedView as the provided PersonContentCombinedView0
func (t *PersonContentCombinedView) FromPersonContentCombinedView0(v PersonContentCombinedView0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePersonContentCombinedView0 performs a merge with any union data inside the PersonContentCombinedView, using the provided PersonContentCombinedView0
func (t *PersonContentCombinedView) MergePersonContentCombinedView0(v PersonContentCombinedView0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPersonContentCombinedView1 returns the union data inside the PersonContentCombinedView as a PersonContentCombinedView1
func (t PersonContentCombinedView) AsPersonContentCombinedView1() (PersonContentCombinedView1, error) {
	var body PersonContentCombinedView1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPersonContentCombinedView1 overwrites any union data inside the PersonContentCombinedView as the provided PersonContentCombinedView1
func (t *PersonContentCombinedView) FromPersonContentCombinedView1(v PersonContentCombinedView1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePersonContentCombinedView1 performs a merge with any union data inside the PersonContentCombinedView, using the provided PersonContentCombinedView1
func (t *PersonContentCombinedView) MergePersonContentCombinedView1(v PersonContentCombinedView1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t PersonContentCombinedView) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *PersonContentCombinedView) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsReportCombinedView0 returns the union data inside the ReportCombinedView as a ReportCombinedView0
func (t ReportCombinedView) AsReportCombinedView0() (ReportCombinedView0, error) {
	var body ReportCombinedView0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromReportCombinedView0 overwrites any union data inside the ReportCombinedView as the provided ReportCombinedView0
func (t *ReportCombinedView) FromReportCombinedView0(v ReportCombinedView0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeReportCombinedView0 performs a merge with any union data inside the ReportCombinedView, using the provided ReportCombinedView0
func (t *ReportCombinedView) MergeReportCombinedView0(v ReportCombinedView0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsReportCombinedView1 returns the union data inside the ReportCombinedView as a ReportCombinedView1
func (t ReportCombinedView) AsReportCombinedView1() (ReportCombinedView1, error) {
	var body ReportCombinedView1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromReportCombinedView1 overwrites any union data inside the ReportCombinedView as the provided ReportCombinedView1
func (t *ReportCombinedView) FromReportCombinedView1(v ReportCombinedView1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeReportCombinedView1 performs a merge with any union data inside the ReportCombinedView, using the provided ReportCombinedView1
func (t *ReportCombinedView) MergeReportCombinedView1(v ReportCombinedView1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsReportCombinedView2 returns the union data inside the ReportCombinedView as a ReportCombinedView2
func (t ReportCombinedView) AsReportCombinedView2() (ReportCombinedView2, error) {
	var body ReportCombinedView2
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromReportCombinedView2 overwrites any union data inside the ReportCombinedView as the provided ReportCombinedView2
func (t *ReportCombinedView) FromReportCombinedView2(v ReportCombinedView2) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeReportCombinedView2 performs a merge with any union data inside the ReportCombinedView, using the provided ReportCombinedView2
func (t *ReportCombinedView) MergeReportCombinedView2(v ReportCombinedView2) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsReportCombinedView3 returns the union data inside the ReportCombinedView as a ReportCombinedView3
func (t ReportCombinedView) AsReportCombinedView3() (ReportCombinedView3, error) {
	var body ReportCombinedView3
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromReportCombinedView3 overwrites any union data inside the ReportCombinedView as the provided ReportCombinedView3
func (t *ReportCombinedView) FromReportCombinedView3(v ReportCombinedView3) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeReportCombinedView3 performs a merge with any union data inside the ReportCombinedView, using the provided ReportCombinedView3
func (t *ReportCombinedView) MergeReportCombinedView3(v ReportCombinedView3) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ReportCombinedView) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ReportCombinedView) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsSearchCombinedView0 returns the union data inside the SearchCombinedView as a SearchCombinedView0
func (t SearchCombinedView) AsSearchCombinedView0() (SearchCombinedView0, error) {
	var body SearchCombinedView0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSearchCombinedView0 overwrites any union data inside the SearchCombinedView as the provided SearchCombinedView0
func (t *SearchCombinedView) FromSearchCombinedView0(v SearchCombinedView0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSearchCombinedView0 performs a merge with any union data inside the SearchCombinedView, using the provided SearchCombinedView0
func (t *SearchCombinedView) MergeSearchCombinedView0(v SearchCombinedView0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSearchCombinedView1 returns the union data inside the SearchCombinedView as a SearchCombinedView1
func (t SearchCombinedView) AsSearchCombinedView1() (SearchCombinedView1, error) {
	var body SearchCombinedView1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSearchCombinedView1 overwrites any union data inside the SearchCombinedView as the provided SearchCombinedView1
func (t *SearchCombinedView) FromSearchCombinedView1(v SearchCombinedView1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSearchCombinedView1 performs a merge with any union data inside the SearchCombinedView, using the provided SearchCombinedView1
func (t *SearchCombinedView) MergeSearchCombinedView1(v SearchCombinedView1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSearchCombinedView2 returns the union data inside the SearchCombinedView as a SearchCombinedView2
func (t SearchCombinedView) AsSearchCombinedView2() (SearchCombinedView2, error) {
	var body SearchCombinedView2
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSearchCombinedView2 overwrites any union data inside the SearchCombinedView as the provided SearchCombinedView2
func (t *SearchCombinedView) FromSearchCombinedView2(v SearchCombinedView2) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSearchCombinedView2 performs a merge with any union data inside the SearchCombinedView, using the provided SearchCombinedView2
func (t *SearchCombinedView) MergeSearchCombinedView2(v SearchCombinedView2) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSearchCombinedView3 returns the union data inside the SearchCombinedView as a SearchCombinedView3
func (t SearchCombinedView) AsSearchCombinedView3() (SearchCombinedView3, error) {
	var body SearchCombinedView3
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSearchCombinedView3 overwrites any union data inside the SearchCombinedView as the provided SearchCombinedView3
func (t *SearchCombinedView) FromSearchCombinedView3(v SearchCombinedView3) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSearchCombinedView3 performs a merge with any union data inside the SearchCombinedView, using the provided SearchCombinedView3
func (t *SearchCombinedView) MergeSearchCombinedView3(v SearchCombinedView3) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t SearchCombinedView) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *SearchCombinedView) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetMyUser request
	GetMyUser(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ChangePasswordWithBody request with any body
	ChangePasswordWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ChangePassword(ctx context.Context, body ChangePasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCaptcha request
	GetCaptcha(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LoginWithBody request with any body
	LoginWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	Login(ctx context.Context, body LoginJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Logout request
	Logout(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PasswordChangeAfterResetWithBody request with any body
	PasswordChangeAfterResetWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PasswordChangeAfterReset(ctx context.Context, body PasswordChangeAfterResetJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PasswordResetWithBody request with any body
	PasswordResetWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PasswordReset(ctx context.Context, body PasswordResetJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RegisterWithBody request with any body
	RegisterWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	Register(ctx context.Context, body RegisterJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ResendVerificationEmailWithBody request with any body
	ResendVerificationEmailWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ResendVerificationEmail(ctx context.Context, body ResendVerificationEmailJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListPersonSaved request
	ListPersonSaved(ctx context.Context, params *ListPersonSavedParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GenerateTotpSecret request
	GenerateTotpSecret(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateTotpWithBody request with any body
	UpdateTotpWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateTotp(ctx context.Context, body UpdateTotpJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// VerifyEmailWithBody request with any body
	VerifyEmailWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	VerifyEmail(ctx context.Context, body VerifyEmailJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteUserAvatar request
	DeleteUserAvatar(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UploadUserAvatarWithBody request with any body
	UploadUserAvatarWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteUserBanner request
	DeleteUserBanner(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UploadUserBannerWithBody request with any body
	UploadUserBannerWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BlockCommunityWithBody request with any body
	BlockCommunityWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	BlockCommunity(ctx context.Context, body BlockCommunityJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UserBlockInstanceWithBody request with any body
	UserBlockInstanceWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UserBlockInstance(ctx context.Context, body UserBlockInstanceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BlockPersonWithBody request with any body
	BlockPersonWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	BlockPerson(ctx context.Context, body BlockPersonJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteAccountWithBody request with any body
	DeleteAccountWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteAccount(ctx context.Context, body DeleteAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListInbox request
	ListInbox(ctx context.Context, params *ListInboxParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListLogins request
	ListLogins(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListMedia request
	ListMedia(ctx context.Context, params *ListMediaParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MarkAllNotificationsAsRead request
	MarkAllNotificationsAsRead(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MarkCommentMentionAsReadWithBody request with any body
	MarkCommentMentionAsReadWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	MarkCommentMentionAsRead(ctx context.Context, body MarkCommentMentionAsReadJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MarkPostMentionAsReadWithBody request with any body
	MarkPostMentionAsReadWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	MarkPostMentionAsRead(ctx context.Context, body MarkPostMentionAsReadJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetReportCount request
	GetReportCount(ctx context.Context, params *GetReportCountParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExportSettings request
	ExportSettings(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ImportSettingsWithBody request with any body
	ImportSettingsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ImportSettings(ctx context.Context, body ImportSettingsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SaveUserSettingsWithBody request with any body
	SaveUserSettingsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SaveUserSettings(ctx context.Context, body SaveUserSettingsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUnreadCount request
	GetUnreadCount(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ValidateAuth request
	ValidateAuth(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddAdminWithBody request with any body
	AddAdminWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddAdmin(ctx context.Context, body AddAdminJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BanPersonWithBody request with any body
	BanPersonWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	BanPerson(ctx context.Context, body BanPersonJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBannedPersons request
	GetBannedPersons(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AdminAllowInstanceWithBody request with any body
	AdminAllowInstanceWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AdminAllowInstance(ctx context.Context, body AdminAllowInstanceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AdminBlockInstanceWithBody request with any body
	AdminBlockInstanceWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AdminBlockInstance(ctx context.Context, body AdminBlockInstanceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LeaveAdmin request
	LeaveAdmin(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListAllMedia request
	ListAllMedia(ctx context.Context, params *ListAllMediaParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PurgeCommentWithBody request with any body
	PurgeCommentWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PurgeComment(ctx context.Context, body PurgeCommentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PurgeCommunityWithBody request with any body
	PurgeCommunityWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PurgeCommunity(ctx context.Context, body PurgeCommunityJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PurgePersonWithBody request with any body
	PurgePersonWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PurgePerson(ctx context.Context, body PurgePersonJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PurgePostWithBody request with any body
	PurgePostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PurgePost(ctx context.Context, body PurgePostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRegistrationApplication request
	GetRegistrationApplication(ctx context.Context, params *GetRegistrationApplicationParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ApproveRegistrationApplicationWithBody request with any body
	ApproveRegistrationApplicationWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ApproveRegistrationApplication(ctx context.Context, body ApproveRegistrationApplicationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUnreadRegistrationApplicationCount request
	GetUnreadRegistrationApplicationCount(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListRegistrationApplications request
	ListRegistrationApplications(ctx context.Context, params *ListRegistrationApplicationsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateTaglineWithBody request with any body
	CreateTaglineWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateTagline(ctx context.Context, body CreateTaglineJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EditTaglineWithBody request with any body
	EditTaglineWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	EditTagline(ctx context.Context, body EditTaglineJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteTaglineWithBody request with any body
	DeleteTaglineWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteTagline(ctx context.Context, body DeleteTaglineJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListTaglines request
	ListTaglines(ctx context.Context, params *ListTaglinesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetComment request
	GetComment(ctx context.Context, params *GetCommentParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateCommentWithBody request with any body
	CreateCommentWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateComment(ctx context.Context, body CreateCommentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EditCommentWithBody request with any body
	EditCommentWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	EditComment(ctx context.Context, body EditCommentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteCommentWithBody request with any body
	DeleteCommentWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteComment(ctx context.Context, body DeleteCommentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DistinguishCommentWithBody request with any body
	DistinguishCommentWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DistinguishComment(ctx context.Context, body DistinguishCommentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LikeCommentWithBody request with any body
	LikeCommentWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	LikeComment(ctx context.Context, body LikeCommentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListCommentLikes request
	ListCommentLikes(ctx context.Context, params *ListCommentLikesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetComments request
	GetComments(ctx context.Context, params *GetCommentsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCommentsSlim request
	GetCommentsSlim(ctx context.Context, params *GetCommentsSlimParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MarkCommentReplyAsReadWithBody request with any body
	MarkCommentReplyAsReadWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	MarkCommentReplyAsRead(ctx context.Context, body MarkCommentReplyAsReadJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveCommentWithBody request with any body
	RemoveCommentWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RemoveComment(ctx context.Context, body RemoveCommentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateCommentReportWithBody request with any body
	CreateCommentReportWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateCommentReport(ctx context.Context, body CreateCommentReportJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ResolveCommentReportWithBody request with any body
	ResolveCommentReportWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ResolveCommentReport(ctx context.Context, body ResolveCommentReportJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SaveCommentWithBody request with any body
	SaveCommentWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SaveComment(ctx context.Context, body SaveCommentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCommunity request
	GetCommunity(ctx context.Context, params *GetCommunityParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateCommunityWithBody request with any body
	CreateCommunityWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateCommunity(ctx context.Context, body CreateCommunityJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EditCommunityWithBody request with any body
	EditCommunityWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	EditCommunity(ctx context.Context, body EditCommunityJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BanFromCommunityWithBody request with any body
	BanFromCommunityWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	BanFromCommunity(ctx context.Context, body BanFromCommunityJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteCommunityBanner request
	DeleteCommunityBanner(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UploadCommunityBannerWithBody request with any body
	UploadCommunityBannerWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteCommunityWithBody request with any body
	DeleteCommunityWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteCommunity(ctx context.Context, body DeleteCommunityJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FollowCommunityWithBody request with any body
	FollowCommunityWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	FollowCommunity(ctx context.Context, body FollowCommunityJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// HideCommunityWithBody request with any body
	HideCommunityWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	HideCommunity(ctx context.Context, body HideCommunityJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteCommunityIcon request
	DeleteCommunityIcon(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UploadCommunityIconWithBody request with any body
	UploadCommunityIconWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListCommunities request
	ListCommunities(ctx context.Context, params *ListCommunitiesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddModToCommunityWithBody request with any body
	AddModToCommunityWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddModToCommunity(ctx context.Context, body AddModToCommunityJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ApproveCommunityPendingFollowWithBody request with any body
	ApproveCommunityPendingFollowWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ApproveCommunityPendingFollow(ctx context.Context, body ApproveCommunityPendingFollowJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCommunityPendingFollowsCount request
	GetCommunityPendingFollowsCount(ctx context.Context, params *GetCommunityPendingFollowsCountParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListCommunityPendingFollows request
	ListCommunityPendingFollows(ctx context.Context, params *ListCommunityPendingFollowsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRandomCommunity request
	GetRandomCommunity(ctx context.Context, params *GetRandomCommunityParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveCommunityWithBody request with any body
	RemoveCommunityWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RemoveCommunity(ctx context.Context, body RemoveCommunityJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TransferCommunityWithBody request with any body
	TransferCommunityWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TransferCommunity(ctx context.Context, body TransferCommunityJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateCustomEmojiWithBody request with any body
	CreateCustomEmojiWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateCustomEmoji(ctx context.Context, body CreateCustomEmojiJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EditCustomEmojiWithBody request with any body
	EditCustomEmojiWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	EditCustomEmoji(ctx context.Context, body EditCustomEmojiJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteCustomEmojiWithBody request with any body
	DeleteCustomEmojiWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteCustomEmoji(ctx context.Context, body DeleteCustomEmojiJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListCustomEmojis request
	ListCustomEmojis(ctx context.Context, params *ListCustomEmojisParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFederatedInstances request
	GetFederatedInstances(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteImage request
	DeleteImage(ctx context.Context, params *DeleteImageParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UploadImageWithBody request with any body
	UploadImageWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ImageHealth request
	ImageHealth(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetModlog request
	GetModlog(ctx context.Context, params *GetModlogParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AuthenticateWithOAuthWithBody request with any body
	AuthenticateWithOAuthWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AuthenticateWithOAuth(ctx context.Context, body AuthenticateWithOAuthJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateOAuthProviderWithBody request with any body
	CreateOAuthProviderWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateOAuthProvider(ctx context.Context, body CreateOAuthProviderJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EditOAuthProviderWithBody request with any body
	EditOAuthProviderWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	EditOAuthProvider(ctx context.Context, body EditOAuthProviderJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteOAuthProviderWithBody request with any body
	DeleteOAuthProviderWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteOAuthProvider(ctx context.Context, body DeleteOAuthProviderJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPersonDetails request
	GetPersonDetails(ctx context.Context, params *GetPersonDetailsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListPersonContent request
	ListPersonContent(ctx context.Context, params *ListPersonContentParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPost request
	GetPost(ctx context.Context, params *GetPostParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreatePostWithBody request with any body
	CreatePostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreatePost(ctx context.Context, body CreatePostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EditPostWithBody request with any body
	EditPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	EditPost(ctx context.Context, body EditPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeletePostWithBody request with any body
	DeletePostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeletePost(ctx context.Context, body DeletePostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FeaturePostWithBody request with any body
	FeaturePostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	FeaturePost(ctx context.Context, body FeaturePostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// HidePostWithBody request with any body
	HidePostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	HidePost(ctx context.Context, body HidePostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LikePostWithBody request with any body
	LikePostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	LikePost(ctx context.Context, body LikePostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListPostLikes request
	ListPostLikes(ctx context.Context, params *ListPostLikesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPosts request
	GetPosts(ctx context.Context, params *GetPostsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LockPostWithBody request with any body
	LockPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	LockPost(ctx context.Context, body LockPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MarkPostAsReadWithBody request with any body
	MarkPostAsReadWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	MarkPostAsRead(ctx context.Context, body MarkPostAsReadJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MarkManyPostAsReadWithBody request with any body
	MarkManyPostAsReadWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	MarkManyPostAsRead(ctx context.Context, body MarkManyPostAsReadJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemovePostWithBody request with any body
	RemovePostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RemovePost(ctx context.Context, body RemovePostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreatePostReportWithBody request with any body
	CreatePostReportWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreatePostReport(ctx context.Context, body CreatePostReportJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ResolvePostReportWithBody request with any body
	ResolvePostReportWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ResolvePostReport(ctx context.Context, body ResolvePostReportJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SavePostWithBody request with any body
	SavePostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SavePost(ctx context.Context, body SavePostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSiteMetadata request
	GetSiteMetadata(ctx context.Context, params *GetSiteMetadataParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreatePrivateMessageWithBody request with any body
	CreatePrivateMessageWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreatePrivateMessage(ctx context.Context, body CreatePrivateMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EditPrivateMessageWithBody request with any body
	EditPrivateMessageWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	EditPrivateMessage(ctx context.Context, body EditPrivateMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeletePrivateMessageWithBody request with any body
	DeletePrivateMessageWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeletePrivateMessage(ctx context.Context, body DeletePrivateMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MarkPrivateMessageAsReadWithBody request with any body
	MarkPrivateMessageAsReadWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	MarkPrivateMessageAsRead(ctx context.Context, body MarkPrivateMessageAsReadJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreatePrivateMessageReportWithBody request with any body
	CreatePrivateMessageReportWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreatePrivateMessageReport(ctx context.Context, body CreatePrivateMessageReportJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ResolvePrivateMessageReportWithBody request with any body
	ResolvePrivateMessageReportWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ResolvePrivateMessageReport(ctx context.Context, body ResolvePrivateMessageReportJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListReports request
	ListReports(ctx context.Context, params *ListReportsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ResolveObject request
	ResolveObject(ctx context.Context, params *ResolveObjectParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Search request
	Search(ctx context.Context, params *SearchParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSite request
	GetSite(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateSiteWithBody request with any body
	CreateSiteWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateSite(ctx context.Context, body CreateSiteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EditSiteWithBody request with any body
	EditSiteWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	EditSite(ctx context.Context, body EditSiteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSiteBanner request
	DeleteSiteBanner(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UploadSiteBannerWithBody request with any body
	UploadSiteBannerWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSiteIcon request
	DeleteSiteIcon(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UploadSiteIconWithBody request with any body
	UploadSiteIconWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetMyUser(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMyUserRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ChangePasswordWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewChangePasswordRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ChangePassword(ctx context.Context, body ChangePasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewChangePasswordRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCaptcha(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCaptchaRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LoginWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLoginRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Login(ctx context.Context, body LoginJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLoginRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Logout(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLogoutRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PasswordChangeAfterResetWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPasswordChangeAfterResetRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PasswordChangeAfterReset(ctx context.Context, body PasswordChangeAfterResetJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPasswordChangeAfterResetRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PasswordResetWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPasswordResetRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PasswordReset(ctx context.Context, body PasswordResetJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPasswordResetRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RegisterWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRegisterRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Register(ctx context.Context, body RegisterJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRegisterRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ResendVerificationEmailWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewResendVerificationEmailRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ResendVerificationEmail(ctx context.Context, body ResendVerificationEmailJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewResendVerificationEmailRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListPersonSaved(ctx context.Context, params *ListPersonSavedParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListPersonSavedRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GenerateTotpSecret(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGenerateTotpSecretRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateTotpWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateTotpRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateTotp(ctx context.Context, body UpdateTotpJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateTotpRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) VerifyEmailWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewVerifyEmailRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) VerifyEmail(ctx context.Context, body VerifyEmailJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewVerifyEmailRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteUserAvatar(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteUserAvatarRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UploadUserAvatarWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUploadUserAvatarRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteUserBanner(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteUserBannerRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UploadUserBannerWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUploadUserBannerRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BlockCommunityWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBlockCommunityRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BlockCommunity(ctx context.Context, body BlockCommunityJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBlockCommunityRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UserBlockInstanceWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUserBlockInstanceRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UserBlockInstance(ctx context.Context, body UserBlockInstanceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUserBlockInstanceRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BlockPersonWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBlockPersonRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BlockPerson(ctx context.Context, body BlockPersonJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBlockPersonRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteAccountWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteAccountRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteAccount(ctx context.Context, body DeleteAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteAccountRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListInbox(ctx context.Context, params *ListInboxParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListInboxRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListLogins(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListLoginsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListMedia(ctx context.Context, params *ListMediaParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListMediaRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MarkAllNotificationsAsRead(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMarkAllNotificationsAsReadRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MarkCommentMentionAsReadWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMarkCommentMentionAsReadRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MarkCommentMentionAsRead(ctx context.Context, body MarkCommentMentionAsReadJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMarkCommentMentionAsReadRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MarkPostMentionAsReadWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMarkPostMentionAsReadRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MarkPostMentionAsRead(ctx context.Context, body MarkPostMentionAsReadJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMarkPostMentionAsReadRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetReportCount(ctx context.Context, params *GetReportCountParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetReportCountRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExportSettings(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExportSettingsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ImportSettingsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewImportSettingsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ImportSettings(ctx context.Context, body ImportSettingsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewImportSettingsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SaveUserSettingsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSaveUserSettingsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SaveUserSettings(ctx context.Context, body SaveUserSettingsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSaveUserSettingsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUnreadCount(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUnreadCountRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ValidateAuth(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewValidateAuthRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddAdminWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddAdminRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddAdmin(ctx context.Context, body AddAdminJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddAdminRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BanPersonWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBanPersonRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BanPerson(ctx context.Context, body BanPersonJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBanPersonRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBannedPersons(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBannedPersonsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AdminAllowInstanceWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAdminAllowInstanceRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AdminAllowInstance(ctx context.Context, body AdminAllowInstanceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAdminAllowInstanceRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AdminBlockInstanceWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAdminBlockInstanceRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AdminBlockInstance(ctx context.Context, body AdminBlockInstanceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAdminBlockInstanceRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LeaveAdmin(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLeaveAdminRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListAllMedia(ctx context.Context, params *ListAllMediaParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAllMediaRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PurgeCommentWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPurgeCommentRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PurgeComment(ctx context.Context, body PurgeCommentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPurgeCommentRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PurgeCommunityWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPurgeCommunityRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PurgeCommunity(ctx context.Context, body PurgeCommunityJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPurgeCommunityRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PurgePersonWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPurgePersonRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PurgePerson(ctx context.Context, body PurgePersonJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPurgePersonRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PurgePostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPurgePostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PurgePost(ctx context.Context, body PurgePostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPurgePostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRegistrationApplication(ctx context.Context, params *GetRegistrationApplicationParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRegistrationApplicationRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ApproveRegistrationApplicationWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewApproveRegistrationApplicationRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ApproveRegistrationApplication(ctx context.Context, body ApproveRegistrationApplicationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewApproveRegistrationApplicationRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUnreadRegistrationApplicationCount(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUnreadRegistrationApplicationCountRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListRegistrationApplications(ctx context.Context, params *ListRegistrationApplicationsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListRegistrationApplicationsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTaglineWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTaglineRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTagline(ctx context.Context, body CreateTaglineJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTaglineRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EditTaglineWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEditTaglineRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EditTagline(ctx context.Context, body EditTaglineJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEditTaglineRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteTaglineWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteTaglineRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteTagline(ctx context.Context, body DeleteTaglineJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteTaglineRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListTaglines(ctx context.Context, params *ListTaglinesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListTaglinesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetComment(ctx context.Context, params *GetCommentParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCommentRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateCommentWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateCommentRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateComment(ctx context.Context, body CreateCommentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateCommentRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EditCommentWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEditCommentRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EditComment(ctx context.Context, body EditCommentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEditCommentRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteCommentWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteCommentRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteComment(ctx context.Context, body DeleteCommentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteCommentRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DistinguishCommentWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDistinguishCommentRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DistinguishComment(ctx context.Context, body DistinguishCommentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDistinguishCommentRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LikeCommentWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLikeCommentRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LikeComment(ctx context.Context, body LikeCommentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLikeCommentRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListCommentLikes(ctx context.Context, params *ListCommentLikesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListCommentLikesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetComments(ctx context.Context, params *GetCommentsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCommentsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCommentsSlim(ctx context.Context, params *GetCommentsSlimParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCommentsSlimRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MarkCommentReplyAsReadWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMarkCommentReplyAsReadRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MarkCommentReplyAsRead(ctx context.Context, body MarkCommentReplyAsReadJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMarkCommentReplyAsReadRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveCommentWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveCommentRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveComment(ctx context.Context, body RemoveCommentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveCommentRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateCommentReportWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateCommentReportRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateCommentReport(ctx context.Context, body CreateCommentReportJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateCommentReportRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ResolveCommentReportWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewResolveCommentReportRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ResolveCommentReport(ctx context.Context, body ResolveCommentReportJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewResolveCommentReportRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SaveCommentWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSaveCommentRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SaveComment(ctx context.Context, body SaveCommentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSaveCommentRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCommunity(ctx context.Context, params *GetCommunityParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCommunityRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateCommunityWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateCommunityRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateCommunity(ctx context.Context, body CreateCommunityJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateCommunityRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EditCommunityWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEditCommunityRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EditCommunity(ctx context.Context, body EditCommunityJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEditCommunityRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BanFromCommunityWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBanFromCommunityRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BanFromCommunity(ctx context.Context, body BanFromCommunityJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBanFromCommunityRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteCommunityBanner(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteCommunityBannerRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UploadCommunityBannerWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUploadCommunityBannerRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteCommunityWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteCommunityRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteCommunity(ctx context.Context, body DeleteCommunityJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteCommunityRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FollowCommunityWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFollowCommunityRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FollowCommunity(ctx context.Context, body FollowCommunityJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFollowCommunityRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) HideCommunityWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewHideCommunityRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) HideCommunity(ctx context.Context, body HideCommunityJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewHideCommunityRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteCommunityIcon(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteCommunityIconRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UploadCommunityIconWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUploadCommunityIconRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListCommunities(ctx context.Context, params *ListCommunitiesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListCommunitiesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddModToCommunityWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddModToCommunityRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddModToCommunity(ctx context.Context, body AddModToCommunityJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddModToCommunityRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ApproveCommunityPendingFollowWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewApproveCommunityPendingFollowRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ApproveCommunityPendingFollow(ctx context.Context, body ApproveCommunityPendingFollowJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewApproveCommunityPendingFollowRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCommunityPendingFollowsCount(ctx context.Context, params *GetCommunityPendingFollowsCountParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCommunityPendingFollowsCountRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListCommunityPendingFollows(ctx context.Context, params *ListCommunityPendingFollowsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListCommunityPendingFollowsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRandomCommunity(ctx context.Context, params *GetRandomCommunityParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRandomCommunityRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveCommunityWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveCommunityRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveCommunity(ctx context.Context, body RemoveCommunityJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveCommunityRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TransferCommunityWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTransferCommunityRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TransferCommunity(ctx context.Context, body TransferCommunityJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTransferCommunityRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateCustomEmojiWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateCustomEmojiRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateCustomEmoji(ctx context.Context, body CreateCustomEmojiJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateCustomEmojiRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EditCustomEmojiWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEditCustomEmojiRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EditCustomEmoji(ctx context.Context, body EditCustomEmojiJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEditCustomEmojiRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteCustomEmojiWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteCustomEmojiRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteCustomEmoji(ctx context.Context, body DeleteCustomEmojiJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteCustomEmojiRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListCustomEmojis(ctx context.Context, params *ListCustomEmojisParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListCustomEmojisRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFederatedInstances(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFederatedInstancesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteImage(ctx context.Context, params *DeleteImageParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteImageRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UploadImageWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUploadImageRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ImageHealth(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewImageHealthRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetModlog(ctx context.Context, params *GetModlogParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetModlogRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AuthenticateWithOAuthWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAuthenticateWithOAuthRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AuthenticateWithOAuth(ctx context.Context, body AuthenticateWithOAuthJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAuthenticateWithOAuthRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateOAuthProviderWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateOAuthProviderRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateOAuthProvider(ctx context.Context, body CreateOAuthProviderJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateOAuthProviderRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EditOAuthProviderWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEditOAuthProviderRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EditOAuthProvider(ctx context.Context, body EditOAuthProviderJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEditOAuthProviderRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteOAuthProviderWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteOAuthProviderRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteOAuthProvider(ctx context.Context, body DeleteOAuthProviderJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteOAuthProviderRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPersonDetails(ctx context.Context, params *GetPersonDetailsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPersonDetailsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListPersonContent(ctx context.Context, params *ListPersonContentParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListPersonContentRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPost(ctx context.Context, params *GetPostParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPostRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePost(ctx context.Context, body CreatePostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EditPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEditPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EditPost(ctx context.Context, body EditPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEditPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeletePostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeletePostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeletePost(ctx context.Context, body DeletePostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeletePostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FeaturePostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFeaturePostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FeaturePost(ctx context.Context, body FeaturePostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFeaturePostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) HidePostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewHidePostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) HidePost(ctx context.Context, body HidePostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewHidePostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LikePostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLikePostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LikePost(ctx context.Context, body LikePostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLikePostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListPostLikes(ctx context.Context, params *ListPostLikesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListPostLikesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPosts(ctx context.Context, params *GetPostsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPostsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LockPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLockPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LockPost(ctx context.Context, body LockPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLockPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MarkPostAsReadWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMarkPostAsReadRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MarkPostAsRead(ctx context.Context, body MarkPostAsReadJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMarkPostAsReadRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MarkManyPostAsReadWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMarkManyPostAsReadRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MarkManyPostAsRead(ctx context.Context, body MarkManyPostAsReadJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMarkManyPostAsReadRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemovePostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemovePostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemovePost(ctx context.Context, body RemovePostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemovePostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePostReportWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePostReportRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePostReport(ctx context.Context, body CreatePostReportJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePostReportRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ResolvePostReportWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewResolvePostReportRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ResolvePostReport(ctx context.Context, body ResolvePostReportJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewResolvePostReportRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SavePostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSavePostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SavePost(ctx context.Context, body SavePostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSavePostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSiteMetadata(ctx context.Context, params *GetSiteMetadataParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSiteMetadataRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePrivateMessageWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePrivateMessageRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePrivateMessage(ctx context.Context, body CreatePrivateMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePrivateMessageRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EditPrivateMessageWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEditPrivateMessageRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EditPrivateMessage(ctx context.Context, body EditPrivateMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEditPrivateMessageRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeletePrivateMessageWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeletePrivateMessageRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeletePrivateMessage(ctx context.Context, body DeletePrivateMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeletePrivateMessageRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MarkPrivateMessageAsReadWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMarkPrivateMessageAsReadRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MarkPrivateMessageAsRead(ctx context.Context, body MarkPrivateMessageAsReadJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMarkPrivateMessageAsReadRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePrivateMessageReportWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePrivateMessageReportRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePrivateMessageReport(ctx context.Context, body CreatePrivateMessageReportJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePrivateMessageReportRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ResolvePrivateMessageReportWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewResolvePrivateMessageReportRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ResolvePrivateMessageReport(ctx context.Context, body ResolvePrivateMessageReportJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewResolvePrivateMessageReportRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListReports(ctx context.Context, params *ListReportsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListReportsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ResolveObject(ctx context.Context, params *ResolveObjectParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewResolveObjectRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Search(ctx context.Context, params *SearchParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSite(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSiteRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSiteWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSiteRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSite(ctx context.Context, body CreateSiteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSiteRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EditSiteWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEditSiteRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EditSite(ctx context.Context, body EditSiteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEditSiteRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSiteBanner(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSiteBannerRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UploadSiteBannerWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUploadSiteBannerRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSiteIcon(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSiteIconRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UploadSiteIconWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUploadSiteIconRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetMyUserRequest generates requests for GetMyUser
func NewGetMyUserRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/account")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewChangePasswordRequest calls the generic ChangePassword builder with application/json body
func NewChangePasswordRequest(server string, body ChangePasswordJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewChangePasswordRequestWithBody(server, "application/json", bodyReader)
}

// NewChangePasswordRequestWithBody generates requests for ChangePassword with any type of body
func NewChangePasswordRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/account/auth/change_password")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetCaptchaRequest generates requests for GetCaptcha
func NewGetCaptchaRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/account/auth/get_captcha")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewLoginRequest calls the generic Login builder with application/json body
func NewLoginRequest(server string, body LoginJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewLoginRequestWithBody(server, "application/json", bodyReader)
}

// NewLoginRequestWithBody generates requests for Login with any type of body
func NewLoginRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/account/auth/login")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewLogoutRequest generates requests for Logout
func NewLogoutRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/account/auth/logout")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPasswordChangeAfterResetRequest calls the generic PasswordChangeAfterReset builder with application/json body
func NewPasswordChangeAfterResetRequest(server string, body PasswordChangeAfterResetJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPasswordChangeAfterResetRequestWithBody(server, "application/json", bodyReader)
}

// NewPasswordChangeAfterResetRequestWithBody generates requests for PasswordChangeAfterReset with any type of body
func NewPasswordChangeAfterResetRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/account/auth/password_change")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPasswordResetRequest calls the generic PasswordReset builder with application/json body
func NewPasswordResetRequest(server string, body PasswordResetJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPasswordResetRequestWithBody(server, "application/json", bodyReader)
}

// NewPasswordResetRequestWithBody generates requests for PasswordReset with any type of body
func NewPasswordResetRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/account/auth/password_reset")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRegisterRequest calls the generic Register builder with application/json body
func NewRegisterRequest(server string, body RegisterJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRegisterRequestWithBody(server, "application/json", bodyReader)
}

// NewRegisterRequestWithBody generates requests for Register with any type of body
func NewRegisterRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/account/auth/register")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewResendVerificationEmailRequest calls the generic ResendVerificationEmail builder with application/json body
func NewResendVerificationEmailRequest(server string, body ResendVerificationEmailJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewResendVerificationEmailRequestWithBody(server, "application/json", bodyReader)
}

// NewResendVerificationEmailRequestWithBody generates requests for ResendVerificationEmail with any type of body
func NewResendVerificationEmailRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/account/auth/resend_verification_email")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListPersonSavedRequest generates requests for ListPersonSaved
func NewListPersonSavedRequest(server string, params *ListPersonSavedParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/account/auth/saved")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PageBack != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page_back", runtime.ParamLocationQuery, *params.PageBack); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageCursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page_cursor", runtime.ParamLocationQuery, *params.PageCursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type_", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGenerateTotpSecretRequest generates requests for GenerateTotpSecret
func NewGenerateTotpSecretRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/account/auth/totp/generate")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateTotpRequest calls the generic UpdateTotp builder with application/json body
func NewUpdateTotpRequest(server string, body UpdateTotpJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateTotpRequestWithBody(server, "application/json", bodyReader)
}

// NewUpdateTotpRequestWithBody generates requests for UpdateTotp with any type of body
func NewUpdateTotpRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/account/auth/totp/update")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewVerifyEmailRequest calls the generic VerifyEmail builder with application/json body
func NewVerifyEmailRequest(server string, body VerifyEmailJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewVerifyEmailRequestWithBody(server, "application/json", bodyReader)
}

// NewVerifyEmailRequestWithBody generates requests for VerifyEmail with any type of body
func NewVerifyEmailRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/account/auth/verify_email")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteUserAvatarRequest generates requests for DeleteUserAvatar
func NewDeleteUserAvatarRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/account/avatar")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUploadUserAvatarRequestWithBody generates requests for UploadUserAvatar with any type of body
func NewUploadUserAvatarRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/account/avatar")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteUserBannerRequest generates requests for DeleteUserBanner
func NewDeleteUserBannerRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/account/banner")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUploadUserBannerRequestWithBody generates requests for UploadUserBanner with any type of body
func NewUploadUserBannerRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/account/banner")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewBlockCommunityRequest calls the generic BlockCommunity builder with application/json body
func NewBlockCommunityRequest(server string, body BlockCommunityJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewBlockCommunityRequestWithBody(server, "application/json", bodyReader)
}

// NewBlockCommunityRequestWithBody generates requests for BlockCommunity with any type of body
func NewBlockCommunityRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/account/block/community")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUserBlockInstanceRequest calls the generic UserBlockInstance builder with application/json body
func NewUserBlockInstanceRequest(server string, body UserBlockInstanceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUserBlockInstanceRequestWithBody(server, "application/json", bodyReader)
}

// NewUserBlockInstanceRequestWithBody generates requests for UserBlockInstance with any type of body
func NewUserBlockInstanceRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/account/block/instance")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewBlockPersonRequest calls the generic BlockPerson builder with application/json body
func NewBlockPersonRequest(server string, body BlockPersonJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewBlockPersonRequestWithBody(server, "application/json", bodyReader)
}

// NewBlockPersonRequestWithBody generates requests for BlockPerson with any type of body
func NewBlockPersonRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/account/block/person")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteAccountRequest calls the generic DeleteAccount builder with application/json body
func NewDeleteAccountRequest(server string, body DeleteAccountJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteAccountRequestWithBody(server, "application/json", bodyReader)
}

// NewDeleteAccountRequestWithBody generates requests for DeleteAccount with any type of body
func NewDeleteAccountRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/account/delete")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListInboxRequest generates requests for ListInbox
func NewListInboxRequest(server string, params *ListInboxParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/account/inbox")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PageBack != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page_back", runtime.ParamLocationQuery, *params.PageBack); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageCursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page_cursor", runtime.ParamLocationQuery, *params.PageCursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UnreadOnly != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "unread_only", runtime.ParamLocationQuery, *params.UnreadOnly); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type_", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListLoginsRequest generates requests for ListLogins
func NewListLoginsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/account/list_logins")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListMediaRequest generates requests for ListMedia
func NewListMediaRequest(server string, params *ListMediaParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/account/list_media")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMarkAllNotificationsAsReadRequest generates requests for MarkAllNotificationsAsRead
func NewMarkAllNotificationsAsReadRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/account/mark_as_read/all")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMarkCommentMentionAsReadRequest calls the generic MarkCommentMentionAsRead builder with application/json body
func NewMarkCommentMentionAsReadRequest(server string, body MarkCommentMentionAsReadJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewMarkCommentMentionAsReadRequestWithBody(server, "application/json", bodyReader)
}

// NewMarkCommentMentionAsReadRequestWithBody generates requests for MarkCommentMentionAsRead with any type of body
func NewMarkCommentMentionAsReadRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/account/mention/comment/mark_as_read")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewMarkPostMentionAsReadRequest calls the generic MarkPostMentionAsRead builder with application/json body
func NewMarkPostMentionAsReadRequest(server string, body MarkPostMentionAsReadJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewMarkPostMentionAsReadRequestWithBody(server, "application/json", bodyReader)
}

// NewMarkPostMentionAsReadRequestWithBody generates requests for MarkPostMentionAsRead with any type of body
func NewMarkPostMentionAsReadRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/account/mention/post/mark_as_read")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetReportCountRequest generates requests for GetReportCount
func NewGetReportCountRequest(server string, params *GetReportCountParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/account/report_count")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.CommunityId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "community_id", runtime.ParamLocationQuery, *params.CommunityId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewExportSettingsRequest generates requests for ExportSettings
func NewExportSettingsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/account/settings/export")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewImportSettingsRequest calls the generic ImportSettings builder with application/json body
func NewImportSettingsRequest(server string, body ImportSettingsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewImportSettingsRequestWithBody(server, "application/json", bodyReader)
}

// NewImportSettingsRequestWithBody generates requests for ImportSettings with any type of body
func NewImportSettingsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/account/settings/import")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSaveUserSettingsRequest calls the generic SaveUserSettings builder with application/json body
func NewSaveUserSettingsRequest(server string, body SaveUserSettingsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSaveUserSettingsRequestWithBody(server, "application/json", bodyReader)
}

// NewSaveUserSettingsRequestWithBody generates requests for SaveUserSettings with any type of body
func NewSaveUserSettingsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/account/settings/save")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetUnreadCountRequest generates requests for GetUnreadCount
func NewGetUnreadCountRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/account/unread_count")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewValidateAuthRequest generates requests for ValidateAuth
func NewValidateAuthRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/account/validate_auth")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddAdminRequest calls the generic AddAdmin builder with application/json body
func NewAddAdminRequest(server string, body AddAdminJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddAdminRequestWithBody(server, "application/json", bodyReader)
}

// NewAddAdminRequestWithBody generates requests for AddAdmin with any type of body
func NewAddAdminRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/admin/add")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewBanPersonRequest calls the generic BanPerson builder with application/json body
func NewBanPersonRequest(server string, body BanPersonJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewBanPersonRequestWithBody(server, "application/json", bodyReader)
}

// NewBanPersonRequestWithBody generates requests for BanPerson with any type of body
func NewBanPersonRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/admin/ban")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetBannedPersonsRequest generates requests for GetBannedPersons
func NewGetBannedPersonsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/admin/banned")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAdminAllowInstanceRequest calls the generic AdminAllowInstance builder with application/json body
func NewAdminAllowInstanceRequest(server string, body AdminAllowInstanceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAdminAllowInstanceRequestWithBody(server, "application/json", bodyReader)
}

// NewAdminAllowInstanceRequestWithBody generates requests for AdminAllowInstance with any type of body
func NewAdminAllowInstanceRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/admin/instance/allow")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAdminBlockInstanceRequest calls the generic AdminBlockInstance builder with application/json body
func NewAdminBlockInstanceRequest(server string, body AdminBlockInstanceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAdminBlockInstanceRequestWithBody(server, "application/json", bodyReader)
}

// NewAdminBlockInstanceRequestWithBody generates requests for AdminBlockInstance with any type of body
func NewAdminBlockInstanceRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/admin/instance/block")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewLeaveAdminRequest generates requests for LeaveAdmin
func NewLeaveAdminRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/admin/leave")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListAllMediaRequest generates requests for ListAllMedia
func NewListAllMediaRequest(server string, params *ListAllMediaParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/admin/list_all_media")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPurgeCommentRequest calls the generic PurgeComment builder with application/json body
func NewPurgeCommentRequest(server string, body PurgeCommentJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPurgeCommentRequestWithBody(server, "application/json", bodyReader)
}

// NewPurgeCommentRequestWithBody generates requests for PurgeComment with any type of body
func NewPurgeCommentRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/admin/purge/comment")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPurgeCommunityRequest calls the generic PurgeCommunity builder with application/json body
func NewPurgeCommunityRequest(server string, body PurgeCommunityJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPurgeCommunityRequestWithBody(server, "application/json", bodyReader)
}

// NewPurgeCommunityRequestWithBody generates requests for PurgeCommunity with any type of body
func NewPurgeCommunityRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/admin/purge/community")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPurgePersonRequest calls the generic PurgePerson builder with application/json body
func NewPurgePersonRequest(server string, body PurgePersonJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPurgePersonRequestWithBody(server, "application/json", bodyReader)
}

// NewPurgePersonRequestWithBody generates requests for PurgePerson with any type of body
func NewPurgePersonRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/admin/purge/person")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPurgePostRequest calls the generic PurgePost builder with application/json body
func NewPurgePostRequest(server string, body PurgePostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPurgePostRequestWithBody(server, "application/json", bodyReader)
}

// NewPurgePostRequestWithBody generates requests for PurgePost with any type of body
func NewPurgePostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/admin/purge/post")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetRegistrationApplicationRequest generates requests for GetRegistrationApplication
func NewGetRegistrationApplicationRequest(server string, params *GetRegistrationApplicationParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/admin/registration_application")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "person_id", runtime.ParamLocationQuery, params.PersonId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewApproveRegistrationApplicationRequest calls the generic ApproveRegistrationApplication builder with application/json body
func NewApproveRegistrationApplicationRequest(server string, body ApproveRegistrationApplicationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewApproveRegistrationApplicationRequestWithBody(server, "application/json", bodyReader)
}

// NewApproveRegistrationApplicationRequestWithBody generates requests for ApproveRegistrationApplication with any type of body
func NewApproveRegistrationApplicationRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/admin/registration_application/approve")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetUnreadRegistrationApplicationCountRequest generates requests for GetUnreadRegistrationApplicationCount
func NewGetUnreadRegistrationApplicationCountRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/admin/registration_application/count")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListRegistrationApplicationsRequest generates requests for ListRegistrationApplications
func NewListRegistrationApplicationsRequest(server string, params *ListRegistrationApplicationsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/admin/registration_application/list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UnreadOnly != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "unread_only", runtime.ParamLocationQuery, *params.UnreadOnly); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateTaglineRequest calls the generic CreateTagline builder with application/json body
func NewCreateTaglineRequest(server string, body CreateTaglineJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateTaglineRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateTaglineRequestWithBody generates requests for CreateTagline with any type of body
func NewCreateTaglineRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/admin/tagline")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewEditTaglineRequest calls the generic EditTagline builder with application/json body
func NewEditTaglineRequest(server string, body EditTaglineJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewEditTaglineRequestWithBody(server, "application/json", bodyReader)
}

// NewEditTaglineRequestWithBody generates requests for EditTagline with any type of body
func NewEditTaglineRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/admin/tagline")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteTaglineRequest calls the generic DeleteTagline builder with application/json body
func NewDeleteTaglineRequest(server string, body DeleteTaglineJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteTaglineRequestWithBody(server, "application/json", bodyReader)
}

// NewDeleteTaglineRequestWithBody generates requests for DeleteTagline with any type of body
func NewDeleteTaglineRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/admin/tagline/delete")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListTaglinesRequest generates requests for ListTaglines
func NewListTaglinesRequest(server string, params *ListTaglinesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/admin/tagline/list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCommentRequest generates requests for GetComment
func NewGetCommentRequest(server string, params *GetCommentParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/comment")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateCommentRequest calls the generic CreateComment builder with application/json body
func NewCreateCommentRequest(server string, body CreateCommentJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateCommentRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateCommentRequestWithBody generates requests for CreateComment with any type of body
func NewCreateCommentRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/comment")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewEditCommentRequest calls the generic EditComment builder with application/json body
func NewEditCommentRequest(server string, body EditCommentJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewEditCommentRequestWithBody(server, "application/json", bodyReader)
}

// NewEditCommentRequestWithBody generates requests for EditComment with any type of body
func NewEditCommentRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/comment")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteCommentRequest calls the generic DeleteComment builder with application/json body
func NewDeleteCommentRequest(server string, body DeleteCommentJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteCommentRequestWithBody(server, "application/json", bodyReader)
}

// NewDeleteCommentRequestWithBody generates requests for DeleteComment with any type of body
func NewDeleteCommentRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/comment/delete")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDistinguishCommentRequest calls the generic DistinguishComment builder with application/json body
func NewDistinguishCommentRequest(server string, body DistinguishCommentJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDistinguishCommentRequestWithBody(server, "application/json", bodyReader)
}

// NewDistinguishCommentRequestWithBody generates requests for DistinguishComment with any type of body
func NewDistinguishCommentRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/comment/distinguish")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewLikeCommentRequest calls the generic LikeComment builder with application/json body
func NewLikeCommentRequest(server string, body LikeCommentJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewLikeCommentRequestWithBody(server, "application/json", bodyReader)
}

// NewLikeCommentRequestWithBody generates requests for LikeComment with any type of body
func NewLikeCommentRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/comment/like")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListCommentLikesRequest generates requests for ListCommentLikes
func NewListCommentLikesRequest(server string, params *ListCommentLikesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/comment/like/list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "comment_id", runtime.ParamLocationQuery, params.CommentId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCommentsRequest generates requests for GetComments
func NewGetCommentsRequest(server string, params *GetCommentsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/comment/list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.DislikedOnly != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "disliked_only", runtime.ParamLocationQuery, *params.DislikedOnly); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LikedOnly != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "liked_only", runtime.ParamLocationQuery, *params.LikedOnly); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ParentId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "parent_id", runtime.ParamLocationQuery, *params.ParentId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PostId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "post_id", runtime.ParamLocationQuery, *params.PostId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CommunityName != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "community_name", runtime.ParamLocationQuery, *params.CommunityName); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CommunityId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "community_id", runtime.ParamLocationQuery, *params.CommunityId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxDepth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "max_depth", runtime.ParamLocationQuery, *params.MaxDepth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimeRangeSeconds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "time_range_seconds", runtime.ParamLocationQuery, *params.TimeRangeSeconds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type_", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCommentsSlimRequest generates requests for GetCommentsSlim
func NewGetCommentsSlimRequest(server string, params *GetCommentsSlimParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/comment/list/slim")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.DislikedOnly != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "disliked_only", runtime.ParamLocationQuery, *params.DislikedOnly); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LikedOnly != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "liked_only", runtime.ParamLocationQuery, *params.LikedOnly); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ParentId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "parent_id", runtime.ParamLocationQuery, *params.ParentId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PostId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "post_id", runtime.ParamLocationQuery, *params.PostId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CommunityName != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "community_name", runtime.ParamLocationQuery, *params.CommunityName); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CommunityId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "community_id", runtime.ParamLocationQuery, *params.CommunityId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxDepth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "max_depth", runtime.ParamLocationQuery, *params.MaxDepth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimeRangeSeconds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "time_range_seconds", runtime.ParamLocationQuery, *params.TimeRangeSeconds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type_", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMarkCommentReplyAsReadRequest calls the generic MarkCommentReplyAsRead builder with application/json body
func NewMarkCommentReplyAsReadRequest(server string, body MarkCommentReplyAsReadJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewMarkCommentReplyAsReadRequestWithBody(server, "application/json", bodyReader)
}

// NewMarkCommentReplyAsReadRequestWithBody generates requests for MarkCommentReplyAsRead with any type of body
func NewMarkCommentReplyAsReadRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/comment/mark_as_read")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRemoveCommentRequest calls the generic RemoveComment builder with application/json body
func NewRemoveCommentRequest(server string, body RemoveCommentJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRemoveCommentRequestWithBody(server, "application/json", bodyReader)
}

// NewRemoveCommentRequestWithBody generates requests for RemoveComment with any type of body
func NewRemoveCommentRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/comment/remove")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateCommentReportRequest calls the generic CreateCommentReport builder with application/json body
func NewCreateCommentReportRequest(server string, body CreateCommentReportJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateCommentReportRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateCommentReportRequestWithBody generates requests for CreateCommentReport with any type of body
func NewCreateCommentReportRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/comment/report")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewResolveCommentReportRequest calls the generic ResolveCommentReport builder with application/json body
func NewResolveCommentReportRequest(server string, body ResolveCommentReportJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewResolveCommentReportRequestWithBody(server, "application/json", bodyReader)
}

// NewResolveCommentReportRequestWithBody generates requests for ResolveCommentReport with any type of body
func NewResolveCommentReportRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/comment/report/resolve")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSaveCommentRequest calls the generic SaveComment builder with application/json body
func NewSaveCommentRequest(server string, body SaveCommentJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSaveCommentRequestWithBody(server, "application/json", bodyReader)
}

// NewSaveCommentRequestWithBody generates requests for SaveComment with any type of body
func NewSaveCommentRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/comment/save")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetCommunityRequest generates requests for GetCommunity
func NewGetCommunityRequest(server string, params *GetCommunityParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/community")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateCommunityRequest calls the generic CreateCommunity builder with application/json body
func NewCreateCommunityRequest(server string, body CreateCommunityJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateCommunityRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateCommunityRequestWithBody generates requests for CreateCommunity with any type of body
func NewCreateCommunityRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/community")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewEditCommunityRequest calls the generic EditCommunity builder with application/json body
func NewEditCommunityRequest(server string, body EditCommunityJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewEditCommunityRequestWithBody(server, "application/json", bodyReader)
}

// NewEditCommunityRequestWithBody generates requests for EditCommunity with any type of body
func NewEditCommunityRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/community")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewBanFromCommunityRequest calls the generic BanFromCommunity builder with application/json body
func NewBanFromCommunityRequest(server string, body BanFromCommunityJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewBanFromCommunityRequestWithBody(server, "application/json", bodyReader)
}

// NewBanFromCommunityRequestWithBody generates requests for BanFromCommunity with any type of body
func NewBanFromCommunityRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/community/ban_user")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteCommunityBannerRequest generates requests for DeleteCommunityBanner
func NewDeleteCommunityBannerRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/community/banner")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUploadCommunityBannerRequestWithBody generates requests for UploadCommunityBanner with any type of body
func NewUploadCommunityBannerRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/community/banner")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteCommunityRequest calls the generic DeleteCommunity builder with application/json body
func NewDeleteCommunityRequest(server string, body DeleteCommunityJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteCommunityRequestWithBody(server, "application/json", bodyReader)
}

// NewDeleteCommunityRequestWithBody generates requests for DeleteCommunity with any type of body
func NewDeleteCommunityRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/community/delete")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewFollowCommunityRequest calls the generic FollowCommunity builder with application/json body
func NewFollowCommunityRequest(server string, body FollowCommunityJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewFollowCommunityRequestWithBody(server, "application/json", bodyReader)
}

// NewFollowCommunityRequestWithBody generates requests for FollowCommunity with any type of body
func NewFollowCommunityRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/community/follow")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewHideCommunityRequest calls the generic HideCommunity builder with application/json body
func NewHideCommunityRequest(server string, body HideCommunityJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewHideCommunityRequestWithBody(server, "application/json", bodyReader)
}

// NewHideCommunityRequestWithBody generates requests for HideCommunity with any type of body
func NewHideCommunityRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/community/hide")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteCommunityIconRequest generates requests for DeleteCommunityIcon
func NewDeleteCommunityIconRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/community/icon")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUploadCommunityIconRequestWithBody generates requests for UploadCommunityIcon with any type of body
func NewUploadCommunityIconRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/community/icon")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListCommunitiesRequest generates requests for ListCommunities
func NewListCommunitiesRequest(server string, params *ListCommunitiesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/community/list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ShowNsfw != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "show_nsfw", runtime.ParamLocationQuery, *params.ShowNsfw); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimeRangeSeconds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "time_range_seconds", runtime.ParamLocationQuery, *params.TimeRangeSeconds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type_", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddModToCommunityRequest calls the generic AddModToCommunity builder with application/json body
func NewAddModToCommunityRequest(server string, body AddModToCommunityJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddModToCommunityRequestWithBody(server, "application/json", bodyReader)
}

// NewAddModToCommunityRequestWithBody generates requests for AddModToCommunity with any type of body
func NewAddModToCommunityRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/community/mod")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewApproveCommunityPendingFollowRequest calls the generic ApproveCommunityPendingFollow builder with application/json body
func NewApproveCommunityPendingFollowRequest(server string, body ApproveCommunityPendingFollowJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewApproveCommunityPendingFollowRequestWithBody(server, "application/json", bodyReader)
}

// NewApproveCommunityPendingFollowRequestWithBody generates requests for ApproveCommunityPendingFollow with any type of body
func NewApproveCommunityPendingFollowRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/community/pending_follows/approve")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetCommunityPendingFollowsCountRequest generates requests for GetCommunityPendingFollowsCount
func NewGetCommunityPendingFollowsCountRequest(server string, params *GetCommunityPendingFollowsCountParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/community/pending_follows/count")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "community_id", runtime.ParamLocationQuery, params.CommunityId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListCommunityPendingFollowsRequest generates requests for ListCommunityPendingFollows
func NewListCommunityPendingFollowsRequest(server string, params *ListCommunityPendingFollowsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/community/pending_follows/list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AllCommunities != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "all_communities", runtime.ParamLocationQuery, *params.AllCommunities); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PendingOnly != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pending_only", runtime.ParamLocationQuery, *params.PendingOnly); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRandomCommunityRequest generates requests for GetRandomCommunity
func NewGetRandomCommunityRequest(server string, params *GetRandomCommunityParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/community/random")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ShowNsfw != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "show_nsfw", runtime.ParamLocationQuery, *params.ShowNsfw); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type_", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRemoveCommunityRequest calls the generic RemoveCommunity builder with application/json body
func NewRemoveCommunityRequest(server string, body RemoveCommunityJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRemoveCommunityRequestWithBody(server, "application/json", bodyReader)
}

// NewRemoveCommunityRequestWithBody generates requests for RemoveCommunity with any type of body
func NewRemoveCommunityRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/community/remove")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTransferCommunityRequest calls the generic TransferCommunity builder with application/json body
func NewTransferCommunityRequest(server string, body TransferCommunityJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTransferCommunityRequestWithBody(server, "application/json", bodyReader)
}

// NewTransferCommunityRequestWithBody generates requests for TransferCommunity with any type of body
func NewTransferCommunityRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/community/transfer")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateCustomEmojiRequest calls the generic CreateCustomEmoji builder with application/json body
func NewCreateCustomEmojiRequest(server string, body CreateCustomEmojiJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateCustomEmojiRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateCustomEmojiRequestWithBody generates requests for CreateCustomEmoji with any type of body
func NewCreateCustomEmojiRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/custom_emoji")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewEditCustomEmojiRequest calls the generic EditCustomEmoji builder with application/json body
func NewEditCustomEmojiRequest(server string, body EditCustomEmojiJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewEditCustomEmojiRequestWithBody(server, "application/json", bodyReader)
}

// NewEditCustomEmojiRequestWithBody generates requests for EditCustomEmoji with any type of body
func NewEditCustomEmojiRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/custom_emoji")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteCustomEmojiRequest calls the generic DeleteCustomEmoji builder with application/json body
func NewDeleteCustomEmojiRequest(server string, body DeleteCustomEmojiJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteCustomEmojiRequestWithBody(server, "application/json", bodyReader)
}

// NewDeleteCustomEmojiRequestWithBody generates requests for DeleteCustomEmoji with any type of body
func NewDeleteCustomEmojiRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/custom_emoji/delete")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListCustomEmojisRequest generates requests for ListCustomEmojis
func NewListCustomEmojisRequest(server string, params *ListCustomEmojisParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/custom_emoji/list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IgnorePageLimits != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ignore_page_limits", runtime.ParamLocationQuery, *params.IgnorePageLimits); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Category != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "category", runtime.ParamLocationQuery, *params.Category); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetFederatedInstancesRequest generates requests for GetFederatedInstances
func NewGetFederatedInstancesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/federated_instances")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteImageRequest generates requests for DeleteImage
func NewDeleteImageRequest(server string, params *DeleteImageParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/image")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filename", runtime.ParamLocationQuery, params.Filename); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUploadImageRequestWithBody generates requests for UploadImage with any type of body
func NewUploadImageRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/image")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewImageHealthRequest generates requests for ImageHealth
func NewImageHealthRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/image/health")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetModlogRequest generates requests for GetModlog
func NewGetModlogRequest(server string, params *GetModlogParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/modlog")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PageBack != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page_back", runtime.ParamLocationQuery, *params.PageBack); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageCursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page_cursor", runtime.ParamLocationQuery, *params.PageCursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CommentId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "comment_id", runtime.ParamLocationQuery, *params.CommentId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PostId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "post_id", runtime.ParamLocationQuery, *params.PostId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OtherPersonId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "other_person_id", runtime.ParamLocationQuery, *params.OtherPersonId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ListingType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "listing_type", runtime.ParamLocationQuery, *params.ListingType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type_", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CommunityId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "community_id", runtime.ParamLocationQuery, *params.CommunityId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ModPersonId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "mod_person_id", runtime.ParamLocationQuery, *params.ModPersonId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAuthenticateWithOAuthRequest calls the generic AuthenticateWithOAuth builder with application/json body
func NewAuthenticateWithOAuthRequest(server string, body AuthenticateWithOAuthJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAuthenticateWithOAuthRequestWithBody(server, "application/json", bodyReader)
}

// NewAuthenticateWithOAuthRequestWithBody generates requests for AuthenticateWithOAuth with any type of body
func NewAuthenticateWithOAuthRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/oauth/authenticate")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateOAuthProviderRequest calls the generic CreateOAuthProvider builder with application/json body
func NewCreateOAuthProviderRequest(server string, body CreateOAuthProviderJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateOAuthProviderRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateOAuthProviderRequestWithBody generates requests for CreateOAuthProvider with any type of body
func NewCreateOAuthProviderRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/oauth_provider")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewEditOAuthProviderRequest calls the generic EditOAuthProvider builder with application/json body
func NewEditOAuthProviderRequest(server string, body EditOAuthProviderJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewEditOAuthProviderRequestWithBody(server, "application/json", bodyReader)
}

// NewEditOAuthProviderRequestWithBody generates requests for EditOAuthProvider with any type of body
func NewEditOAuthProviderRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/oauth_provider")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteOAuthProviderRequest calls the generic DeleteOAuthProvider builder with application/json body
func NewDeleteOAuthProviderRequest(server string, body DeleteOAuthProviderJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteOAuthProviderRequestWithBody(server, "application/json", bodyReader)
}

// NewDeleteOAuthProviderRequestWithBody generates requests for DeleteOAuthProvider with any type of body
func NewDeleteOAuthProviderRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/oauth_provider/delete")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetPersonDetailsRequest generates requests for GetPersonDetails
func NewGetPersonDetailsRequest(server string, params *GetPersonDetailsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/person")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Username != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "username", runtime.ParamLocationQuery, *params.Username); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PersonId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "person_id", runtime.ParamLocationQuery, *params.PersonId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListPersonContentRequest generates requests for ListPersonContent
func NewListPersonContentRequest(server string, params *ListPersonContentParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/person/content")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PageBack != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page_back", runtime.ParamLocationQuery, *params.PageBack); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageCursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page_cursor", runtime.ParamLocationQuery, *params.PageCursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Username != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "username", runtime.ParamLocationQuery, *params.Username); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PersonId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "person_id", runtime.ParamLocationQuery, *params.PersonId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type_", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPostRequest generates requests for GetPost
func NewGetPostRequest(server string, params *GetPostParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/post")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.CommentId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "comment_id", runtime.ParamLocationQuery, *params.CommentId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreatePostRequest calls the generic CreatePost builder with application/json body
func NewCreatePostRequest(server string, body CreatePostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreatePostRequestWithBody(server, "application/json", bodyReader)
}

// NewCreatePostRequestWithBody generates requests for CreatePost with any type of body
func NewCreatePostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/post")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewEditPostRequest calls the generic EditPost builder with application/json body
func NewEditPostRequest(server string, body EditPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewEditPostRequestWithBody(server, "application/json", bodyReader)
}

// NewEditPostRequestWithBody generates requests for EditPost with any type of body
func NewEditPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/post")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeletePostRequest calls the generic DeletePost builder with application/json body
func NewDeletePostRequest(server string, body DeletePostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeletePostRequestWithBody(server, "application/json", bodyReader)
}

// NewDeletePostRequestWithBody generates requests for DeletePost with any type of body
func NewDeletePostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/post/delete")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewFeaturePostRequest calls the generic FeaturePost builder with application/json body
func NewFeaturePostRequest(server string, body FeaturePostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewFeaturePostRequestWithBody(server, "application/json", bodyReader)
}

// NewFeaturePostRequestWithBody generates requests for FeaturePost with any type of body
func NewFeaturePostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/post/feature")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewHidePostRequest calls the generic HidePost builder with application/json body
func NewHidePostRequest(server string, body HidePostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewHidePostRequestWithBody(server, "application/json", bodyReader)
}

// NewHidePostRequestWithBody generates requests for HidePost with any type of body
func NewHidePostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/post/hide")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewLikePostRequest calls the generic LikePost builder with application/json body
func NewLikePostRequest(server string, body LikePostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewLikePostRequestWithBody(server, "application/json", bodyReader)
}

// NewLikePostRequestWithBody generates requests for LikePost with any type of body
func NewLikePostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/post/like")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListPostLikesRequest generates requests for ListPostLikes
func NewListPostLikesRequest(server string, params *ListPostLikesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/post/like/list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "post_id", runtime.ParamLocationQuery, params.PostId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPostsRequest generates requests for GetPosts
func NewGetPostsRequest(server string, params *GetPostsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/post/list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PageBack != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page_back", runtime.ParamLocationQuery, *params.PageBack); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageCursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page_cursor", runtime.ParamLocationQuery, *params.PageCursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NoCommentsOnly != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "no_comments_only", runtime.ParamLocationQuery, *params.NoCommentsOnly); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MarkAsRead != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "mark_as_read", runtime.ParamLocationQuery, *params.MarkAsRead); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.HideMedia != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hide_media", runtime.ParamLocationQuery, *params.HideMedia); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ShowNsfw != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "show_nsfw", runtime.ParamLocationQuery, *params.ShowNsfw); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ShowRead != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "show_read", runtime.ParamLocationQuery, *params.ShowRead); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ShowHidden != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "show_hidden", runtime.ParamLocationQuery, *params.ShowHidden); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DislikedOnly != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "disliked_only", runtime.ParamLocationQuery, *params.DislikedOnly); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LikedOnly != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "liked_only", runtime.ParamLocationQuery, *params.LikedOnly); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ReadOnly != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "read_only", runtime.ParamLocationQuery, *params.ReadOnly); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SavedOnly != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "saved_only", runtime.ParamLocationQuery, *params.SavedOnly); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CommunityName != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "community_name", runtime.ParamLocationQuery, *params.CommunityName); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CommunityId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "community_id", runtime.ParamLocationQuery, *params.CommunityId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimeRangeSeconds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "time_range_seconds", runtime.ParamLocationQuery, *params.TimeRangeSeconds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type_", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewLockPostRequest calls the generic LockPost builder with application/json body
func NewLockPostRequest(server string, body LockPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewLockPostRequestWithBody(server, "application/json", bodyReader)
}

// NewLockPostRequestWithBody generates requests for LockPost with any type of body
func NewLockPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/post/lock")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewMarkPostAsReadRequest calls the generic MarkPostAsRead builder with application/json body
func NewMarkPostAsReadRequest(server string, body MarkPostAsReadJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewMarkPostAsReadRequestWithBody(server, "application/json", bodyReader)
}

// NewMarkPostAsReadRequestWithBody generates requests for MarkPostAsRead with any type of body
func NewMarkPostAsReadRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/post/mark_as_read")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewMarkManyPostAsReadRequest calls the generic MarkManyPostAsRead builder with application/json body
func NewMarkManyPostAsReadRequest(server string, body MarkManyPostAsReadJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewMarkManyPostAsReadRequestWithBody(server, "application/json", bodyReader)
}

// NewMarkManyPostAsReadRequestWithBody generates requests for MarkManyPostAsRead with any type of body
func NewMarkManyPostAsReadRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/post/mark_as_read/many")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRemovePostRequest calls the generic RemovePost builder with application/json body
func NewRemovePostRequest(server string, body RemovePostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRemovePostRequestWithBody(server, "application/json", bodyReader)
}

// NewRemovePostRequestWithBody generates requests for RemovePost with any type of body
func NewRemovePostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/post/remove")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreatePostReportRequest calls the generic CreatePostReport builder with application/json body
func NewCreatePostReportRequest(server string, body CreatePostReportJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreatePostReportRequestWithBody(server, "application/json", bodyReader)
}

// NewCreatePostReportRequestWithBody generates requests for CreatePostReport with any type of body
func NewCreatePostReportRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/post/report")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewResolvePostReportRequest calls the generic ResolvePostReport builder with application/json body
func NewResolvePostReportRequest(server string, body ResolvePostReportJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewResolvePostReportRequestWithBody(server, "application/json", bodyReader)
}

// NewResolvePostReportRequestWithBody generates requests for ResolvePostReport with any type of body
func NewResolvePostReportRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/post/report/resolve")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSavePostRequest calls the generic SavePost builder with application/json body
func NewSavePostRequest(server string, body SavePostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSavePostRequestWithBody(server, "application/json", bodyReader)
}

// NewSavePostRequestWithBody generates requests for SavePost with any type of body
func NewSavePostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/post/save")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetSiteMetadataRequest generates requests for GetSiteMetadata
func NewGetSiteMetadataRequest(server string, params *GetSiteMetadataParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/post/site_metadata")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "url", runtime.ParamLocationQuery, params.Url); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreatePrivateMessageRequest calls the generic CreatePrivateMessage builder with application/json body
func NewCreatePrivateMessageRequest(server string, body CreatePrivateMessageJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreatePrivateMessageRequestWithBody(server, "application/json", bodyReader)
}

// NewCreatePrivateMessageRequestWithBody generates requests for CreatePrivateMessage with any type of body
func NewCreatePrivateMessageRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/private_message")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewEditPrivateMessageRequest calls the generic EditPrivateMessage builder with application/json body
func NewEditPrivateMessageRequest(server string, body EditPrivateMessageJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewEditPrivateMessageRequestWithBody(server, "application/json", bodyReader)
}

// NewEditPrivateMessageRequestWithBody generates requests for EditPrivateMessage with any type of body
func NewEditPrivateMessageRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/private_message")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeletePrivateMessageRequest calls the generic DeletePrivateMessage builder with application/json body
func NewDeletePrivateMessageRequest(server string, body DeletePrivateMessageJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeletePrivateMessageRequestWithBody(server, "application/json", bodyReader)
}

// NewDeletePrivateMessageRequestWithBody generates requests for DeletePrivateMessage with any type of body
func NewDeletePrivateMessageRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/private_message/delete")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewMarkPrivateMessageAsReadRequest calls the generic MarkPrivateMessageAsRead builder with application/json body
func NewMarkPrivateMessageAsReadRequest(server string, body MarkPrivateMessageAsReadJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewMarkPrivateMessageAsReadRequestWithBody(server, "application/json", bodyReader)
}

// NewMarkPrivateMessageAsReadRequestWithBody generates requests for MarkPrivateMessageAsRead with any type of body
func NewMarkPrivateMessageAsReadRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/private_message/mark_as_read")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreatePrivateMessageReportRequest calls the generic CreatePrivateMessageReport builder with application/json body
func NewCreatePrivateMessageReportRequest(server string, body CreatePrivateMessageReportJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreatePrivateMessageReportRequestWithBody(server, "application/json", bodyReader)
}

// NewCreatePrivateMessageReportRequestWithBody generates requests for CreatePrivateMessageReport with any type of body
func NewCreatePrivateMessageReportRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/private_message/report")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewResolvePrivateMessageReportRequest calls the generic ResolvePrivateMessageReport builder with application/json body
func NewResolvePrivateMessageReportRequest(server string, body ResolvePrivateMessageReportJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewResolvePrivateMessageReportRequestWithBody(server, "application/json", bodyReader)
}

// NewResolvePrivateMessageReportRequestWithBody generates requests for ResolvePrivateMessageReport with any type of body
func NewResolvePrivateMessageReportRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/private_message/report/resolve")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListReportsRequest generates requests for ListReports
func NewListReportsRequest(server string, params *ListReportsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/report/list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.MyReportsOnly != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "my_reports_only", runtime.ParamLocationQuery, *params.MyReportsOnly); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ShowCommunityRuleViolations != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "show_community_rule_violations", runtime.ParamLocationQuery, *params.ShowCommunityRuleViolations); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageBack != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page_back", runtime.ParamLocationQuery, *params.PageBack); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageCursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page_cursor", runtime.ParamLocationQuery, *params.PageCursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CommunityId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "community_id", runtime.ParamLocationQuery, *params.CommunityId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PostId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "post_id", runtime.ParamLocationQuery, *params.PostId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type_", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UnresolvedOnly != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "unresolved_only", runtime.ParamLocationQuery, *params.UnresolvedOnly); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewResolveObjectRequest generates requests for ResolveObject
func NewResolveObjectRequest(server string, params *ResolveObjectParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/resolve_object")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "q", runtime.ParamLocationQuery, params.Q); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSearchRequest generates requests for Search
func NewSearchRequest(server string, params *SearchParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/search")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PageBack != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page_back", runtime.ParamLocationQuery, *params.PageBack); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageCursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page_cursor", runtime.ParamLocationQuery, *params.PageCursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DislikedOnly != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "disliked_only", runtime.ParamLocationQuery, *params.DislikedOnly); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LikedOnly != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "liked_only", runtime.ParamLocationQuery, *params.LikedOnly); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PostUrlOnly != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "post_url_only", runtime.ParamLocationQuery, *params.PostUrlOnly); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TitleOnly != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "title_only", runtime.ParamLocationQuery, *params.TitleOnly); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ListingType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "listing_type", runtime.ParamLocationQuery, *params.ListingType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimeRangeSeconds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "time_range_seconds", runtime.ParamLocationQuery, *params.TimeRangeSeconds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type_", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatorId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "creator_id", runtime.ParamLocationQuery, *params.CreatorId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CommunityName != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "community_name", runtime.ParamLocationQuery, *params.CommunityName); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CommunityId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "community_id", runtime.ParamLocationQuery, *params.CommunityId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SearchTerm != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search_term", runtime.ParamLocationQuery, *params.SearchTerm); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSiteRequest generates requests for GetSite
func NewGetSiteRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/site")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateSiteRequest calls the generic CreateSite builder with application/json body
func NewCreateSiteRequest(server string, body CreateSiteJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateSiteRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateSiteRequestWithBody generates requests for CreateSite with any type of body
func NewCreateSiteRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/site")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewEditSiteRequest calls the generic EditSite builder with application/json body
func NewEditSiteRequest(server string, body EditSiteJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewEditSiteRequestWithBody(server, "application/json", bodyReader)
}

// NewEditSiteRequestWithBody generates requests for EditSite with any type of body
func NewEditSiteRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/site")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteSiteBannerRequest generates requests for DeleteSiteBanner
func NewDeleteSiteBannerRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/site/banner")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUploadSiteBannerRequestWithBody generates requests for UploadSiteBanner with any type of body
func NewUploadSiteBannerRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/site/banner")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteSiteIconRequest generates requests for DeleteSiteIcon
func NewDeleteSiteIconRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/site/icon")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUploadSiteIconRequestWithBody generates requests for UploadSiteIcon with any type of body
func NewUploadSiteIconRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v4/site/icon")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetMyUserWithResponse request
	GetMyUserWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetMyUserResp, error)

	// ChangePasswordWithBodyWithResponse request with any body
	ChangePasswordWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ChangePasswordResp, error)

	ChangePasswordWithResponse(ctx context.Context, body ChangePasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*ChangePasswordResp, error)

	// GetCaptchaWithResponse request
	GetCaptchaWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetCaptchaResp, error)

	// LoginWithBodyWithResponse request with any body
	LoginWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LoginResp, error)

	LoginWithResponse(ctx context.Context, body LoginJSONRequestBody, reqEditors ...RequestEditorFn) (*LoginResp, error)

	// LogoutWithResponse request
	LogoutWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*LogoutResp, error)

	// PasswordChangeAfterResetWithBodyWithResponse request with any body
	PasswordChangeAfterResetWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PasswordChangeAfterResetResp, error)

	PasswordChangeAfterResetWithResponse(ctx context.Context, body PasswordChangeAfterResetJSONRequestBody, reqEditors ...RequestEditorFn) (*PasswordChangeAfterResetResp, error)

	// PasswordResetWithBodyWithResponse request with any body
	PasswordResetWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PasswordResetResp, error)

	PasswordResetWithResponse(ctx context.Context, body PasswordResetJSONRequestBody, reqEditors ...RequestEditorFn) (*PasswordResetResp, error)

	// RegisterWithBodyWithResponse request with any body
	RegisterWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RegisterResp, error)

	RegisterWithResponse(ctx context.Context, body RegisterJSONRequestBody, reqEditors ...RequestEditorFn) (*RegisterResp, error)

	// ResendVerificationEmailWithBodyWithResponse request with any body
	ResendVerificationEmailWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ResendVerificationEmailResp, error)

	ResendVerificationEmailWithResponse(ctx context.Context, body ResendVerificationEmailJSONRequestBody, reqEditors ...RequestEditorFn) (*ResendVerificationEmailResp, error)

	// ListPersonSavedWithResponse request
	ListPersonSavedWithResponse(ctx context.Context, params *ListPersonSavedParams, reqEditors ...RequestEditorFn) (*ListPersonSavedResp, error)

	// GenerateTotpSecretWithResponse request
	GenerateTotpSecretWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GenerateTotpSecretResp, error)

	// UpdateTotpWithBodyWithResponse request with any body
	UpdateTotpWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateTotpResp, error)

	UpdateTotpWithResponse(ctx context.Context, body UpdateTotpJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateTotpResp, error)

	// VerifyEmailWithBodyWithResponse request with any body
	VerifyEmailWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*VerifyEmailResp, error)

	VerifyEmailWithResponse(ctx context.Context, body VerifyEmailJSONRequestBody, reqEditors ...RequestEditorFn) (*VerifyEmailResp, error)

	// DeleteUserAvatarWithResponse request
	DeleteUserAvatarWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*DeleteUserAvatarResp, error)

	// UploadUserAvatarWithBodyWithResponse request with any body
	UploadUserAvatarWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UploadUserAvatarResp, error)

	// DeleteUserBannerWithResponse request
	DeleteUserBannerWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*DeleteUserBannerResp, error)

	// UploadUserBannerWithBodyWithResponse request with any body
	UploadUserBannerWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UploadUserBannerResp, error)

	// BlockCommunityWithBodyWithResponse request with any body
	BlockCommunityWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BlockCommunityResp, error)

	BlockCommunityWithResponse(ctx context.Context, body BlockCommunityJSONRequestBody, reqEditors ...RequestEditorFn) (*BlockCommunityResp, error)

	// UserBlockInstanceWithBodyWithResponse request with any body
	UserBlockInstanceWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UserBlockInstanceResp, error)

	UserBlockInstanceWithResponse(ctx context.Context, body UserBlockInstanceJSONRequestBody, reqEditors ...RequestEditorFn) (*UserBlockInstanceResp, error)

	// BlockPersonWithBodyWithResponse request with any body
	BlockPersonWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BlockPersonResp, error)

	BlockPersonWithResponse(ctx context.Context, body BlockPersonJSONRequestBody, reqEditors ...RequestEditorFn) (*BlockPersonResp, error)

	// DeleteAccountWithBodyWithResponse request with any body
	DeleteAccountWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteAccountResp, error)

	DeleteAccountWithResponse(ctx context.Context, body DeleteAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteAccountResp, error)

	// ListInboxWithResponse request
	ListInboxWithResponse(ctx context.Context, params *ListInboxParams, reqEditors ...RequestEditorFn) (*ListInboxResp, error)

	// ListLoginsWithResponse request
	ListLoginsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListLoginsResp, error)

	// ListMediaWithResponse request
	ListMediaWithResponse(ctx context.Context, params *ListMediaParams, reqEditors ...RequestEditorFn) (*ListMediaResp, error)

	// MarkAllNotificationsAsReadWithResponse request
	MarkAllNotificationsAsReadWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*MarkAllNotificationsAsReadResp, error)

	// MarkCommentMentionAsReadWithBodyWithResponse request with any body
	MarkCommentMentionAsReadWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MarkCommentMentionAsReadResp, error)

	MarkCommentMentionAsReadWithResponse(ctx context.Context, body MarkCommentMentionAsReadJSONRequestBody, reqEditors ...RequestEditorFn) (*MarkCommentMentionAsReadResp, error)

	// MarkPostMentionAsReadWithBodyWithResponse request with any body
	MarkPostMentionAsReadWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MarkPostMentionAsReadResp, error)

	MarkPostMentionAsReadWithResponse(ctx context.Context, body MarkPostMentionAsReadJSONRequestBody, reqEditors ...RequestEditorFn) (*MarkPostMentionAsReadResp, error)

	// GetReportCountWithResponse request
	GetReportCountWithResponse(ctx context.Context, params *GetReportCountParams, reqEditors ...RequestEditorFn) (*GetReportCountResp, error)

	// ExportSettingsWithResponse request
	ExportSettingsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ExportSettingsResp, error)

	// ImportSettingsWithBodyWithResponse request with any body
	ImportSettingsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ImportSettingsResp, error)

	ImportSettingsWithResponse(ctx context.Context, body ImportSettingsJSONRequestBody, reqEditors ...RequestEditorFn) (*ImportSettingsResp, error)

	// SaveUserSettingsWithBodyWithResponse request with any body
	SaveUserSettingsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SaveUserSettingsResp, error)

	SaveUserSettingsWithResponse(ctx context.Context, body SaveUserSettingsJSONRequestBody, reqEditors ...RequestEditorFn) (*SaveUserSettingsResp, error)

	// GetUnreadCountWithResponse request
	GetUnreadCountWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetUnreadCountResp, error)

	// ValidateAuthWithResponse request
	ValidateAuthWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ValidateAuthResp, error)

	// AddAdminWithBodyWithResponse request with any body
	AddAdminWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddAdminResp, error)

	AddAdminWithResponse(ctx context.Context, body AddAdminJSONRequestBody, reqEditors ...RequestEditorFn) (*AddAdminResp, error)

	// BanPersonWithBodyWithResponse request with any body
	BanPersonWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BanPersonResp, error)

	BanPersonWithResponse(ctx context.Context, body BanPersonJSONRequestBody, reqEditors ...RequestEditorFn) (*BanPersonResp, error)

	// GetBannedPersonsWithResponse request
	GetBannedPersonsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetBannedPersonsResp, error)

	// AdminAllowInstanceWithBodyWithResponse request with any body
	AdminAllowInstanceWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AdminAllowInstanceResp, error)

	AdminAllowInstanceWithResponse(ctx context.Context, body AdminAllowInstanceJSONRequestBody, reqEditors ...RequestEditorFn) (*AdminAllowInstanceResp, error)

	// AdminBlockInstanceWithBodyWithResponse request with any body
	AdminBlockInstanceWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AdminBlockInstanceResp, error)

	AdminBlockInstanceWithResponse(ctx context.Context, body AdminBlockInstanceJSONRequestBody, reqEditors ...RequestEditorFn) (*AdminBlockInstanceResp, error)

	// LeaveAdminWithResponse request
	LeaveAdminWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*LeaveAdminResp, error)

	// ListAllMediaWithResponse request
	ListAllMediaWithResponse(ctx context.Context, params *ListAllMediaParams, reqEditors ...RequestEditorFn) (*ListAllMediaResp, error)

	// PurgeCommentWithBodyWithResponse request with any body
	PurgeCommentWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PurgeCommentResp, error)

	PurgeCommentWithResponse(ctx context.Context, body PurgeCommentJSONRequestBody, reqEditors ...RequestEditorFn) (*PurgeCommentResp, error)

	// PurgeCommunityWithBodyWithResponse request with any body
	PurgeCommunityWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PurgeCommunityResp, error)

	PurgeCommunityWithResponse(ctx context.Context, body PurgeCommunityJSONRequestBody, reqEditors ...RequestEditorFn) (*PurgeCommunityResp, error)

	// PurgePersonWithBodyWithResponse request with any body
	PurgePersonWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PurgePersonResp, error)

	PurgePersonWithResponse(ctx context.Context, body PurgePersonJSONRequestBody, reqEditors ...RequestEditorFn) (*PurgePersonResp, error)

	// PurgePostWithBodyWithResponse request with any body
	PurgePostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PurgePostResp, error)

	PurgePostWithResponse(ctx context.Context, body PurgePostJSONRequestBody, reqEditors ...RequestEditorFn) (*PurgePostResp, error)

	// GetRegistrationApplicationWithResponse request
	GetRegistrationApplicationWithResponse(ctx context.Context, params *GetRegistrationApplicationParams, reqEditors ...RequestEditorFn) (*GetRegistrationApplicationResp, error)

	// ApproveRegistrationApplicationWithBodyWithResponse request with any body
	ApproveRegistrationApplicationWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ApproveRegistrationApplicationResp, error)

	ApproveRegistrationApplicationWithResponse(ctx context.Context, body ApproveRegistrationApplicationJSONRequestBody, reqEditors ...RequestEditorFn) (*ApproveRegistrationApplicationResp, error)

	// GetUnreadRegistrationApplicationCountWithResponse request
	GetUnreadRegistrationApplicationCountWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetUnreadRegistrationApplicationCountResp, error)

	// ListRegistrationApplicationsWithResponse request
	ListRegistrationApplicationsWithResponse(ctx context.Context, params *ListRegistrationApplicationsParams, reqEditors ...RequestEditorFn) (*ListRegistrationApplicationsResp, error)

	// CreateTaglineWithBodyWithResponse request with any body
	CreateTaglineWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTaglineResp, error)

	CreateTaglineWithResponse(ctx context.Context, body CreateTaglineJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTaglineResp, error)

	// EditTaglineWithBodyWithResponse request with any body
	EditTaglineWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EditTaglineResp, error)

	EditTaglineWithResponse(ctx context.Context, body EditTaglineJSONRequestBody, reqEditors ...RequestEditorFn) (*EditTaglineResp, error)

	// DeleteTaglineWithBodyWithResponse request with any body
	DeleteTaglineWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteTaglineResp, error)

	DeleteTaglineWithResponse(ctx context.Context, body DeleteTaglineJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteTaglineResp, error)

	// ListTaglinesWithResponse request
	ListTaglinesWithResponse(ctx context.Context, params *ListTaglinesParams, reqEditors ...RequestEditorFn) (*ListTaglinesResp, error)

	// GetCommentWithResponse request
	GetCommentWithResponse(ctx context.Context, params *GetCommentParams, reqEditors ...RequestEditorFn) (*GetCommentResp, error)

	// CreateCommentWithBodyWithResponse request with any body
	CreateCommentWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateCommentResp, error)

	CreateCommentWithResponse(ctx context.Context, body CreateCommentJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateCommentResp, error)

	// EditCommentWithBodyWithResponse request with any body
	EditCommentWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EditCommentResp, error)

	EditCommentWithResponse(ctx context.Context, body EditCommentJSONRequestBody, reqEditors ...RequestEditorFn) (*EditCommentResp, error)

	// DeleteCommentWithBodyWithResponse request with any body
	DeleteCommentWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteCommentResp, error)

	DeleteCommentWithResponse(ctx context.Context, body DeleteCommentJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteCommentResp, error)

	// DistinguishCommentWithBodyWithResponse request with any body
	DistinguishCommentWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DistinguishCommentResp, error)

	DistinguishCommentWithResponse(ctx context.Context, body DistinguishCommentJSONRequestBody, reqEditors ...RequestEditorFn) (*DistinguishCommentResp, error)

	// LikeCommentWithBodyWithResponse request with any body
	LikeCommentWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LikeCommentResp, error)

	LikeCommentWithResponse(ctx context.Context, body LikeCommentJSONRequestBody, reqEditors ...RequestEditorFn) (*LikeCommentResp, error)

	// ListCommentLikesWithResponse request
	ListCommentLikesWithResponse(ctx context.Context, params *ListCommentLikesParams, reqEditors ...RequestEditorFn) (*ListCommentLikesResp, error)

	// GetCommentsWithResponse request
	GetCommentsWithResponse(ctx context.Context, params *GetCommentsParams, reqEditors ...RequestEditorFn) (*GetCommentsResp, error)

	// GetCommentsSlimWithResponse request
	GetCommentsSlimWithResponse(ctx context.Context, params *GetCommentsSlimParams, reqEditors ...RequestEditorFn) (*GetCommentsSlimResp, error)

	// MarkCommentReplyAsReadWithBodyWithResponse request with any body
	MarkCommentReplyAsReadWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MarkCommentReplyAsReadResp, error)

	MarkCommentReplyAsReadWithResponse(ctx context.Context, body MarkCommentReplyAsReadJSONRequestBody, reqEditors ...RequestEditorFn) (*MarkCommentReplyAsReadResp, error)

	// RemoveCommentWithBodyWithResponse request with any body
	RemoveCommentWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RemoveCommentResp, error)

	RemoveCommentWithResponse(ctx context.Context, body RemoveCommentJSONRequestBody, reqEditors ...RequestEditorFn) (*RemoveCommentResp, error)

	// CreateCommentReportWithBodyWithResponse request with any body
	CreateCommentReportWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateCommentReportResp, error)

	CreateCommentReportWithResponse(ctx context.Context, body CreateCommentReportJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateCommentReportResp, error)

	// ResolveCommentReportWithBodyWithResponse request with any body
	ResolveCommentReportWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ResolveCommentReportResp, error)

	ResolveCommentReportWithResponse(ctx context.Context, body ResolveCommentReportJSONRequestBody, reqEditors ...RequestEditorFn) (*ResolveCommentReportResp, error)

	// SaveCommentWithBodyWithResponse request with any body
	SaveCommentWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SaveCommentResp, error)

	SaveCommentWithResponse(ctx context.Context, body SaveCommentJSONRequestBody, reqEditors ...RequestEditorFn) (*SaveCommentResp, error)

	// GetCommunityWithResponse request
	GetCommunityWithResponse(ctx context.Context, params *GetCommunityParams, reqEditors ...RequestEditorFn) (*GetCommunityResp, error)

	// CreateCommunityWithBodyWithResponse request with any body
	CreateCommunityWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateCommunityResp, error)

	CreateCommunityWithResponse(ctx context.Context, body CreateCommunityJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateCommunityResp, error)

	// EditCommunityWithBodyWithResponse request with any body
	EditCommunityWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EditCommunityResp, error)

	EditCommunityWithResponse(ctx context.Context, body EditCommunityJSONRequestBody, reqEditors ...RequestEditorFn) (*EditCommunityResp, error)

	// BanFromCommunityWithBodyWithResponse request with any body
	BanFromCommunityWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BanFromCommunityResp, error)

	BanFromCommunityWithResponse(ctx context.Context, body BanFromCommunityJSONRequestBody, reqEditors ...RequestEditorFn) (*BanFromCommunityResp, error)

	// DeleteCommunityBannerWithResponse request
	DeleteCommunityBannerWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*DeleteCommunityBannerResp, error)

	// UploadCommunityBannerWithBodyWithResponse request with any body
	UploadCommunityBannerWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UploadCommunityBannerResp, error)

	// DeleteCommunityWithBodyWithResponse request with any body
	DeleteCommunityWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteCommunityResp, error)

	DeleteCommunityWithResponse(ctx context.Context, body DeleteCommunityJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteCommunityResp, error)

	// FollowCommunityWithBodyWithResponse request with any body
	FollowCommunityWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FollowCommunityResp, error)

	FollowCommunityWithResponse(ctx context.Context, body FollowCommunityJSONRequestBody, reqEditors ...RequestEditorFn) (*FollowCommunityResp, error)

	// HideCommunityWithBodyWithResponse request with any body
	HideCommunityWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*HideCommunityResp, error)

	HideCommunityWithResponse(ctx context.Context, body HideCommunityJSONRequestBody, reqEditors ...RequestEditorFn) (*HideCommunityResp, error)

	// DeleteCommunityIconWithResponse request
	DeleteCommunityIconWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*DeleteCommunityIconResp, error)

	// UploadCommunityIconWithBodyWithResponse request with any body
	UploadCommunityIconWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UploadCommunityIconResp, error)

	// ListCommunitiesWithResponse request
	ListCommunitiesWithResponse(ctx context.Context, params *ListCommunitiesParams, reqEditors ...RequestEditorFn) (*ListCommunitiesResp, error)

	// AddModToCommunityWithBodyWithResponse request with any body
	AddModToCommunityWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddModToCommunityResp, error)

	AddModToCommunityWithResponse(ctx context.Context, body AddModToCommunityJSONRequestBody, reqEditors ...RequestEditorFn) (*AddModToCommunityResp, error)

	// ApproveCommunityPendingFollowWithBodyWithResponse request with any body
	ApproveCommunityPendingFollowWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ApproveCommunityPendingFollowResp, error)

	ApproveCommunityPendingFollowWithResponse(ctx context.Context, body ApproveCommunityPendingFollowJSONRequestBody, reqEditors ...RequestEditorFn) (*ApproveCommunityPendingFollowResp, error)

	// GetCommunityPendingFollowsCountWithResponse request
	GetCommunityPendingFollowsCountWithResponse(ctx context.Context, params *GetCommunityPendingFollowsCountParams, reqEditors ...RequestEditorFn) (*GetCommunityPendingFollowsCountResp, error)

	// ListCommunityPendingFollowsWithResponse request
	ListCommunityPendingFollowsWithResponse(ctx context.Context, params *ListCommunityPendingFollowsParams, reqEditors ...RequestEditorFn) (*ListCommunityPendingFollowsResp, error)

	// GetRandomCommunityWithResponse request
	GetRandomCommunityWithResponse(ctx context.Context, params *GetRandomCommunityParams, reqEditors ...RequestEditorFn) (*GetRandomCommunityResp, error)

	// RemoveCommunityWithBodyWithResponse request with any body
	RemoveCommunityWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RemoveCommunityResp, error)

	RemoveCommunityWithResponse(ctx context.Context, body RemoveCommunityJSONRequestBody, reqEditors ...RequestEditorFn) (*RemoveCommunityResp, error)

	// TransferCommunityWithBodyWithResponse request with any body
	TransferCommunityWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TransferCommunityResp, error)

	TransferCommunityWithResponse(ctx context.Context, body TransferCommunityJSONRequestBody, reqEditors ...RequestEditorFn) (*TransferCommunityResp, error)

	// CreateCustomEmojiWithBodyWithResponse request with any body
	CreateCustomEmojiWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateCustomEmojiResp, error)

	CreateCustomEmojiWithResponse(ctx context.Context, body CreateCustomEmojiJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateCustomEmojiResp, error)

	// EditCustomEmojiWithBodyWithResponse request with any body
	EditCustomEmojiWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EditCustomEmojiResp, error)

	EditCustomEmojiWithResponse(ctx context.Context, body EditCustomEmojiJSONRequestBody, reqEditors ...RequestEditorFn) (*EditCustomEmojiResp, error)

	// DeleteCustomEmojiWithBodyWithResponse request with any body
	DeleteCustomEmojiWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteCustomEmojiResp, error)

	DeleteCustomEmojiWithResponse(ctx context.Context, body DeleteCustomEmojiJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteCustomEmojiResp, error)

	// ListCustomEmojisWithResponse request
	ListCustomEmojisWithResponse(ctx context.Context, params *ListCustomEmojisParams, reqEditors ...RequestEditorFn) (*ListCustomEmojisResp, error)

	// GetFederatedInstancesWithResponse request
	GetFederatedInstancesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetFederatedInstancesResp, error)

	// DeleteImageWithResponse request
	DeleteImageWithResponse(ctx context.Context, params *DeleteImageParams, reqEditors ...RequestEditorFn) (*DeleteImageResp, error)

	// UploadImageWithBodyWithResponse request with any body
	UploadImageWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UploadImageResp, error)

	// ImageHealthWithResponse request
	ImageHealthWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ImageHealthResp, error)

	// GetModlogWithResponse request
	GetModlogWithResponse(ctx context.Context, params *GetModlogParams, reqEditors ...RequestEditorFn) (*GetModlogResp, error)

	// AuthenticateWithOAuthWithBodyWithResponse request with any body
	AuthenticateWithOAuthWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AuthenticateWithOAuthResp, error)

	AuthenticateWithOAuthWithResponse(ctx context.Context, body AuthenticateWithOAuthJSONRequestBody, reqEditors ...RequestEditorFn) (*AuthenticateWithOAuthResp, error)

	// CreateOAuthProviderWithBodyWithResponse request with any body
	CreateOAuthProviderWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateOAuthProviderResp, error)

	CreateOAuthProviderWithResponse(ctx context.Context, body CreateOAuthProviderJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateOAuthProviderResp, error)

	// EditOAuthProviderWithBodyWithResponse request with any body
	EditOAuthProviderWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EditOAuthProviderResp, error)

	EditOAuthProviderWithResponse(ctx context.Context, body EditOAuthProviderJSONRequestBody, reqEditors ...RequestEditorFn) (*EditOAuthProviderResp, error)

	// DeleteOAuthProviderWithBodyWithResponse request with any body
	DeleteOAuthProviderWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteOAuthProviderResp, error)

	DeleteOAuthProviderWithResponse(ctx context.Context, body DeleteOAuthProviderJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteOAuthProviderResp, error)

	// GetPersonDetailsWithResponse request
	GetPersonDetailsWithResponse(ctx context.Context, params *GetPersonDetailsParams, reqEditors ...RequestEditorFn) (*GetPersonDetailsResp, error)

	// ListPersonContentWithResponse request
	ListPersonContentWithResponse(ctx context.Context, params *ListPersonContentParams, reqEditors ...RequestEditorFn) (*ListPersonContentResp, error)

	// GetPostWithResponse request
	GetPostWithResponse(ctx context.Context, params *GetPostParams, reqEditors ...RequestEditorFn) (*GetPostResp, error)

	// CreatePostWithBodyWithResponse request with any body
	CreatePostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePostResp, error)

	CreatePostWithResponse(ctx context.Context, body CreatePostJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePostResp, error)

	// EditPostWithBodyWithResponse request with any body
	EditPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EditPostResp, error)

	EditPostWithResponse(ctx context.Context, body EditPostJSONRequestBody, reqEditors ...RequestEditorFn) (*EditPostResp, error)

	// DeletePostWithBodyWithResponse request with any body
	DeletePostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeletePostResp, error)

	DeletePostWithResponse(ctx context.Context, body DeletePostJSONRequestBody, reqEditors ...RequestEditorFn) (*DeletePostResp, error)

	// FeaturePostWithBodyWithResponse request with any body
	FeaturePostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FeaturePostResp, error)

	FeaturePostWithResponse(ctx context.Context, body FeaturePostJSONRequestBody, reqEditors ...RequestEditorFn) (*FeaturePostResp, error)

	// HidePostWithBodyWithResponse request with any body
	HidePostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*HidePostResp, error)

	HidePostWithResponse(ctx context.Context, body HidePostJSONRequestBody, reqEditors ...RequestEditorFn) (*HidePostResp, error)

	// LikePostWithBodyWithResponse request with any body
	LikePostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LikePostResp, error)

	LikePostWithResponse(ctx context.Context, body LikePostJSONRequestBody, reqEditors ...RequestEditorFn) (*LikePostResp, error)

	// ListPostLikesWithResponse request
	ListPostLikesWithResponse(ctx context.Context, params *ListPostLikesParams, reqEditors ...RequestEditorFn) (*ListPostLikesResp, error)

	// GetPostsWithResponse request
	GetPostsWithResponse(ctx context.Context, params *GetPostsParams, reqEditors ...RequestEditorFn) (*GetPostsResp, error)

	// LockPostWithBodyWithResponse request with any body
	LockPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LockPostResp, error)

	LockPostWithResponse(ctx context.Context, body LockPostJSONRequestBody, reqEditors ...RequestEditorFn) (*LockPostResp, error)

	// MarkPostAsReadWithBodyWithResponse request with any body
	MarkPostAsReadWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MarkPostAsReadResp, error)

	MarkPostAsReadWithResponse(ctx context.Context, body MarkPostAsReadJSONRequestBody, reqEditors ...RequestEditorFn) (*MarkPostAsReadResp, error)

	// MarkManyPostAsReadWithBodyWithResponse request with any body
	MarkManyPostAsReadWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MarkManyPostAsReadResp, error)

	MarkManyPostAsReadWithResponse(ctx context.Context, body MarkManyPostAsReadJSONRequestBody, reqEditors ...RequestEditorFn) (*MarkManyPostAsReadResp, error)

	// RemovePostWithBodyWithResponse request with any body
	RemovePostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RemovePostResp, error)

	RemovePostWithResponse(ctx context.Context, body RemovePostJSONRequestBody, reqEditors ...RequestEditorFn) (*RemovePostResp, error)

	// CreatePostReportWithBodyWithResponse request with any body
	CreatePostReportWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePostReportResp, error)

	CreatePostReportWithResponse(ctx context.Context, body CreatePostReportJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePostReportResp, error)

	// ResolvePostReportWithBodyWithResponse request with any body
	ResolvePostReportWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ResolvePostReportResp, error)

	ResolvePostReportWithResponse(ctx context.Context, body ResolvePostReportJSONRequestBody, reqEditors ...RequestEditorFn) (*ResolvePostReportResp, error)

	// SavePostWithBodyWithResponse request with any body
	SavePostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SavePostResp, error)

	SavePostWithResponse(ctx context.Context, body SavePostJSONRequestBody, reqEditors ...RequestEditorFn) (*SavePostResp, error)

	// GetSiteMetadataWithResponse request
	GetSiteMetadataWithResponse(ctx context.Context, params *GetSiteMetadataParams, reqEditors ...RequestEditorFn) (*GetSiteMetadataResp, error)

	// CreatePrivateMessageWithBodyWithResponse request with any body
	CreatePrivateMessageWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePrivateMessageResp, error)

	CreatePrivateMessageWithResponse(ctx context.Context, body CreatePrivateMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePrivateMessageResp, error)

	// EditPrivateMessageWithBodyWithResponse request with any body
	EditPrivateMessageWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EditPrivateMessageResp, error)

	EditPrivateMessageWithResponse(ctx context.Context, body EditPrivateMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*EditPrivateMessageResp, error)

	// DeletePrivateMessageWithBodyWithResponse request with any body
	DeletePrivateMessageWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeletePrivateMessageResp, error)

	DeletePrivateMessageWithResponse(ctx context.Context, body DeletePrivateMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*DeletePrivateMessageResp, error)

	// MarkPrivateMessageAsReadWithBodyWithResponse request with any body
	MarkPrivateMessageAsReadWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MarkPrivateMessageAsReadResp, error)

	MarkPrivateMessageAsReadWithResponse(ctx context.Context, body MarkPrivateMessageAsReadJSONRequestBody, reqEditors ...RequestEditorFn) (*MarkPrivateMessageAsReadResp, error)

	// CreatePrivateMessageReportWithBodyWithResponse request with any body
	CreatePrivateMessageReportWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePrivateMessageReportResp, error)

	CreatePrivateMessageReportWithResponse(ctx context.Context, body CreatePrivateMessageReportJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePrivateMessageReportResp, error)

	// ResolvePrivateMessageReportWithBodyWithResponse request with any body
	ResolvePrivateMessageReportWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ResolvePrivateMessageReportResp, error)

	ResolvePrivateMessageReportWithResponse(ctx context.Context, body ResolvePrivateMessageReportJSONRequestBody, reqEditors ...RequestEditorFn) (*ResolvePrivateMessageReportResp, error)

	// ListReportsWithResponse request
	ListReportsWithResponse(ctx context.Context, params *ListReportsParams, reqEditors ...RequestEditorFn) (*ListReportsResp, error)

	// ResolveObjectWithResponse request
	ResolveObjectWithResponse(ctx context.Context, params *ResolveObjectParams, reqEditors ...RequestEditorFn) (*ResolveObjectResp, error)

	// SearchWithResponse request
	SearchWithResponse(ctx context.Context, params *SearchParams, reqEditors ...RequestEditorFn) (*SearchResp, error)

	// GetSiteWithResponse request
	GetSiteWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSiteResp, error)

	// CreateSiteWithBodyWithResponse request with any body
	CreateSiteWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSiteResp, error)

	CreateSiteWithResponse(ctx context.Context, body CreateSiteJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSiteResp, error)

	// EditSiteWithBodyWithResponse request with any body
	EditSiteWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EditSiteResp, error)

	EditSiteWithResponse(ctx context.Context, body EditSiteJSONRequestBody, reqEditors ...RequestEditorFn) (*EditSiteResp, error)

	// DeleteSiteBannerWithResponse request
	DeleteSiteBannerWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*DeleteSiteBannerResp, error)

	// UploadSiteBannerWithBodyWithResponse request with any body
	UploadSiteBannerWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UploadSiteBannerResp, error)

	// DeleteSiteIconWithResponse request
	DeleteSiteIconWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*DeleteSiteIconResp, error)

	// UploadSiteIconWithBodyWithResponse request with any body
	UploadSiteIconWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UploadSiteIconResp, error)
}

type GetMyUserResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MyUserInfo
}

// Status returns HTTPResponse.Status
func (r GetMyUserResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMyUserResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ChangePasswordResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LoginResponse
}

// Status returns HTTPResponse.Status
func (r ChangePasswordResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ChangePasswordResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCaptchaResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetCaptchaResponse
}

// Status returns HTTPResponse.Status
func (r GetCaptchaResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCaptchaResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LoginResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LoginResponse
}

// Status returns HTTPResponse.Status
func (r LoginResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LoginResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LogoutResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SuccessResponse
}

// Status returns HTTPResponse.Status
func (r LogoutResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LogoutResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PasswordChangeAfterResetResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SuccessResponse
}

// Status returns HTTPResponse.Status
func (r PasswordChangeAfterResetResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PasswordChangeAfterResetResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PasswordResetResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SuccessResponse
}

// Status returns HTTPResponse.Status
func (r PasswordResetResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PasswordResetResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RegisterResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LoginResponse
}

// Status returns HTTPResponse.Status
func (r RegisterResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RegisterResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ResendVerificationEmailResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SuccessResponse
}

// Status returns HTTPResponse.Status
func (r ResendVerificationEmailResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ResendVerificationEmailResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListPersonSavedResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListPersonSavedResponse
}

// Status returns HTTPResponse.Status
func (r ListPersonSavedResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListPersonSavedResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GenerateTotpSecretResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GenerateTotpSecretResponse
}

// Status returns HTTPResponse.Status
func (r GenerateTotpSecretResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GenerateTotpSecretResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateTotpResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UpdateTotpResponse
}

// Status returns HTTPResponse.Status
func (r UpdateTotpResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateTotpResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type VerifyEmailResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SuccessResponse
}

// Status returns HTTPResponse.Status
func (r VerifyEmailResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r VerifyEmailResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteUserAvatarResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SuccessResponse
}

// Status returns HTTPResponse.Status
func (r DeleteUserAvatarResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteUserAvatarResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UploadUserAvatarResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SuccessResponse
}

// Status returns HTTPResponse.Status
func (r UploadUserAvatarResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UploadUserAvatarResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteUserBannerResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SuccessResponse
}

// Status returns HTTPResponse.Status
func (r DeleteUserBannerResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteUserBannerResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UploadUserBannerResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SuccessResponse
}

// Status returns HTTPResponse.Status
func (r UploadUserBannerResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UploadUserBannerResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BlockCommunityResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BlockCommunityResponse
}

// Status returns HTTPResponse.Status
func (r BlockCommunityResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BlockCommunityResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UserBlockInstanceResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SuccessResponse
}

// Status returns HTTPResponse.Status
func (r UserBlockInstanceResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UserBlockInstanceResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BlockPersonResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BlockPersonResponse
}

// Status returns HTTPResponse.Status
func (r BlockPersonResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BlockPersonResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteAccountResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SuccessResponse
}

// Status returns HTTPResponse.Status
func (r DeleteAccountResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteAccountResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListInboxResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListInboxResponse
}

// Status returns HTTPResponse.Status
func (r ListInboxResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListInboxResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListLoginsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]LoginToken
}

// Status returns HTTPResponse.Status
func (r ListLoginsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListLoginsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListMediaResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListMediaResponse
}

// Status returns HTTPResponse.Status
func (r ListMediaResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListMediaResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MarkAllNotificationsAsReadResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SuccessResponse
}

// Status returns HTTPResponse.Status
func (r MarkAllNotificationsAsReadResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MarkAllNotificationsAsReadResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MarkCommentMentionAsReadResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SuccessResponse
}

// Status returns HTTPResponse.Status
func (r MarkCommentMentionAsReadResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MarkCommentMentionAsReadResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MarkPostMentionAsReadResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SuccessResponse
}

// Status returns HTTPResponse.Status
func (r MarkPostMentionAsReadResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MarkPostMentionAsReadResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetReportCountResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetReportCountResponse
}

// Status returns HTTPResponse.Status
func (r GetReportCountResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetReportCountResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExportSettingsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *string
}

// Status returns HTTPResponse.Status
func (r ExportSettingsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExportSettingsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ImportSettingsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SuccessResponse
}

// Status returns HTTPResponse.Status
func (r ImportSettingsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ImportSettingsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SaveUserSettingsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SuccessResponse
}

// Status returns HTTPResponse.Status
func (r SaveUserSettingsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SaveUserSettingsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUnreadCountResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetUnreadCountResponse
}

// Status returns HTTPResponse.Status
func (r GetUnreadCountResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUnreadCountResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ValidateAuthResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SuccessResponse
}

// Status returns HTTPResponse.Status
func (r ValidateAuthResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ValidateAuthResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddAdminResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AddAdminResponse
}

// Status returns HTTPResponse.Status
func (r AddAdminResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddAdminResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BanPersonResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BanPersonResponse
}

// Status returns HTTPResponse.Status
func (r BanPersonResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BanPersonResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBannedPersonsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BannedPersonsResponse
}

// Status returns HTTPResponse.Status
func (r GetBannedPersonsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBannedPersonsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AdminAllowInstanceResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SuccessResponse
}

// Status returns HTTPResponse.Status
func (r AdminAllowInstanceResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AdminAllowInstanceResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AdminBlockInstanceResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SuccessResponse
}

// Status returns HTTPResponse.Status
func (r AdminBlockInstanceResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AdminBlockInstanceResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LeaveAdminResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetSiteResponse
}

// Status returns HTTPResponse.Status
func (r LeaveAdminResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LeaveAdminResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListAllMediaResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListMediaResponse
}

// Status returns HTTPResponse.Status
func (r ListAllMediaResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAllMediaResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PurgeCommentResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SuccessResponse
}

// Status returns HTTPResponse.Status
func (r PurgeCommentResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PurgeCommentResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PurgeCommunityResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SuccessResponse
}

// Status returns HTTPResponse.Status
func (r PurgeCommunityResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PurgeCommunityResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PurgePersonResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SuccessResponse
}

// Status returns HTTPResponse.Status
func (r PurgePersonResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PurgePersonResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PurgePostResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SuccessResponse
}

// Status returns HTTPResponse.Status
func (r PurgePostResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PurgePostResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRegistrationApplicationResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RegistrationApplicationResponse
}

// Status returns HTTPResponse.Status
func (r GetRegistrationApplicationResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRegistrationApplicationResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ApproveRegistrationApplicationResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RegistrationApplicationResponse
}

// Status returns HTTPResponse.Status
func (r ApproveRegistrationApplicationResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ApproveRegistrationApplicationResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUnreadRegistrationApplicationCountResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetUnreadRegistrationApplicationCountResponse
}

// Status returns HTTPResponse.Status
func (r GetUnreadRegistrationApplicationCountResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUnreadRegistrationApplicationCountResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListRegistrationApplicationsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListRegistrationApplicationsResponse
}

// Status returns HTTPResponse.Status
func (r ListRegistrationApplicationsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListRegistrationApplicationsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateTaglineResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TaglineResponse
}

// Status returns HTTPResponse.Status
func (r CreateTaglineResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateTaglineResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EditTaglineResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TaglineResponse
}

// Status returns HTTPResponse.Status
func (r EditTaglineResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EditTaglineResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteTaglineResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SuccessResponse
}

// Status returns HTTPResponse.Status
func (r DeleteTaglineResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteTaglineResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListTaglinesResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListTaglinesResponse
}

// Status returns HTTPResponse.Status
func (r ListTaglinesResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListTaglinesResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCommentResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CommentResponse
}

// Status returns HTTPResponse.Status
func (r GetCommentResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCommentResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateCommentResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CommentResponse
}

// Status returns HTTPResponse.Status
func (r CreateCommentResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateCommentResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EditCommentResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CommentResponse
}

// Status returns HTTPResponse.Status
func (r EditCommentResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EditCommentResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteCommentResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CommentResponse
}

// Status returns HTTPResponse.Status
func (r DeleteCommentResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteCommentResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DistinguishCommentResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CommentResponse
}

// Status returns HTTPResponse.Status
func (r DistinguishCommentResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DistinguishCommentResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LikeCommentResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CommentResponse
}

// Status returns HTTPResponse.Status
func (r LikeCommentResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LikeCommentResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListCommentLikesResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListCommentLikesResponse
}

// Status returns HTTPResponse.Status
func (r ListCommentLikesResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListCommentLikesResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCommentsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetCommentsResponse
}

// Status returns HTTPResponse.Status
func (r GetCommentsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCommentsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCommentsSlimResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetCommentsSlimResponse
}

// Status returns HTTPResponse.Status
func (r GetCommentsSlimResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCommentsSlimResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MarkCommentReplyAsReadResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SuccessResponse
}

// Status returns HTTPResponse.Status
func (r MarkCommentReplyAsReadResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MarkCommentReplyAsReadResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveCommentResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CommentResponse
}

// Status returns HTTPResponse.Status
func (r RemoveCommentResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveCommentResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateCommentReportResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CommentReportResponse
}

// Status returns HTTPResponse.Status
func (r CreateCommentReportResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateCommentReportResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ResolveCommentReportResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CommentReportResponse
}

// Status returns HTTPResponse.Status
func (r ResolveCommentReportResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ResolveCommentReportResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SaveCommentResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CommentResponse
}

// Status returns HTTPResponse.Status
func (r SaveCommentResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SaveCommentResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCommunityResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetCommunityResponse
}

// Status returns HTTPResponse.Status
func (r GetCommunityResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCommunityResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateCommunityResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CommunityResponse
}

// Status returns HTTPResponse.Status
func (r CreateCommunityResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateCommunityResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EditCommunityResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CommunityResponse
}

// Status returns HTTPResponse.Status
func (r EditCommunityResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EditCommunityResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BanFromCommunityResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BanFromCommunityResponse
}

// Status returns HTTPResponse.Status
func (r BanFromCommunityResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BanFromCommunityResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteCommunityBannerResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SuccessResponse
}

// Status returns HTTPResponse.Status
func (r DeleteCommunityBannerResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteCommunityBannerResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UploadCommunityBannerResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SuccessResponse
}

// Status returns HTTPResponse.Status
func (r UploadCommunityBannerResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UploadCommunityBannerResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteCommunityResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CommunityResponse
}

// Status returns HTTPResponse.Status
func (r DeleteCommunityResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteCommunityResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FollowCommunityResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CommunityResponse
}

// Status returns HTTPResponse.Status
func (r FollowCommunityResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FollowCommunityResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type HideCommunityResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SuccessResponse
}

// Status returns HTTPResponse.Status
func (r HideCommunityResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r HideCommunityResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteCommunityIconResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SuccessResponse
}

// Status returns HTTPResponse.Status
func (r DeleteCommunityIconResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteCommunityIconResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UploadCommunityIconResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SuccessResponse
}

// Status returns HTTPResponse.Status
func (r UploadCommunityIconResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UploadCommunityIconResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListCommunitiesResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListCommunitiesResponse
}

// Status returns HTTPResponse.Status
func (r ListCommunitiesResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListCommunitiesResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddModToCommunityResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AddModToCommunityResponse
}

// Status returns HTTPResponse.Status
func (r AddModToCommunityResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddModToCommunityResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ApproveCommunityPendingFollowResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SuccessResponse
}

// Status returns HTTPResponse.Status
func (r ApproveCommunityPendingFollowResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ApproveCommunityPendingFollowResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCommunityPendingFollowsCountResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetCommunityPendingFollowsCountResponse
}

// Status returns HTTPResponse.Status
func (r GetCommunityPendingFollowsCountResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCommunityPendingFollowsCountResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListCommunityPendingFollowsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListCommunityPendingFollowsResponse
}

// Status returns HTTPResponse.Status
func (r ListCommunityPendingFollowsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListCommunityPendingFollowsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRandomCommunityResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CommunityResponse
}

// Status returns HTTPResponse.Status
func (r GetRandomCommunityResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRandomCommunityResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveCommunityResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CommunityResponse
}

// Status returns HTTPResponse.Status
func (r RemoveCommunityResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveCommunityResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TransferCommunityResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetCommunityResponse
}

// Status returns HTTPResponse.Status
func (r TransferCommunityResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TransferCommunityResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateCustomEmojiResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CustomEmojiResponse
}

// Status returns HTTPResponse.Status
func (r CreateCustomEmojiResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateCustomEmojiResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EditCustomEmojiResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CustomEmojiResponse
}

// Status returns HTTPResponse.Status
func (r EditCustomEmojiResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EditCustomEmojiResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteCustomEmojiResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SuccessResponse
}

// Status returns HTTPResponse.Status
func (r DeleteCustomEmojiResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteCustomEmojiResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListCustomEmojisResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListCustomEmojisResponse
}

// Status returns HTTPResponse.Status
func (r ListCustomEmojisResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListCustomEmojisResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFederatedInstancesResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetFederatedInstancesResponse
}

// Status returns HTTPResponse.Status
func (r GetFederatedInstancesResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFederatedInstancesResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteImageResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SuccessResponse
}

// Status returns HTTPResponse.Status
func (r DeleteImageResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteImageResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UploadImageResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UploadImageResponse
}

// Status returns HTTPResponse.Status
func (r UploadImageResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UploadImageResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ImageHealthResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SuccessResponse
}

// Status returns HTTPResponse.Status
func (r ImageHealthResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ImageHealthResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetModlogResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetModlogResponse
}

// Status returns HTTPResponse.Status
func (r GetModlogResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetModlogResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AuthenticateWithOAuthResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LoginResponse
}

// Status returns HTTPResponse.Status
func (r AuthenticateWithOAuthResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AuthenticateWithOAuthResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateOAuthProviderResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *OAuthProvider
}

// Status returns HTTPResponse.Status
func (r CreateOAuthProviderResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateOAuthProviderResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EditOAuthProviderResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *OAuthProvider
}

// Status returns HTTPResponse.Status
func (r EditOAuthProviderResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EditOAuthProviderResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteOAuthProviderResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SuccessResponse
}

// Status returns HTTPResponse.Status
func (r DeleteOAuthProviderResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteOAuthProviderResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPersonDetailsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetPersonDetailsResponse
}

// Status returns HTTPResponse.Status
func (r GetPersonDetailsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPersonDetailsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListPersonContentResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListPersonContentResponse
}

// Status returns HTTPResponse.Status
func (r ListPersonContentResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListPersonContentResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPostResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetPostResponse
}

// Status returns HTTPResponse.Status
func (r GetPostResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPostResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreatePostResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PostResponse
}

// Status returns HTTPResponse.Status
func (r CreatePostResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreatePostResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EditPostResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PostResponse
}

// Status returns HTTPResponse.Status
func (r EditPostResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EditPostResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeletePostResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PostResponse
}

// Status returns HTTPResponse.Status
func (r DeletePostResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeletePostResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FeaturePostResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PostResponse
}

// Status returns HTTPResponse.Status
func (r FeaturePostResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FeaturePostResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type HidePostResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SuccessResponse
}

// Status returns HTTPResponse.Status
func (r HidePostResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r HidePostResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LikePostResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PostResponse
}

// Status returns HTTPResponse.Status
func (r LikePostResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LikePostResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListPostLikesResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListPostLikesResponse
}

// Status returns HTTPResponse.Status
func (r ListPostLikesResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListPostLikesResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPostsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetPostsResponse
}

// Status returns HTTPResponse.Status
func (r GetPostsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPostsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LockPostResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PostResponse
}

// Status returns HTTPResponse.Status
func (r LockPostResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LockPostResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MarkPostAsReadResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SuccessResponse
}

// Status returns HTTPResponse.Status
func (r MarkPostAsReadResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MarkPostAsReadResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MarkManyPostAsReadResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SuccessResponse
}

// Status returns HTTPResponse.Status
func (r MarkManyPostAsReadResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MarkManyPostAsReadResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemovePostResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PostResponse
}

// Status returns HTTPResponse.Status
func (r RemovePostResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemovePostResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreatePostReportResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PostReportResponse
}

// Status returns HTTPResponse.Status
func (r CreatePostReportResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreatePostReportResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ResolvePostReportResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PostReportResponse
}

// Status returns HTTPResponse.Status
func (r ResolvePostReportResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ResolvePostReportResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SavePostResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PostResponse
}

// Status returns HTTPResponse.Status
func (r SavePostResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SavePostResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSiteMetadataResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetSiteMetadataResponse
}

// Status returns HTTPResponse.Status
func (r GetSiteMetadataResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSiteMetadataResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreatePrivateMessageResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PrivateMessageResponse
}

// Status returns HTTPResponse.Status
func (r CreatePrivateMessageResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreatePrivateMessageResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EditPrivateMessageResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PrivateMessageResponse
}

// Status returns HTTPResponse.Status
func (r EditPrivateMessageResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EditPrivateMessageResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeletePrivateMessageResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PrivateMessageResponse
}

// Status returns HTTPResponse.Status
func (r DeletePrivateMessageResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeletePrivateMessageResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MarkPrivateMessageAsReadResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PrivateMessageResponse
}

// Status returns HTTPResponse.Status
func (r MarkPrivateMessageAsReadResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MarkPrivateMessageAsReadResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreatePrivateMessageReportResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PrivateMessageReportResponse
}

// Status returns HTTPResponse.Status
func (r CreatePrivateMessageReportResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreatePrivateMessageReportResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ResolvePrivateMessageReportResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PrivateMessageReportResponse
}

// Status returns HTTPResponse.Status
func (r ResolvePrivateMessageReportResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ResolvePrivateMessageReportResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListReportsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListReportsResponse
}

// Status returns HTTPResponse.Status
func (r ListReportsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListReportsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ResolveObjectResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ResolveObjectResponse
}

// Status returns HTTPResponse.Status
func (r ResolveObjectResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ResolveObjectResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SearchResponse
}

// Status returns HTTPResponse.Status
func (r SearchResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSiteResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetSiteResponse
}

// Status returns HTTPResponse.Status
func (r GetSiteResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSiteResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateSiteResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SiteResponse
}

// Status returns HTTPResponse.Status
func (r CreateSiteResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSiteResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EditSiteResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SiteResponse
}

// Status returns HTTPResponse.Status
func (r EditSiteResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EditSiteResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSiteBannerResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SuccessResponse
}

// Status returns HTTPResponse.Status
func (r DeleteSiteBannerResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSiteBannerResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UploadSiteBannerResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SuccessResponse
}

// Status returns HTTPResponse.Status
func (r UploadSiteBannerResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UploadSiteBannerResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSiteIconResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SuccessResponse
}

// Status returns HTTPResponse.Status
func (r DeleteSiteIconResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSiteIconResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UploadSiteIconResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SuccessResponse
}

// Status returns HTTPResponse.Status
func (r UploadSiteIconResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UploadSiteIconResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetMyUserWithResponse request returning *GetMyUserResp
func (c *ClientWithResponses) GetMyUserWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetMyUserResp, error) {
	rsp, err := c.GetMyUser(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMyUserResp(rsp)
}

// ChangePasswordWithBodyWithResponse request with arbitrary body returning *ChangePasswordResp
func (c *ClientWithResponses) ChangePasswordWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ChangePasswordResp, error) {
	rsp, err := c.ChangePasswordWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseChangePasswordResp(rsp)
}

func (c *ClientWithResponses) ChangePasswordWithResponse(ctx context.Context, body ChangePasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*ChangePasswordResp, error) {
	rsp, err := c.ChangePassword(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseChangePasswordResp(rsp)
}

// GetCaptchaWithResponse request returning *GetCaptchaResp
func (c *ClientWithResponses) GetCaptchaWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetCaptchaResp, error) {
	rsp, err := c.GetCaptcha(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCaptchaResp(rsp)
}

// LoginWithBodyWithResponse request with arbitrary body returning *LoginResp
func (c *ClientWithResponses) LoginWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LoginResp, error) {
	rsp, err := c.LoginWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLoginResp(rsp)
}

func (c *ClientWithResponses) LoginWithResponse(ctx context.Context, body LoginJSONRequestBody, reqEditors ...RequestEditorFn) (*LoginResp, error) {
	rsp, err := c.Login(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLoginResp(rsp)
}

// LogoutWithResponse request returning *LogoutResp
func (c *ClientWithResponses) LogoutWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*LogoutResp, error) {
	rsp, err := c.Logout(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLogoutResp(rsp)
}

// PasswordChangeAfterResetWithBodyWithResponse request with arbitrary body returning *PasswordChangeAfterResetResp
func (c *ClientWithResponses) PasswordChangeAfterResetWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PasswordChangeAfterResetResp, error) {
	rsp, err := c.PasswordChangeAfterResetWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePasswordChangeAfterResetResp(rsp)
}

func (c *ClientWithResponses) PasswordChangeAfterResetWithResponse(ctx context.Context, body PasswordChangeAfterResetJSONRequestBody, reqEditors ...RequestEditorFn) (*PasswordChangeAfterResetResp, error) {
	rsp, err := c.PasswordChangeAfterReset(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePasswordChangeAfterResetResp(rsp)
}

// PasswordResetWithBodyWithResponse request with arbitrary body returning *PasswordResetResp
func (c *ClientWithResponses) PasswordResetWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PasswordResetResp, error) {
	rsp, err := c.PasswordResetWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePasswordResetResp(rsp)
}

func (c *ClientWithResponses) PasswordResetWithResponse(ctx context.Context, body PasswordResetJSONRequestBody, reqEditors ...RequestEditorFn) (*PasswordResetResp, error) {
	rsp, err := c.PasswordReset(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePasswordResetResp(rsp)
}

// RegisterWithBodyWithResponse request with arbitrary body returning *RegisterResp
func (c *ClientWithResponses) RegisterWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RegisterResp, error) {
	rsp, err := c.RegisterWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRegisterResp(rsp)
}

func (c *ClientWithResponses) RegisterWithResponse(ctx context.Context, body RegisterJSONRequestBody, reqEditors ...RequestEditorFn) (*RegisterResp, error) {
	rsp, err := c.Register(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRegisterResp(rsp)
}

// ResendVerificationEmailWithBodyWithResponse request with arbitrary body returning *ResendVerificationEmailResp
func (c *ClientWithResponses) ResendVerificationEmailWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ResendVerificationEmailResp, error) {
	rsp, err := c.ResendVerificationEmailWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseResendVerificationEmailResp(rsp)
}

func (c *ClientWithResponses) ResendVerificationEmailWithResponse(ctx context.Context, body ResendVerificationEmailJSONRequestBody, reqEditors ...RequestEditorFn) (*ResendVerificationEmailResp, error) {
	rsp, err := c.ResendVerificationEmail(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseResendVerificationEmailResp(rsp)
}

// ListPersonSavedWithResponse request returning *ListPersonSavedResp
func (c *ClientWithResponses) ListPersonSavedWithResponse(ctx context.Context, params *ListPersonSavedParams, reqEditors ...RequestEditorFn) (*ListPersonSavedResp, error) {
	rsp, err := c.ListPersonSaved(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListPersonSavedResp(rsp)
}

// GenerateTotpSecretWithResponse request returning *GenerateTotpSecretResp
func (c *ClientWithResponses) GenerateTotpSecretWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GenerateTotpSecretResp, error) {
	rsp, err := c.GenerateTotpSecret(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGenerateTotpSecretResp(rsp)
}

// UpdateTotpWithBodyWithResponse request with arbitrary body returning *UpdateTotpResp
func (c *ClientWithResponses) UpdateTotpWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateTotpResp, error) {
	rsp, err := c.UpdateTotpWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateTotpResp(rsp)
}

func (c *ClientWithResponses) UpdateTotpWithResponse(ctx context.Context, body UpdateTotpJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateTotpResp, error) {
	rsp, err := c.UpdateTotp(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateTotpResp(rsp)
}

// VerifyEmailWithBodyWithResponse request with arbitrary body returning *VerifyEmailResp
func (c *ClientWithResponses) VerifyEmailWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*VerifyEmailResp, error) {
	rsp, err := c.VerifyEmailWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseVerifyEmailResp(rsp)
}

func (c *ClientWithResponses) VerifyEmailWithResponse(ctx context.Context, body VerifyEmailJSONRequestBody, reqEditors ...RequestEditorFn) (*VerifyEmailResp, error) {
	rsp, err := c.VerifyEmail(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseVerifyEmailResp(rsp)
}

// DeleteUserAvatarWithResponse request returning *DeleteUserAvatarResp
func (c *ClientWithResponses) DeleteUserAvatarWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*DeleteUserAvatarResp, error) {
	rsp, err := c.DeleteUserAvatar(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteUserAvatarResp(rsp)
}

// UploadUserAvatarWithBodyWithResponse request with arbitrary body returning *UploadUserAvatarResp
func (c *ClientWithResponses) UploadUserAvatarWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UploadUserAvatarResp, error) {
	rsp, err := c.UploadUserAvatarWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUploadUserAvatarResp(rsp)
}

// DeleteUserBannerWithResponse request returning *DeleteUserBannerResp
func (c *ClientWithResponses) DeleteUserBannerWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*DeleteUserBannerResp, error) {
	rsp, err := c.DeleteUserBanner(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteUserBannerResp(rsp)
}

// UploadUserBannerWithBodyWithResponse request with arbitrary body returning *UploadUserBannerResp
func (c *ClientWithResponses) UploadUserBannerWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UploadUserBannerResp, error) {
	rsp, err := c.UploadUserBannerWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUploadUserBannerResp(rsp)
}

// BlockCommunityWithBodyWithResponse request with arbitrary body returning *BlockCommunityResp
func (c *ClientWithResponses) BlockCommunityWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BlockCommunityResp, error) {
	rsp, err := c.BlockCommunityWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBlockCommunityResp(rsp)
}

func (c *ClientWithResponses) BlockCommunityWithResponse(ctx context.Context, body BlockCommunityJSONRequestBody, reqEditors ...RequestEditorFn) (*BlockCommunityResp, error) {
	rsp, err := c.BlockCommunity(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBlockCommunityResp(rsp)
}

// UserBlockInstanceWithBodyWithResponse request with arbitrary body returning *UserBlockInstanceResp
func (c *ClientWithResponses) UserBlockInstanceWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UserBlockInstanceResp, error) {
	rsp, err := c.UserBlockInstanceWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUserBlockInstanceResp(rsp)
}

func (c *ClientWithResponses) UserBlockInstanceWithResponse(ctx context.Context, body UserBlockInstanceJSONRequestBody, reqEditors ...RequestEditorFn) (*UserBlockInstanceResp, error) {
	rsp, err := c.UserBlockInstance(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUserBlockInstanceResp(rsp)
}

// BlockPersonWithBodyWithResponse request with arbitrary body returning *BlockPersonResp
func (c *ClientWithResponses) BlockPersonWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BlockPersonResp, error) {
	rsp, err := c.BlockPersonWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBlockPersonResp(rsp)
}

func (c *ClientWithResponses) BlockPersonWithResponse(ctx context.Context, body BlockPersonJSONRequestBody, reqEditors ...RequestEditorFn) (*BlockPersonResp, error) {
	rsp, err := c.BlockPerson(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBlockPersonResp(rsp)
}

// DeleteAccountWithBodyWithResponse request with arbitrary body returning *DeleteAccountResp
func (c *ClientWithResponses) DeleteAccountWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteAccountResp, error) {
	rsp, err := c.DeleteAccountWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteAccountResp(rsp)
}

func (c *ClientWithResponses) DeleteAccountWithResponse(ctx context.Context, body DeleteAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteAccountResp, error) {
	rsp, err := c.DeleteAccount(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteAccountResp(rsp)
}

// ListInboxWithResponse request returning *ListInboxResp
func (c *ClientWithResponses) ListInboxWithResponse(ctx context.Context, params *ListInboxParams, reqEditors ...RequestEditorFn) (*ListInboxResp, error) {
	rsp, err := c.ListInbox(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListInboxResp(rsp)
}

// ListLoginsWithResponse request returning *ListLoginsResp
func (c *ClientWithResponses) ListLoginsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListLoginsResp, error) {
	rsp, err := c.ListLogins(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListLoginsResp(rsp)
}

// ListMediaWithResponse request returning *ListMediaResp
func (c *ClientWithResponses) ListMediaWithResponse(ctx context.Context, params *ListMediaParams, reqEditors ...RequestEditorFn) (*ListMediaResp, error) {
	rsp, err := c.ListMedia(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListMediaResp(rsp)
}

// MarkAllNotificationsAsReadWithResponse request returning *MarkAllNotificationsAsReadResp
func (c *ClientWithResponses) MarkAllNotificationsAsReadWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*MarkAllNotificationsAsReadResp, error) {
	rsp, err := c.MarkAllNotificationsAsRead(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMarkAllNotificationsAsReadResp(rsp)
}

// MarkCommentMentionAsReadWithBodyWithResponse request with arbitrary body returning *MarkCommentMentionAsReadResp
func (c *ClientWithResponses) MarkCommentMentionAsReadWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MarkCommentMentionAsReadResp, error) {
	rsp, err := c.MarkCommentMentionAsReadWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMarkCommentMentionAsReadResp(rsp)
}

func (c *ClientWithResponses) MarkCommentMentionAsReadWithResponse(ctx context.Context, body MarkCommentMentionAsReadJSONRequestBody, reqEditors ...RequestEditorFn) (*MarkCommentMentionAsReadResp, error) {
	rsp, err := c.MarkCommentMentionAsRead(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMarkCommentMentionAsReadResp(rsp)
}

// MarkPostMentionAsReadWithBodyWithResponse request with arbitrary body returning *MarkPostMentionAsReadResp
func (c *ClientWithResponses) MarkPostMentionAsReadWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MarkPostMentionAsReadResp, error) {
	rsp, err := c.MarkPostMentionAsReadWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMarkPostMentionAsReadResp(rsp)
}

func (c *ClientWithResponses) MarkPostMentionAsReadWithResponse(ctx context.Context, body MarkPostMentionAsReadJSONRequestBody, reqEditors ...RequestEditorFn) (*MarkPostMentionAsReadResp, error) {
	rsp, err := c.MarkPostMentionAsRead(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMarkPostMentionAsReadResp(rsp)
}

// GetReportCountWithResponse request returning *GetReportCountResp
func (c *ClientWithResponses) GetReportCountWithResponse(ctx context.Context, params *GetReportCountParams, reqEditors ...RequestEditorFn) (*GetReportCountResp, error) {
	rsp, err := c.GetReportCount(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetReportCountResp(rsp)
}

// ExportSettingsWithResponse request returning *ExportSettingsResp
func (c *ClientWithResponses) ExportSettingsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ExportSettingsResp, error) {
	rsp, err := c.ExportSettings(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExportSettingsResp(rsp)
}

// ImportSettingsWithBodyWithResponse request with arbitrary body returning *ImportSettingsResp
func (c *ClientWithResponses) ImportSettingsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ImportSettingsResp, error) {
	rsp, err := c.ImportSettingsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseImportSettingsResp(rsp)
}

func (c *ClientWithResponses) ImportSettingsWithResponse(ctx context.Context, body ImportSettingsJSONRequestBody, reqEditors ...RequestEditorFn) (*ImportSettingsResp, error) {
	rsp, err := c.ImportSettings(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseImportSettingsResp(rsp)
}

// SaveUserSettingsWithBodyWithResponse request with arbitrary body returning *SaveUserSettingsResp
func (c *ClientWithResponses) SaveUserSettingsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SaveUserSettingsResp, error) {
	rsp, err := c.SaveUserSettingsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSaveUserSettingsResp(rsp)
}

func (c *ClientWithResponses) SaveUserSettingsWithResponse(ctx context.Context, body SaveUserSettingsJSONRequestBody, reqEditors ...RequestEditorFn) (*SaveUserSettingsResp, error) {
	rsp, err := c.SaveUserSettings(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSaveUserSettingsResp(rsp)
}

// GetUnreadCountWithResponse request returning *GetUnreadCountResp
func (c *ClientWithResponses) GetUnreadCountWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetUnreadCountResp, error) {
	rsp, err := c.GetUnreadCount(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUnreadCountResp(rsp)
}

// ValidateAuthWithResponse request returning *ValidateAuthResp
func (c *ClientWithResponses) ValidateAuthWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ValidateAuthResp, error) {
	rsp, err := c.ValidateAuth(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseValidateAuthResp(rsp)
}

// AddAdminWithBodyWithResponse request with arbitrary body returning *AddAdminResp
func (c *ClientWithResponses) AddAdminWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddAdminResp, error) {
	rsp, err := c.AddAdminWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddAdminResp(rsp)
}

func (c *ClientWithResponses) AddAdminWithResponse(ctx context.Context, body AddAdminJSONRequestBody, reqEditors ...RequestEditorFn) (*AddAdminResp, error) {
	rsp, err := c.AddAdmin(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddAdminResp(rsp)
}

// BanPersonWithBodyWithResponse request with arbitrary body returning *BanPersonResp
func (c *ClientWithResponses) BanPersonWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BanPersonResp, error) {
	rsp, err := c.BanPersonWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBanPersonResp(rsp)
}

func (c *ClientWithResponses) BanPersonWithResponse(ctx context.Context, body BanPersonJSONRequestBody, reqEditors ...RequestEditorFn) (*BanPersonResp, error) {
	rsp, err := c.BanPerson(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBanPersonResp(rsp)
}

// GetBannedPersonsWithResponse request returning *GetBannedPersonsResp
func (c *ClientWithResponses) GetBannedPersonsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetBannedPersonsResp, error) {
	rsp, err := c.GetBannedPersons(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBannedPersonsResp(rsp)
}

// AdminAllowInstanceWithBodyWithResponse request with arbitrary body returning *AdminAllowInstanceResp
func (c *ClientWithResponses) AdminAllowInstanceWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AdminAllowInstanceResp, error) {
	rsp, err := c.AdminAllowInstanceWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAdminAllowInstanceResp(rsp)
}

func (c *ClientWithResponses) AdminAllowInstanceWithResponse(ctx context.Context, body AdminAllowInstanceJSONRequestBody, reqEditors ...RequestEditorFn) (*AdminAllowInstanceResp, error) {
	rsp, err := c.AdminAllowInstance(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAdminAllowInstanceResp(rsp)
}

// AdminBlockInstanceWithBodyWithResponse request with arbitrary body returning *AdminBlockInstanceResp
func (c *ClientWithResponses) AdminBlockInstanceWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AdminBlockInstanceResp, error) {
	rsp, err := c.AdminBlockInstanceWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAdminBlockInstanceResp(rsp)
}

func (c *ClientWithResponses) AdminBlockInstanceWithResponse(ctx context.Context, body AdminBlockInstanceJSONRequestBody, reqEditors ...RequestEditorFn) (*AdminBlockInstanceResp, error) {
	rsp, err := c.AdminBlockInstance(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAdminBlockInstanceResp(rsp)
}

// LeaveAdminWithResponse request returning *LeaveAdminResp
func (c *ClientWithResponses) LeaveAdminWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*LeaveAdminResp, error) {
	rsp, err := c.LeaveAdmin(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLeaveAdminResp(rsp)
}

// ListAllMediaWithResponse request returning *ListAllMediaResp
func (c *ClientWithResponses) ListAllMediaWithResponse(ctx context.Context, params *ListAllMediaParams, reqEditors ...RequestEditorFn) (*ListAllMediaResp, error) {
	rsp, err := c.ListAllMedia(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAllMediaResp(rsp)
}

// PurgeCommentWithBodyWithResponse request with arbitrary body returning *PurgeCommentResp
func (c *ClientWithResponses) PurgeCommentWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PurgeCommentResp, error) {
	rsp, err := c.PurgeCommentWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePurgeCommentResp(rsp)
}

func (c *ClientWithResponses) PurgeCommentWithResponse(ctx context.Context, body PurgeCommentJSONRequestBody, reqEditors ...RequestEditorFn) (*PurgeCommentResp, error) {
	rsp, err := c.PurgeComment(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePurgeCommentResp(rsp)
}

// PurgeCommunityWithBodyWithResponse request with arbitrary body returning *PurgeCommunityResp
func (c *ClientWithResponses) PurgeCommunityWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PurgeCommunityResp, error) {
	rsp, err := c.PurgeCommunityWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePurgeCommunityResp(rsp)
}

func (c *ClientWithResponses) PurgeCommunityWithResponse(ctx context.Context, body PurgeCommunityJSONRequestBody, reqEditors ...RequestEditorFn) (*PurgeCommunityResp, error) {
	rsp, err := c.PurgeCommunity(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePurgeCommunityResp(rsp)
}

// PurgePersonWithBodyWithResponse request with arbitrary body returning *PurgePersonResp
func (c *ClientWithResponses) PurgePersonWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PurgePersonResp, error) {
	rsp, err := c.PurgePersonWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePurgePersonResp(rsp)
}

func (c *ClientWithResponses) PurgePersonWithResponse(ctx context.Context, body PurgePersonJSONRequestBody, reqEditors ...RequestEditorFn) (*PurgePersonResp, error) {
	rsp, err := c.PurgePerson(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePurgePersonResp(rsp)
}

// PurgePostWithBodyWithResponse request with arbitrary body returning *PurgePostResp
func (c *ClientWithResponses) PurgePostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PurgePostResp, error) {
	rsp, err := c.PurgePostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePurgePostResp(rsp)
}

func (c *ClientWithResponses) PurgePostWithResponse(ctx context.Context, body PurgePostJSONRequestBody, reqEditors ...RequestEditorFn) (*PurgePostResp, error) {
	rsp, err := c.PurgePost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePurgePostResp(rsp)
}

// GetRegistrationApplicationWithResponse request returning *GetRegistrationApplicationResp
func (c *ClientWithResponses) GetRegistrationApplicationWithResponse(ctx context.Context, params *GetRegistrationApplicationParams, reqEditors ...RequestEditorFn) (*GetRegistrationApplicationResp, error) {
	rsp, err := c.GetRegistrationApplication(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRegistrationApplicationResp(rsp)
}

// ApproveRegistrationApplicationWithBodyWithResponse request with arbitrary body returning *ApproveRegistrationApplicationResp
func (c *ClientWithResponses) ApproveRegistrationApplicationWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ApproveRegistrationApplicationResp, error) {
	rsp, err := c.ApproveRegistrationApplicationWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseApproveRegistrationApplicationResp(rsp)
}

func (c *ClientWithResponses) ApproveRegistrationApplicationWithResponse(ctx context.Context, body ApproveRegistrationApplicationJSONRequestBody, reqEditors ...RequestEditorFn) (*ApproveRegistrationApplicationResp, error) {
	rsp, err := c.ApproveRegistrationApplication(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseApproveRegistrationApplicationResp(rsp)
}

// GetUnreadRegistrationApplicationCountWithResponse request returning *GetUnreadRegistrationApplicationCountResp
func (c *ClientWithResponses) GetUnreadRegistrationApplicationCountWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetUnreadRegistrationApplicationCountResp, error) {
	rsp, err := c.GetUnreadRegistrationApplicationCount(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUnreadRegistrationApplicationCountResp(rsp)
}

// ListRegistrationApplicationsWithResponse request returning *ListRegistrationApplicationsResp
func (c *ClientWithResponses) ListRegistrationApplicationsWithResponse(ctx context.Context, params *ListRegistrationApplicationsParams, reqEditors ...RequestEditorFn) (*ListRegistrationApplicationsResp, error) {
	rsp, err := c.ListRegistrationApplications(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListRegistrationApplicationsResp(rsp)
}

// CreateTaglineWithBodyWithResponse request with arbitrary body returning *CreateTaglineResp
func (c *ClientWithResponses) CreateTaglineWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTaglineResp, error) {
	rsp, err := c.CreateTaglineWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTaglineResp(rsp)
}

func (c *ClientWithResponses) CreateTaglineWithResponse(ctx context.Context, body CreateTaglineJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTaglineResp, error) {
	rsp, err := c.CreateTagline(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTaglineResp(rsp)
}

// EditTaglineWithBodyWithResponse request with arbitrary body returning *EditTaglineResp
func (c *ClientWithResponses) EditTaglineWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EditTaglineResp, error) {
	rsp, err := c.EditTaglineWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEditTaglineResp(rsp)
}

func (c *ClientWithResponses) EditTaglineWithResponse(ctx context.Context, body EditTaglineJSONRequestBody, reqEditors ...RequestEditorFn) (*EditTaglineResp, error) {
	rsp, err := c.EditTagline(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEditTaglineResp(rsp)
}

// DeleteTaglineWithBodyWithResponse request with arbitrary body returning *DeleteTaglineResp
func (c *ClientWithResponses) DeleteTaglineWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteTaglineResp, error) {
	rsp, err := c.DeleteTaglineWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteTaglineResp(rsp)
}

func (c *ClientWithResponses) DeleteTaglineWithResponse(ctx context.Context, body DeleteTaglineJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteTaglineResp, error) {
	rsp, err := c.DeleteTagline(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteTaglineResp(rsp)
}

// ListTaglinesWithResponse request returning *ListTaglinesResp
func (c *ClientWithResponses) ListTaglinesWithResponse(ctx context.Context, params *ListTaglinesParams, reqEditors ...RequestEditorFn) (*ListTaglinesResp, error) {
	rsp, err := c.ListTaglines(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListTaglinesResp(rsp)
}

// GetCommentWithResponse request returning *GetCommentResp
func (c *ClientWithResponses) GetCommentWithResponse(ctx context.Context, params *GetCommentParams, reqEditors ...RequestEditorFn) (*GetCommentResp, error) {
	rsp, err := c.GetComment(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCommentResp(rsp)
}

// CreateCommentWithBodyWithResponse request with arbitrary body returning *CreateCommentResp
func (c *ClientWithResponses) CreateCommentWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateCommentResp, error) {
	rsp, err := c.CreateCommentWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateCommentResp(rsp)
}

func (c *ClientWithResponses) CreateCommentWithResponse(ctx context.Context, body CreateCommentJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateCommentResp, error) {
	rsp, err := c.CreateComment(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateCommentResp(rsp)
}

// EditCommentWithBodyWithResponse request with arbitrary body returning *EditCommentResp
func (c *ClientWithResponses) EditCommentWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EditCommentResp, error) {
	rsp, err := c.EditCommentWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEditCommentResp(rsp)
}

func (c *ClientWithResponses) EditCommentWithResponse(ctx context.Context, body EditCommentJSONRequestBody, reqEditors ...RequestEditorFn) (*EditCommentResp, error) {
	rsp, err := c.EditComment(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEditCommentResp(rsp)
}

// DeleteCommentWithBodyWithResponse request with arbitrary body returning *DeleteCommentResp
func (c *ClientWithResponses) DeleteCommentWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteCommentResp, error) {
	rsp, err := c.DeleteCommentWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteCommentResp(rsp)
}

func (c *ClientWithResponses) DeleteCommentWithResponse(ctx context.Context, body DeleteCommentJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteCommentResp, error) {
	rsp, err := c.DeleteComment(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteCommentResp(rsp)
}

// DistinguishCommentWithBodyWithResponse request with arbitrary body returning *DistinguishCommentResp
func (c *ClientWithResponses) DistinguishCommentWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DistinguishCommentResp, error) {
	rsp, err := c.DistinguishCommentWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDistinguishCommentResp(rsp)
}

func (c *ClientWithResponses) DistinguishCommentWithResponse(ctx context.Context, body DistinguishCommentJSONRequestBody, reqEditors ...RequestEditorFn) (*DistinguishCommentResp, error) {
	rsp, err := c.DistinguishComment(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDistinguishCommentResp(rsp)
}

// LikeCommentWithBodyWithResponse request with arbitrary body returning *LikeCommentResp
func (c *ClientWithResponses) LikeCommentWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LikeCommentResp, error) {
	rsp, err := c.LikeCommentWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLikeCommentResp(rsp)
}

func (c *ClientWithResponses) LikeCommentWithResponse(ctx context.Context, body LikeCommentJSONRequestBody, reqEditors ...RequestEditorFn) (*LikeCommentResp, error) {
	rsp, err := c.LikeComment(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLikeCommentResp(rsp)
}

// ListCommentLikesWithResponse request returning *ListCommentLikesResp
func (c *ClientWithResponses) ListCommentLikesWithResponse(ctx context.Context, params *ListCommentLikesParams, reqEditors ...RequestEditorFn) (*ListCommentLikesResp, error) {
	rsp, err := c.ListCommentLikes(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListCommentLikesResp(rsp)
}

// GetCommentsWithResponse request returning *GetCommentsResp
func (c *ClientWithResponses) GetCommentsWithResponse(ctx context.Context, params *GetCommentsParams, reqEditors ...RequestEditorFn) (*GetCommentsResp, error) {
	rsp, err := c.GetComments(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCommentsResp(rsp)
}

// GetCommentsSlimWithResponse request returning *GetCommentsSlimResp
func (c *ClientWithResponses) GetCommentsSlimWithResponse(ctx context.Context, params *GetCommentsSlimParams, reqEditors ...RequestEditorFn) (*GetCommentsSlimResp, error) {
	rsp, err := c.GetCommentsSlim(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCommentsSlimResp(rsp)
}

// MarkCommentReplyAsReadWithBodyWithResponse request with arbitrary body returning *MarkCommentReplyAsReadResp
func (c *ClientWithResponses) MarkCommentReplyAsReadWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MarkCommentReplyAsReadResp, error) {
	rsp, err := c.MarkCommentReplyAsReadWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMarkCommentReplyAsReadResp(rsp)
}

func (c *ClientWithResponses) MarkCommentReplyAsReadWithResponse(ctx context.Context, body MarkCommentReplyAsReadJSONRequestBody, reqEditors ...RequestEditorFn) (*MarkCommentReplyAsReadResp, error) {
	rsp, err := c.MarkCommentReplyAsRead(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMarkCommentReplyAsReadResp(rsp)
}

// RemoveCommentWithBodyWithResponse request with arbitrary body returning *RemoveCommentResp
func (c *ClientWithResponses) RemoveCommentWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RemoveCommentResp, error) {
	rsp, err := c.RemoveCommentWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveCommentResp(rsp)
}

func (c *ClientWithResponses) RemoveCommentWithResponse(ctx context.Context, body RemoveCommentJSONRequestBody, reqEditors ...RequestEditorFn) (*RemoveCommentResp, error) {
	rsp, err := c.RemoveComment(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveCommentResp(rsp)
}

// CreateCommentReportWithBodyWithResponse request with arbitrary body returning *CreateCommentReportResp
func (c *ClientWithResponses) CreateCommentReportWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateCommentReportResp, error) {
	rsp, err := c.CreateCommentReportWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateCommentReportResp(rsp)
}

func (c *ClientWithResponses) CreateCommentReportWithResponse(ctx context.Context, body CreateCommentReportJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateCommentReportResp, error) {
	rsp, err := c.CreateCommentReport(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateCommentReportResp(rsp)
}

// ResolveCommentReportWithBodyWithResponse request with arbitrary body returning *ResolveCommentReportResp
func (c *ClientWithResponses) ResolveCommentReportWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ResolveCommentReportResp, error) {
	rsp, err := c.ResolveCommentReportWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseResolveCommentReportResp(rsp)
}

func (c *ClientWithResponses) ResolveCommentReportWithResponse(ctx context.Context, body ResolveCommentReportJSONRequestBody, reqEditors ...RequestEditorFn) (*ResolveCommentReportResp, error) {
	rsp, err := c.ResolveCommentReport(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseResolveCommentReportResp(rsp)
}

// SaveCommentWithBodyWithResponse request with arbitrary body returning *SaveCommentResp
func (c *ClientWithResponses) SaveCommentWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SaveCommentResp, error) {
	rsp, err := c.SaveCommentWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSaveCommentResp(rsp)
}

func (c *ClientWithResponses) SaveCommentWithResponse(ctx context.Context, body SaveCommentJSONRequestBody, reqEditors ...RequestEditorFn) (*SaveCommentResp, error) {
	rsp, err := c.SaveComment(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSaveCommentResp(rsp)
}

// GetCommunityWithResponse request returning *GetCommunityResp
func (c *ClientWithResponses) GetCommunityWithResponse(ctx context.Context, params *GetCommunityParams, reqEditors ...RequestEditorFn) (*GetCommunityResp, error) {
	rsp, err := c.GetCommunity(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCommunityResp(rsp)
}

// CreateCommunityWithBodyWithResponse request with arbitrary body returning *CreateCommunityResp
func (c *ClientWithResponses) CreateCommunityWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateCommunityResp, error) {
	rsp, err := c.CreateCommunityWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateCommunityResp(rsp)
}

func (c *ClientWithResponses) CreateCommunityWithResponse(ctx context.Context, body CreateCommunityJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateCommunityResp, error) {
	rsp, err := c.CreateCommunity(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateCommunityResp(rsp)
}

// EditCommunityWithBodyWithResponse request with arbitrary body returning *EditCommunityResp
func (c *ClientWithResponses) EditCommunityWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EditCommunityResp, error) {
	rsp, err := c.EditCommunityWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEditCommunityResp(rsp)
}

func (c *ClientWithResponses) EditCommunityWithResponse(ctx context.Context, body EditCommunityJSONRequestBody, reqEditors ...RequestEditorFn) (*EditCommunityResp, error) {
	rsp, err := c.EditCommunity(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEditCommunityResp(rsp)
}

// BanFromCommunityWithBodyWithResponse request with arbitrary body returning *BanFromCommunityResp
func (c *ClientWithResponses) BanFromCommunityWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BanFromCommunityResp, error) {
	rsp, err := c.BanFromCommunityWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBanFromCommunityResp(rsp)
}

func (c *ClientWithResponses) BanFromCommunityWithResponse(ctx context.Context, body BanFromCommunityJSONRequestBody, reqEditors ...RequestEditorFn) (*BanFromCommunityResp, error) {
	rsp, err := c.BanFromCommunity(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBanFromCommunityResp(rsp)
}

// DeleteCommunityBannerWithResponse request returning *DeleteCommunityBannerResp
func (c *ClientWithResponses) DeleteCommunityBannerWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*DeleteCommunityBannerResp, error) {
	rsp, err := c.DeleteCommunityBanner(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteCommunityBannerResp(rsp)
}

// UploadCommunityBannerWithBodyWithResponse request with arbitrary body returning *UploadCommunityBannerResp
func (c *ClientWithResponses) UploadCommunityBannerWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UploadCommunityBannerResp, error) {
	rsp, err := c.UploadCommunityBannerWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUploadCommunityBannerResp(rsp)
}

// DeleteCommunityWithBodyWithResponse request with arbitrary body returning *DeleteCommunityResp
func (c *ClientWithResponses) DeleteCommunityWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteCommunityResp, error) {
	rsp, err := c.DeleteCommunityWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteCommunityResp(rsp)
}

func (c *ClientWithResponses) DeleteCommunityWithResponse(ctx context.Context, body DeleteCommunityJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteCommunityResp, error) {
	rsp, err := c.DeleteCommunity(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteCommunityResp(rsp)
}

// FollowCommunityWithBodyWithResponse request with arbitrary body returning *FollowCommunityResp
func (c *ClientWithResponses) FollowCommunityWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FollowCommunityResp, error) {
	rsp, err := c.FollowCommunityWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFollowCommunityResp(rsp)
}

func (c *ClientWithResponses) FollowCommunityWithResponse(ctx context.Context, body FollowCommunityJSONRequestBody, reqEditors ...RequestEditorFn) (*FollowCommunityResp, error) {
	rsp, err := c.FollowCommunity(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFollowCommunityResp(rsp)
}

// HideCommunityWithBodyWithResponse request with arbitrary body returning *HideCommunityResp
func (c *ClientWithResponses) HideCommunityWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*HideCommunityResp, error) {
	rsp, err := c.HideCommunityWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseHideCommunityResp(rsp)
}

func (c *ClientWithResponses) HideCommunityWithResponse(ctx context.Context, body HideCommunityJSONRequestBody, reqEditors ...RequestEditorFn) (*HideCommunityResp, error) {
	rsp, err := c.HideCommunity(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseHideCommunityResp(rsp)
}

// DeleteCommunityIconWithResponse request returning *DeleteCommunityIconResp
func (c *ClientWithResponses) DeleteCommunityIconWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*DeleteCommunityIconResp, error) {
	rsp, err := c.DeleteCommunityIcon(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteCommunityIconResp(rsp)
}

// UploadCommunityIconWithBodyWithResponse request with arbitrary body returning *UploadCommunityIconResp
func (c *ClientWithResponses) UploadCommunityIconWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UploadCommunityIconResp, error) {
	rsp, err := c.UploadCommunityIconWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUploadCommunityIconResp(rsp)
}

// ListCommunitiesWithResponse request returning *ListCommunitiesResp
func (c *ClientWithResponses) ListCommunitiesWithResponse(ctx context.Context, params *ListCommunitiesParams, reqEditors ...RequestEditorFn) (*ListCommunitiesResp, error) {
	rsp, err := c.ListCommunities(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListCommunitiesResp(rsp)
}

// AddModToCommunityWithBodyWithResponse request with arbitrary body returning *AddModToCommunityResp
func (c *ClientWithResponses) AddModToCommunityWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddModToCommunityResp, error) {
	rsp, err := c.AddModToCommunityWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddModToCommunityResp(rsp)
}

func (c *ClientWithResponses) AddModToCommunityWithResponse(ctx context.Context, body AddModToCommunityJSONRequestBody, reqEditors ...RequestEditorFn) (*AddModToCommunityResp, error) {
	rsp, err := c.AddModToCommunity(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddModToCommunityResp(rsp)
}

// ApproveCommunityPendingFollowWithBodyWithResponse request with arbitrary body returning *ApproveCommunityPendingFollowResp
func (c *ClientWithResponses) ApproveCommunityPendingFollowWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ApproveCommunityPendingFollowResp, error) {
	rsp, err := c.ApproveCommunityPendingFollowWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseApproveCommunityPendingFollowResp(rsp)
}

func (c *ClientWithResponses) ApproveCommunityPendingFollowWithResponse(ctx context.Context, body ApproveCommunityPendingFollowJSONRequestBody, reqEditors ...RequestEditorFn) (*ApproveCommunityPendingFollowResp, error) {
	rsp, err := c.ApproveCommunityPendingFollow(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseApproveCommunityPendingFollowResp(rsp)
}

// GetCommunityPendingFollowsCountWithResponse request returning *GetCommunityPendingFollowsCountResp
func (c *ClientWithResponses) GetCommunityPendingFollowsCountWithResponse(ctx context.Context, params *GetCommunityPendingFollowsCountParams, reqEditors ...RequestEditorFn) (*GetCommunityPendingFollowsCountResp, error) {
	rsp, err := c.GetCommunityPendingFollowsCount(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCommunityPendingFollowsCountResp(rsp)
}

// ListCommunityPendingFollowsWithResponse request returning *ListCommunityPendingFollowsResp
func (c *ClientWithResponses) ListCommunityPendingFollowsWithResponse(ctx context.Context, params *ListCommunityPendingFollowsParams, reqEditors ...RequestEditorFn) (*ListCommunityPendingFollowsResp, error) {
	rsp, err := c.ListCommunityPendingFollows(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListCommunityPendingFollowsResp(rsp)
}

// GetRandomCommunityWithResponse request returning *GetRandomCommunityResp
func (c *ClientWithResponses) GetRandomCommunityWithResponse(ctx context.Context, params *GetRandomCommunityParams, reqEditors ...RequestEditorFn) (*GetRandomCommunityResp, error) {
	rsp, err := c.GetRandomCommunity(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRandomCommunityResp(rsp)
}

// RemoveCommunityWithBodyWithResponse request with arbitrary body returning *RemoveCommunityResp
func (c *ClientWithResponses) RemoveCommunityWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RemoveCommunityResp, error) {
	rsp, err := c.RemoveCommunityWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveCommunityResp(rsp)
}

func (c *ClientWithResponses) RemoveCommunityWithResponse(ctx context.Context, body RemoveCommunityJSONRequestBody, reqEditors ...RequestEditorFn) (*RemoveCommunityResp, error) {
	rsp, err := c.RemoveCommunity(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveCommunityResp(rsp)
}

// TransferCommunityWithBodyWithResponse request with arbitrary body returning *TransferCommunityResp
func (c *ClientWithResponses) TransferCommunityWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TransferCommunityResp, error) {
	rsp, err := c.TransferCommunityWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTransferCommunityResp(rsp)
}

func (c *ClientWithResponses) TransferCommunityWithResponse(ctx context.Context, body TransferCommunityJSONRequestBody, reqEditors ...RequestEditorFn) (*TransferCommunityResp, error) {
	rsp, err := c.TransferCommunity(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTransferCommunityResp(rsp)
}

// CreateCustomEmojiWithBodyWithResponse request with arbitrary body returning *CreateCustomEmojiResp
func (c *ClientWithResponses) CreateCustomEmojiWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateCustomEmojiResp, error) {
	rsp, err := c.CreateCustomEmojiWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateCustomEmojiResp(rsp)
}

func (c *ClientWithResponses) CreateCustomEmojiWithResponse(ctx context.Context, body CreateCustomEmojiJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateCustomEmojiResp, error) {
	rsp, err := c.CreateCustomEmoji(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateCustomEmojiResp(rsp)
}

// EditCustomEmojiWithBodyWithResponse request with arbitrary body returning *EditCustomEmojiResp
func (c *ClientWithResponses) EditCustomEmojiWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EditCustomEmojiResp, error) {
	rsp, err := c.EditCustomEmojiWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEditCustomEmojiResp(rsp)
}

func (c *ClientWithResponses) EditCustomEmojiWithResponse(ctx context.Context, body EditCustomEmojiJSONRequestBody, reqEditors ...RequestEditorFn) (*EditCustomEmojiResp, error) {
	rsp, err := c.EditCustomEmoji(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEditCustomEmojiResp(rsp)
}

// DeleteCustomEmojiWithBodyWithResponse request with arbitrary body returning *DeleteCustomEmojiResp
func (c *ClientWithResponses) DeleteCustomEmojiWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteCustomEmojiResp, error) {
	rsp, err := c.DeleteCustomEmojiWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteCustomEmojiResp(rsp)
}

func (c *ClientWithResponses) DeleteCustomEmojiWithResponse(ctx context.Context, body DeleteCustomEmojiJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteCustomEmojiResp, error) {
	rsp, err := c.DeleteCustomEmoji(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteCustomEmojiResp(rsp)
}

// ListCustomEmojisWithResponse request returning *ListCustomEmojisResp
func (c *ClientWithResponses) ListCustomEmojisWithResponse(ctx context.Context, params *ListCustomEmojisParams, reqEditors ...RequestEditorFn) (*ListCustomEmojisResp, error) {
	rsp, err := c.ListCustomEmojis(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListCustomEmojisResp(rsp)
}

// GetFederatedInstancesWithResponse request returning *GetFederatedInstancesResp
func (c *ClientWithResponses) GetFederatedInstancesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetFederatedInstancesResp, error) {
	rsp, err := c.GetFederatedInstances(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFederatedInstancesResp(rsp)
}

// DeleteImageWithResponse request returning *DeleteImageResp
func (c *ClientWithResponses) DeleteImageWithResponse(ctx context.Context, params *DeleteImageParams, reqEditors ...RequestEditorFn) (*DeleteImageResp, error) {
	rsp, err := c.DeleteImage(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteImageResp(rsp)
}

// UploadImageWithBodyWithResponse request with arbitrary body returning *UploadImageResp
func (c *ClientWithResponses) UploadImageWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UploadImageResp, error) {
	rsp, err := c.UploadImageWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUploadImageResp(rsp)
}

// ImageHealthWithResponse request returning *ImageHealthResp
func (c *ClientWithResponses) ImageHealthWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ImageHealthResp, error) {
	rsp, err := c.ImageHealth(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseImageHealthResp(rsp)
}

// GetModlogWithResponse request returning *GetModlogResp
func (c *ClientWithResponses) GetModlogWithResponse(ctx context.Context, params *GetModlogParams, reqEditors ...RequestEditorFn) (*GetModlogResp, error) {
	rsp, err := c.GetModlog(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetModlogResp(rsp)
}

// AuthenticateWithOAuthWithBodyWithResponse request with arbitrary body returning *AuthenticateWithOAuthResp
func (c *ClientWithResponses) AuthenticateWithOAuthWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AuthenticateWithOAuthResp, error) {
	rsp, err := c.AuthenticateWithOAuthWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAuthenticateWithOAuthResp(rsp)
}

func (c *ClientWithResponses) AuthenticateWithOAuthWithResponse(ctx context.Context, body AuthenticateWithOAuthJSONRequestBody, reqEditors ...RequestEditorFn) (*AuthenticateWithOAuthResp, error) {
	rsp, err := c.AuthenticateWithOAuth(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAuthenticateWithOAuthResp(rsp)
}

// CreateOAuthProviderWithBodyWithResponse request with arbitrary body returning *CreateOAuthProviderResp
func (c *ClientWithResponses) CreateOAuthProviderWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateOAuthProviderResp, error) {
	rsp, err := c.CreateOAuthProviderWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateOAuthProviderResp(rsp)
}

func (c *ClientWithResponses) CreateOAuthProviderWithResponse(ctx context.Context, body CreateOAuthProviderJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateOAuthProviderResp, error) {
	rsp, err := c.CreateOAuthProvider(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateOAuthProviderResp(rsp)
}

// EditOAuthProviderWithBodyWithResponse request with arbitrary body returning *EditOAuthProviderResp
func (c *ClientWithResponses) EditOAuthProviderWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EditOAuthProviderResp, error) {
	rsp, err := c.EditOAuthProviderWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEditOAuthProviderResp(rsp)
}

func (c *ClientWithResponses) EditOAuthProviderWithResponse(ctx context.Context, body EditOAuthProviderJSONRequestBody, reqEditors ...RequestEditorFn) (*EditOAuthProviderResp, error) {
	rsp, err := c.EditOAuthProvider(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEditOAuthProviderResp(rsp)
}

// DeleteOAuthProviderWithBodyWithResponse request with arbitrary body returning *DeleteOAuthProviderResp
func (c *ClientWithResponses) DeleteOAuthProviderWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteOAuthProviderResp, error) {
	rsp, err := c.DeleteOAuthProviderWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteOAuthProviderResp(rsp)
}

func (c *ClientWithResponses) DeleteOAuthProviderWithResponse(ctx context.Context, body DeleteOAuthProviderJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteOAuthProviderResp, error) {
	rsp, err := c.DeleteOAuthProvider(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteOAuthProviderResp(rsp)
}

// GetPersonDetailsWithResponse request returning *GetPersonDetailsResp
func (c *ClientWithResponses) GetPersonDetailsWithResponse(ctx context.Context, params *GetPersonDetailsParams, reqEditors ...RequestEditorFn) (*GetPersonDetailsResp, error) {
	rsp, err := c.GetPersonDetails(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPersonDetailsResp(rsp)
}

// ListPersonContentWithResponse request returning *ListPersonContentResp
func (c *ClientWithResponses) ListPersonContentWithResponse(ctx context.Context, params *ListPersonContentParams, reqEditors ...RequestEditorFn) (*ListPersonContentResp, error) {
	rsp, err := c.ListPersonContent(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListPersonContentResp(rsp)
}

// GetPostWithResponse request returning *GetPostResp
func (c *ClientWithResponses) GetPostWithResponse(ctx context.Context, params *GetPostParams, reqEditors ...RequestEditorFn) (*GetPostResp, error) {
	rsp, err := c.GetPost(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPostResp(rsp)
}

// CreatePostWithBodyWithResponse request with arbitrary body returning *CreatePostResp
func (c *ClientWithResponses) CreatePostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePostResp, error) {
	rsp, err := c.CreatePostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePostResp(rsp)
}

func (c *ClientWithResponses) CreatePostWithResponse(ctx context.Context, body CreatePostJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePostResp, error) {
	rsp, err := c.CreatePost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePostResp(rsp)
}

// EditPostWithBodyWithResponse request with arbitrary body returning *EditPostResp
func (c *ClientWithResponses) EditPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EditPostResp, error) {
	rsp, err := c.EditPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEditPostResp(rsp)
}

func (c *ClientWithResponses) EditPostWithResponse(ctx context.Context, body EditPostJSONRequestBody, reqEditors ...RequestEditorFn) (*EditPostResp, error) {
	rsp, err := c.EditPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEditPostResp(rsp)
}

// DeletePostWithBodyWithResponse request with arbitrary body returning *DeletePostResp
func (c *ClientWithResponses) DeletePostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeletePostResp, error) {
	rsp, err := c.DeletePostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeletePostResp(rsp)
}

func (c *ClientWithResponses) DeletePostWithResponse(ctx context.Context, body DeletePostJSONRequestBody, reqEditors ...RequestEditorFn) (*DeletePostResp, error) {
	rsp, err := c.DeletePost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeletePostResp(rsp)
}

// FeaturePostWithBodyWithResponse request with arbitrary body returning *FeaturePostResp
func (c *ClientWithResponses) FeaturePostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FeaturePostResp, error) {
	rsp, err := c.FeaturePostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFeaturePostResp(rsp)
}

func (c *ClientWithResponses) FeaturePostWithResponse(ctx context.Context, body FeaturePostJSONRequestBody, reqEditors ...RequestEditorFn) (*FeaturePostResp, error) {
	rsp, err := c.FeaturePost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFeaturePostResp(rsp)
}

// HidePostWithBodyWithResponse request with arbitrary body returning *HidePostResp
func (c *ClientWithResponses) HidePostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*HidePostResp, error) {
	rsp, err := c.HidePostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseHidePostResp(rsp)
}

func (c *ClientWithResponses) HidePostWithResponse(ctx context.Context, body HidePostJSONRequestBody, reqEditors ...RequestEditorFn) (*HidePostResp, error) {
	rsp, err := c.HidePost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseHidePostResp(rsp)
}

// LikePostWithBodyWithResponse request with arbitrary body returning *LikePostResp
func (c *ClientWithResponses) LikePostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LikePostResp, error) {
	rsp, err := c.LikePostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLikePostResp(rsp)
}

func (c *ClientWithResponses) LikePostWithResponse(ctx context.Context, body LikePostJSONRequestBody, reqEditors ...RequestEditorFn) (*LikePostResp, error) {
	rsp, err := c.LikePost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLikePostResp(rsp)
}

// ListPostLikesWithResponse request returning *ListPostLikesResp
func (c *ClientWithResponses) ListPostLikesWithResponse(ctx context.Context, params *ListPostLikesParams, reqEditors ...RequestEditorFn) (*ListPostLikesResp, error) {
	rsp, err := c.ListPostLikes(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListPostLikesResp(rsp)
}

// GetPostsWithResponse request returning *GetPostsResp
func (c *ClientWithResponses) GetPostsWithResponse(ctx context.Context, params *GetPostsParams, reqEditors ...RequestEditorFn) (*GetPostsResp, error) {
	rsp, err := c.GetPosts(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPostsResp(rsp)
}

// LockPostWithBodyWithResponse request with arbitrary body returning *LockPostResp
func (c *ClientWithResponses) LockPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LockPostResp, error) {
	rsp, err := c.LockPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLockPostResp(rsp)
}

func (c *ClientWithResponses) LockPostWithResponse(ctx context.Context, body LockPostJSONRequestBody, reqEditors ...RequestEditorFn) (*LockPostResp, error) {
	rsp, err := c.LockPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLockPostResp(rsp)
}

// MarkPostAsReadWithBodyWithResponse request with arbitrary body returning *MarkPostAsReadResp
func (c *ClientWithResponses) MarkPostAsReadWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MarkPostAsReadResp, error) {
	rsp, err := c.MarkPostAsReadWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMarkPostAsReadResp(rsp)
}

func (c *ClientWithResponses) MarkPostAsReadWithResponse(ctx context.Context, body MarkPostAsReadJSONRequestBody, reqEditors ...RequestEditorFn) (*MarkPostAsReadResp, error) {
	rsp, err := c.MarkPostAsRead(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMarkPostAsReadResp(rsp)
}

// MarkManyPostAsReadWithBodyWithResponse request with arbitrary body returning *MarkManyPostAsReadResp
func (c *ClientWithResponses) MarkManyPostAsReadWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MarkManyPostAsReadResp, error) {
	rsp, err := c.MarkManyPostAsReadWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMarkManyPostAsReadResp(rsp)
}

func (c *ClientWithResponses) MarkManyPostAsReadWithResponse(ctx context.Context, body MarkManyPostAsReadJSONRequestBody, reqEditors ...RequestEditorFn) (*MarkManyPostAsReadResp, error) {
	rsp, err := c.MarkManyPostAsRead(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMarkManyPostAsReadResp(rsp)
}

// RemovePostWithBodyWithResponse request with arbitrary body returning *RemovePostResp
func (c *ClientWithResponses) RemovePostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RemovePostResp, error) {
	rsp, err := c.RemovePostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemovePostResp(rsp)
}

func (c *ClientWithResponses) RemovePostWithResponse(ctx context.Context, body RemovePostJSONRequestBody, reqEditors ...RequestEditorFn) (*RemovePostResp, error) {
	rsp, err := c.RemovePost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemovePostResp(rsp)
}

// CreatePostReportWithBodyWithResponse request with arbitrary body returning *CreatePostReportResp
func (c *ClientWithResponses) CreatePostReportWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePostReportResp, error) {
	rsp, err := c.CreatePostReportWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePostReportResp(rsp)
}

func (c *ClientWithResponses) CreatePostReportWithResponse(ctx context.Context, body CreatePostReportJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePostReportResp, error) {
	rsp, err := c.CreatePostReport(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePostReportResp(rsp)
}

// ResolvePostReportWithBodyWithResponse request with arbitrary body returning *ResolvePostReportResp
func (c *ClientWithResponses) ResolvePostReportWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ResolvePostReportResp, error) {
	rsp, err := c.ResolvePostReportWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseResolvePostReportResp(rsp)
}

func (c *ClientWithResponses) ResolvePostReportWithResponse(ctx context.Context, body ResolvePostReportJSONRequestBody, reqEditors ...RequestEditorFn) (*ResolvePostReportResp, error) {
	rsp, err := c.ResolvePostReport(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseResolvePostReportResp(rsp)
}

// SavePostWithBodyWithResponse request with arbitrary body returning *SavePostResp
func (c *ClientWithResponses) SavePostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SavePostResp, error) {
	rsp, err := c.SavePostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSavePostResp(rsp)
}

func (c *ClientWithResponses) SavePostWithResponse(ctx context.Context, body SavePostJSONRequestBody, reqEditors ...RequestEditorFn) (*SavePostResp, error) {
	rsp, err := c.SavePost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSavePostResp(rsp)
}

// GetSiteMetadataWithResponse request returning *GetSiteMetadataResp
func (c *ClientWithResponses) GetSiteMetadataWithResponse(ctx context.Context, params *GetSiteMetadataParams, reqEditors ...RequestEditorFn) (*GetSiteMetadataResp, error) {
	rsp, err := c.GetSiteMetadata(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSiteMetadataResp(rsp)
}

// CreatePrivateMessageWithBodyWithResponse request with arbitrary body returning *CreatePrivateMessageResp
func (c *ClientWithResponses) CreatePrivateMessageWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePrivateMessageResp, error) {
	rsp, err := c.CreatePrivateMessageWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePrivateMessageResp(rsp)
}

func (c *ClientWithResponses) CreatePrivateMessageWithResponse(ctx context.Context, body CreatePrivateMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePrivateMessageResp, error) {
	rsp, err := c.CreatePrivateMessage(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePrivateMessageResp(rsp)
}

// EditPrivateMessageWithBodyWithResponse request with arbitrary body returning *EditPrivateMessageResp
func (c *ClientWithResponses) EditPrivateMessageWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EditPrivateMessageResp, error) {
	rsp, err := c.EditPrivateMessageWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEditPrivateMessageResp(rsp)
}

func (c *ClientWithResponses) EditPrivateMessageWithResponse(ctx context.Context, body EditPrivateMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*EditPrivateMessageResp, error) {
	rsp, err := c.EditPrivateMessage(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEditPrivateMessageResp(rsp)
}

// DeletePrivateMessageWithBodyWithResponse request with arbitrary body returning *DeletePrivateMessageResp
func (c *ClientWithResponses) DeletePrivateMessageWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeletePrivateMessageResp, error) {
	rsp, err := c.DeletePrivateMessageWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeletePrivateMessageResp(rsp)
}

func (c *ClientWithResponses) DeletePrivateMessageWithResponse(ctx context.Context, body DeletePrivateMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*DeletePrivateMessageResp, error) {
	rsp, err := c.DeletePrivateMessage(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeletePrivateMessageResp(rsp)
}

// MarkPrivateMessageAsReadWithBodyWithResponse request with arbitrary body returning *MarkPrivateMessageAsReadResp
func (c *ClientWithResponses) MarkPrivateMessageAsReadWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MarkPrivateMessageAsReadResp, error) {
	rsp, err := c.MarkPrivateMessageAsReadWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMarkPrivateMessageAsReadResp(rsp)
}

func (c *ClientWithResponses) MarkPrivateMessageAsReadWithResponse(ctx context.Context, body MarkPrivateMessageAsReadJSONRequestBody, reqEditors ...RequestEditorFn) (*MarkPrivateMessageAsReadResp, error) {
	rsp, err := c.MarkPrivateMessageAsRead(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMarkPrivateMessageAsReadResp(rsp)
}

// CreatePrivateMessageReportWithBodyWithResponse request with arbitrary body returning *CreatePrivateMessageReportResp
func (c *ClientWithResponses) CreatePrivateMessageReportWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePrivateMessageReportResp, error) {
	rsp, err := c.CreatePrivateMessageReportWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePrivateMessageReportResp(rsp)
}

func (c *ClientWithResponses) CreatePrivateMessageReportWithResponse(ctx context.Context, body CreatePrivateMessageReportJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePrivateMessageReportResp, error) {
	rsp, err := c.CreatePrivateMessageReport(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePrivateMessageReportResp(rsp)
}

// ResolvePrivateMessageReportWithBodyWithResponse request with arbitrary body returning *ResolvePrivateMessageReportResp
func (c *ClientWithResponses) ResolvePrivateMessageReportWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ResolvePrivateMessageReportResp, error) {
	rsp, err := c.ResolvePrivateMessageReportWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseResolvePrivateMessageReportResp(rsp)
}

func (c *ClientWithResponses) ResolvePrivateMessageReportWithResponse(ctx context.Context, body ResolvePrivateMessageReportJSONRequestBody, reqEditors ...RequestEditorFn) (*ResolvePrivateMessageReportResp, error) {
	rsp, err := c.ResolvePrivateMessageReport(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseResolvePrivateMessageReportResp(rsp)
}

// ListReportsWithResponse request returning *ListReportsResp
func (c *ClientWithResponses) ListReportsWithResponse(ctx context.Context, params *ListReportsParams, reqEditors ...RequestEditorFn) (*ListReportsResp, error) {
	rsp, err := c.ListReports(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListReportsResp(rsp)
}

// ResolveObjectWithResponse request returning *ResolveObjectResp
func (c *ClientWithResponses) ResolveObjectWithResponse(ctx context.Context, params *ResolveObjectParams, reqEditors ...RequestEditorFn) (*ResolveObjectResp, error) {
	rsp, err := c.ResolveObject(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseResolveObjectResp(rsp)
}

// SearchWithResponse request returning *SearchResp
func (c *ClientWithResponses) SearchWithResponse(ctx context.Context, params *SearchParams, reqEditors ...RequestEditorFn) (*SearchResp, error) {
	rsp, err := c.Search(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchResp(rsp)
}

// GetSiteWithResponse request returning *GetSiteResp
func (c *ClientWithResponses) GetSiteWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSiteResp, error) {
	rsp, err := c.GetSite(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSiteResp(rsp)
}

// CreateSiteWithBodyWithResponse request with arbitrary body returning *CreateSiteResp
func (c *ClientWithResponses) CreateSiteWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSiteResp, error) {
	rsp, err := c.CreateSiteWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSiteResp(rsp)
}

func (c *ClientWithResponses) CreateSiteWithResponse(ctx context.Context, body CreateSiteJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSiteResp, error) {
	rsp, err := c.CreateSite(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSiteResp(rsp)
}

// EditSiteWithBodyWithResponse request with arbitrary body returning *EditSiteResp
func (c *ClientWithResponses) EditSiteWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EditSiteResp, error) {
	rsp, err := c.EditSiteWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEditSiteResp(rsp)
}

func (c *ClientWithResponses) EditSiteWithResponse(ctx context.Context, body EditSiteJSONRequestBody, reqEditors ...RequestEditorFn) (*EditSiteResp, error) {
	rsp, err := c.EditSite(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEditSiteResp(rsp)
}

// DeleteSiteBannerWithResponse request returning *DeleteSiteBannerResp
func (c *ClientWithResponses) DeleteSiteBannerWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*DeleteSiteBannerResp, error) {
	rsp, err := c.DeleteSiteBanner(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSiteBannerResp(rsp)
}

// UploadSiteBannerWithBodyWithResponse request with arbitrary body returning *UploadSiteBannerResp
func (c *ClientWithResponses) UploadSiteBannerWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UploadSiteBannerResp, error) {
	rsp, err := c.UploadSiteBannerWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUploadSiteBannerResp(rsp)
}

// DeleteSiteIconWithResponse request returning *DeleteSiteIconResp
func (c *ClientWithResponses) DeleteSiteIconWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*DeleteSiteIconResp, error) {
	rsp, err := c.DeleteSiteIcon(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSiteIconResp(rsp)
}

// UploadSiteIconWithBodyWithResponse request with arbitrary body returning *UploadSiteIconResp
func (c *ClientWithResponses) UploadSiteIconWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UploadSiteIconResp, error) {
	rsp, err := c.UploadSiteIconWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUploadSiteIconResp(rsp)
}

// ParseGetMyUserResp parses an HTTP response from a GetMyUserWithResponse call
func ParseGetMyUserResp(rsp *http.Response) (*GetMyUserResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMyUserResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MyUserInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseChangePasswordResp parses an HTTP response from a ChangePasswordWithResponse call
func ParseChangePasswordResp(rsp *http.Response) (*ChangePasswordResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ChangePasswordResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LoginResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetCaptchaResp parses an HTTP response from a GetCaptchaWithResponse call
func ParseGetCaptchaResp(rsp *http.Response) (*GetCaptchaResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCaptchaResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetCaptchaResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseLoginResp parses an HTTP response from a LoginWithResponse call
func ParseLoginResp(rsp *http.Response) (*LoginResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LoginResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LoginResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseLogoutResp parses an HTTP response from a LogoutWithResponse call
func ParseLogoutResp(rsp *http.Response) (*LogoutResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LogoutResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SuccessResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePasswordChangeAfterResetResp parses an HTTP response from a PasswordChangeAfterResetWithResponse call
func ParsePasswordChangeAfterResetResp(rsp *http.Response) (*PasswordChangeAfterResetResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PasswordChangeAfterResetResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SuccessResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePasswordResetResp parses an HTTP response from a PasswordResetWithResponse call
func ParsePasswordResetResp(rsp *http.Response) (*PasswordResetResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PasswordResetResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SuccessResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseRegisterResp parses an HTTP response from a RegisterWithResponse call
func ParseRegisterResp(rsp *http.Response) (*RegisterResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RegisterResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LoginResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseResendVerificationEmailResp parses an HTTP response from a ResendVerificationEmailWithResponse call
func ParseResendVerificationEmailResp(rsp *http.Response) (*ResendVerificationEmailResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ResendVerificationEmailResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SuccessResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListPersonSavedResp parses an HTTP response from a ListPersonSavedWithResponse call
func ParseListPersonSavedResp(rsp *http.Response) (*ListPersonSavedResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListPersonSavedResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListPersonSavedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGenerateTotpSecretResp parses an HTTP response from a GenerateTotpSecretWithResponse call
func ParseGenerateTotpSecretResp(rsp *http.Response) (*GenerateTotpSecretResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GenerateTotpSecretResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GenerateTotpSecretResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateTotpResp parses an HTTP response from a UpdateTotpWithResponse call
func ParseUpdateTotpResp(rsp *http.Response) (*UpdateTotpResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateTotpResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UpdateTotpResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseVerifyEmailResp parses an HTTP response from a VerifyEmailWithResponse call
func ParseVerifyEmailResp(rsp *http.Response) (*VerifyEmailResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &VerifyEmailResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SuccessResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteUserAvatarResp parses an HTTP response from a DeleteUserAvatarWithResponse call
func ParseDeleteUserAvatarResp(rsp *http.Response) (*DeleteUserAvatarResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteUserAvatarResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SuccessResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUploadUserAvatarResp parses an HTTP response from a UploadUserAvatarWithResponse call
func ParseUploadUserAvatarResp(rsp *http.Response) (*UploadUserAvatarResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UploadUserAvatarResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SuccessResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteUserBannerResp parses an HTTP response from a DeleteUserBannerWithResponse call
func ParseDeleteUserBannerResp(rsp *http.Response) (*DeleteUserBannerResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteUserBannerResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SuccessResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUploadUserBannerResp parses an HTTP response from a UploadUserBannerWithResponse call
func ParseUploadUserBannerResp(rsp *http.Response) (*UploadUserBannerResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UploadUserBannerResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SuccessResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseBlockCommunityResp parses an HTTP response from a BlockCommunityWithResponse call
func ParseBlockCommunityResp(rsp *http.Response) (*BlockCommunityResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BlockCommunityResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BlockCommunityResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUserBlockInstanceResp parses an HTTP response from a UserBlockInstanceWithResponse call
func ParseUserBlockInstanceResp(rsp *http.Response) (*UserBlockInstanceResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UserBlockInstanceResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SuccessResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseBlockPersonResp parses an HTTP response from a BlockPersonWithResponse call
func ParseBlockPersonResp(rsp *http.Response) (*BlockPersonResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BlockPersonResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BlockPersonResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteAccountResp parses an HTTP response from a DeleteAccountWithResponse call
func ParseDeleteAccountResp(rsp *http.Response) (*DeleteAccountResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteAccountResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SuccessResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListInboxResp parses an HTTP response from a ListInboxWithResponse call
func ParseListInboxResp(rsp *http.Response) (*ListInboxResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListInboxResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListInboxResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListLoginsResp parses an HTTP response from a ListLoginsWithResponse call
func ParseListLoginsResp(rsp *http.Response) (*ListLoginsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListLoginsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []LoginToken
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListMediaResp parses an HTTP response from a ListMediaWithResponse call
func ParseListMediaResp(rsp *http.Response) (*ListMediaResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListMediaResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListMediaResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseMarkAllNotificationsAsReadResp parses an HTTP response from a MarkAllNotificationsAsReadWithResponse call
func ParseMarkAllNotificationsAsReadResp(rsp *http.Response) (*MarkAllNotificationsAsReadResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MarkAllNotificationsAsReadResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SuccessResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseMarkCommentMentionAsReadResp parses an HTTP response from a MarkCommentMentionAsReadWithResponse call
func ParseMarkCommentMentionAsReadResp(rsp *http.Response) (*MarkCommentMentionAsReadResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MarkCommentMentionAsReadResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SuccessResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseMarkPostMentionAsReadResp parses an HTTP response from a MarkPostMentionAsReadWithResponse call
func ParseMarkPostMentionAsReadResp(rsp *http.Response) (*MarkPostMentionAsReadResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MarkPostMentionAsReadResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SuccessResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetReportCountResp parses an HTTP response from a GetReportCountWithResponse call
func ParseGetReportCountResp(rsp *http.Response) (*GetReportCountResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetReportCountResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetReportCountResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseExportSettingsResp parses an HTTP response from a ExportSettingsWithResponse call
func ParseExportSettingsResp(rsp *http.Response) (*ExportSettingsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExportSettingsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseImportSettingsResp parses an HTTP response from a ImportSettingsWithResponse call
func ParseImportSettingsResp(rsp *http.Response) (*ImportSettingsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ImportSettingsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SuccessResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSaveUserSettingsResp parses an HTTP response from a SaveUserSettingsWithResponse call
func ParseSaveUserSettingsResp(rsp *http.Response) (*SaveUserSettingsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SaveUserSettingsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SuccessResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetUnreadCountResp parses an HTTP response from a GetUnreadCountWithResponse call
func ParseGetUnreadCountResp(rsp *http.Response) (*GetUnreadCountResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUnreadCountResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetUnreadCountResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseValidateAuthResp parses an HTTP response from a ValidateAuthWithResponse call
func ParseValidateAuthResp(rsp *http.Response) (*ValidateAuthResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ValidateAuthResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SuccessResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAddAdminResp parses an HTTP response from a AddAdminWithResponse call
func ParseAddAdminResp(rsp *http.Response) (*AddAdminResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddAdminResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AddAdminResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseBanPersonResp parses an HTTP response from a BanPersonWithResponse call
func ParseBanPersonResp(rsp *http.Response) (*BanPersonResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BanPersonResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BanPersonResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetBannedPersonsResp parses an HTTP response from a GetBannedPersonsWithResponse call
func ParseGetBannedPersonsResp(rsp *http.Response) (*GetBannedPersonsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBannedPersonsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BannedPersonsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAdminAllowInstanceResp parses an HTTP response from a AdminAllowInstanceWithResponse call
func ParseAdminAllowInstanceResp(rsp *http.Response) (*AdminAllowInstanceResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AdminAllowInstanceResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SuccessResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAdminBlockInstanceResp parses an HTTP response from a AdminBlockInstanceWithResponse call
func ParseAdminBlockInstanceResp(rsp *http.Response) (*AdminBlockInstanceResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AdminBlockInstanceResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SuccessResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseLeaveAdminResp parses an HTTP response from a LeaveAdminWithResponse call
func ParseLeaveAdminResp(rsp *http.Response) (*LeaveAdminResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LeaveAdminResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetSiteResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListAllMediaResp parses an HTTP response from a ListAllMediaWithResponse call
func ParseListAllMediaResp(rsp *http.Response) (*ListAllMediaResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAllMediaResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListMediaResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePurgeCommentResp parses an HTTP response from a PurgeCommentWithResponse call
func ParsePurgeCommentResp(rsp *http.Response) (*PurgeCommentResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PurgeCommentResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SuccessResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePurgeCommunityResp parses an HTTP response from a PurgeCommunityWithResponse call
func ParsePurgeCommunityResp(rsp *http.Response) (*PurgeCommunityResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PurgeCommunityResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SuccessResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePurgePersonResp parses an HTTP response from a PurgePersonWithResponse call
func ParsePurgePersonResp(rsp *http.Response) (*PurgePersonResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PurgePersonResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SuccessResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePurgePostResp parses an HTTP response from a PurgePostWithResponse call
func ParsePurgePostResp(rsp *http.Response) (*PurgePostResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PurgePostResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SuccessResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetRegistrationApplicationResp parses an HTTP response from a GetRegistrationApplicationWithResponse call
func ParseGetRegistrationApplicationResp(rsp *http.Response) (*GetRegistrationApplicationResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRegistrationApplicationResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RegistrationApplicationResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseApproveRegistrationApplicationResp parses an HTTP response from a ApproveRegistrationApplicationWithResponse call
func ParseApproveRegistrationApplicationResp(rsp *http.Response) (*ApproveRegistrationApplicationResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ApproveRegistrationApplicationResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RegistrationApplicationResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetUnreadRegistrationApplicationCountResp parses an HTTP response from a GetUnreadRegistrationApplicationCountWithResponse call
func ParseGetUnreadRegistrationApplicationCountResp(rsp *http.Response) (*GetUnreadRegistrationApplicationCountResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUnreadRegistrationApplicationCountResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetUnreadRegistrationApplicationCountResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListRegistrationApplicationsResp parses an HTTP response from a ListRegistrationApplicationsWithResponse call
func ParseListRegistrationApplicationsResp(rsp *http.Response) (*ListRegistrationApplicationsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListRegistrationApplicationsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListRegistrationApplicationsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateTaglineResp parses an HTTP response from a CreateTaglineWithResponse call
func ParseCreateTaglineResp(rsp *http.Response) (*CreateTaglineResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateTaglineResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TaglineResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseEditTaglineResp parses an HTTP response from a EditTaglineWithResponse call
func ParseEditTaglineResp(rsp *http.Response) (*EditTaglineResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EditTaglineResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TaglineResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteTaglineResp parses an HTTP response from a DeleteTaglineWithResponse call
func ParseDeleteTaglineResp(rsp *http.Response) (*DeleteTaglineResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteTaglineResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SuccessResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListTaglinesResp parses an HTTP response from a ListTaglinesWithResponse call
func ParseListTaglinesResp(rsp *http.Response) (*ListTaglinesResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListTaglinesResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListTaglinesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetCommentResp parses an HTTP response from a GetCommentWithResponse call
func ParseGetCommentResp(rsp *http.Response) (*GetCommentResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCommentResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CommentResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateCommentResp parses an HTTP response from a CreateCommentWithResponse call
func ParseCreateCommentResp(rsp *http.Response) (*CreateCommentResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateCommentResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CommentResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseEditCommentResp parses an HTTP response from a EditCommentWithResponse call
func ParseEditCommentResp(rsp *http.Response) (*EditCommentResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EditCommentResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CommentResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteCommentResp parses an HTTP response from a DeleteCommentWithResponse call
func ParseDeleteCommentResp(rsp *http.Response) (*DeleteCommentResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteCommentResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CommentResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDistinguishCommentResp parses an HTTP response from a DistinguishCommentWithResponse call
func ParseDistinguishCommentResp(rsp *http.Response) (*DistinguishCommentResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DistinguishCommentResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CommentResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseLikeCommentResp parses an HTTP response from a LikeCommentWithResponse call
func ParseLikeCommentResp(rsp *http.Response) (*LikeCommentResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LikeCommentResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CommentResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListCommentLikesResp parses an HTTP response from a ListCommentLikesWithResponse call
func ParseListCommentLikesResp(rsp *http.Response) (*ListCommentLikesResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListCommentLikesResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListCommentLikesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetCommentsResp parses an HTTP response from a GetCommentsWithResponse call
func ParseGetCommentsResp(rsp *http.Response) (*GetCommentsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCommentsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetCommentsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetCommentsSlimResp parses an HTTP response from a GetCommentsSlimWithResponse call
func ParseGetCommentsSlimResp(rsp *http.Response) (*GetCommentsSlimResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCommentsSlimResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetCommentsSlimResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseMarkCommentReplyAsReadResp parses an HTTP response from a MarkCommentReplyAsReadWithResponse call
func ParseMarkCommentReplyAsReadResp(rsp *http.Response) (*MarkCommentReplyAsReadResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MarkCommentReplyAsReadResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SuccessResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseRemoveCommentResp parses an HTTP response from a RemoveCommentWithResponse call
func ParseRemoveCommentResp(rsp *http.Response) (*RemoveCommentResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveCommentResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CommentResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateCommentReportResp parses an HTTP response from a CreateCommentReportWithResponse call
func ParseCreateCommentReportResp(rsp *http.Response) (*CreateCommentReportResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateCommentReportResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CommentReportResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseResolveCommentReportResp parses an HTTP response from a ResolveCommentReportWithResponse call
func ParseResolveCommentReportResp(rsp *http.Response) (*ResolveCommentReportResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ResolveCommentReportResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CommentReportResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSaveCommentResp parses an HTTP response from a SaveCommentWithResponse call
func ParseSaveCommentResp(rsp *http.Response) (*SaveCommentResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SaveCommentResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CommentResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetCommunityResp parses an HTTP response from a GetCommunityWithResponse call
func ParseGetCommunityResp(rsp *http.Response) (*GetCommunityResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCommunityResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetCommunityResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateCommunityResp parses an HTTP response from a CreateCommunityWithResponse call
func ParseCreateCommunityResp(rsp *http.Response) (*CreateCommunityResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateCommunityResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CommunityResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseEditCommunityResp parses an HTTP response from a EditCommunityWithResponse call
func ParseEditCommunityResp(rsp *http.Response) (*EditCommunityResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EditCommunityResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CommunityResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseBanFromCommunityResp parses an HTTP response from a BanFromCommunityWithResponse call
func ParseBanFromCommunityResp(rsp *http.Response) (*BanFromCommunityResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BanFromCommunityResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BanFromCommunityResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteCommunityBannerResp parses an HTTP response from a DeleteCommunityBannerWithResponse call
func ParseDeleteCommunityBannerResp(rsp *http.Response) (*DeleteCommunityBannerResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteCommunityBannerResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SuccessResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUploadCommunityBannerResp parses an HTTP response from a UploadCommunityBannerWithResponse call
func ParseUploadCommunityBannerResp(rsp *http.Response) (*UploadCommunityBannerResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UploadCommunityBannerResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SuccessResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteCommunityResp parses an HTTP response from a DeleteCommunityWithResponse call
func ParseDeleteCommunityResp(rsp *http.Response) (*DeleteCommunityResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteCommunityResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CommunityResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseFollowCommunityResp parses an HTTP response from a FollowCommunityWithResponse call
func ParseFollowCommunityResp(rsp *http.Response) (*FollowCommunityResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FollowCommunityResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CommunityResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseHideCommunityResp parses an HTTP response from a HideCommunityWithResponse call
func ParseHideCommunityResp(rsp *http.Response) (*HideCommunityResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &HideCommunityResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SuccessResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteCommunityIconResp parses an HTTP response from a DeleteCommunityIconWithResponse call
func ParseDeleteCommunityIconResp(rsp *http.Response) (*DeleteCommunityIconResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteCommunityIconResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SuccessResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUploadCommunityIconResp parses an HTTP response from a UploadCommunityIconWithResponse call
func ParseUploadCommunityIconResp(rsp *http.Response) (*UploadCommunityIconResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UploadCommunityIconResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SuccessResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListCommunitiesResp parses an HTTP response from a ListCommunitiesWithResponse call
func ParseListCommunitiesResp(rsp *http.Response) (*ListCommunitiesResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListCommunitiesResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListCommunitiesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAddModToCommunityResp parses an HTTP response from a AddModToCommunityWithResponse call
func ParseAddModToCommunityResp(rsp *http.Response) (*AddModToCommunityResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddModToCommunityResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AddModToCommunityResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseApproveCommunityPendingFollowResp parses an HTTP response from a ApproveCommunityPendingFollowWithResponse call
func ParseApproveCommunityPendingFollowResp(rsp *http.Response) (*ApproveCommunityPendingFollowResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ApproveCommunityPendingFollowResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SuccessResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetCommunityPendingFollowsCountResp parses an HTTP response from a GetCommunityPendingFollowsCountWithResponse call
func ParseGetCommunityPendingFollowsCountResp(rsp *http.Response) (*GetCommunityPendingFollowsCountResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCommunityPendingFollowsCountResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetCommunityPendingFollowsCountResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListCommunityPendingFollowsResp parses an HTTP response from a ListCommunityPendingFollowsWithResponse call
func ParseListCommunityPendingFollowsResp(rsp *http.Response) (*ListCommunityPendingFollowsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListCommunityPendingFollowsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListCommunityPendingFollowsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetRandomCommunityResp parses an HTTP response from a GetRandomCommunityWithResponse call
func ParseGetRandomCommunityResp(rsp *http.Response) (*GetRandomCommunityResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRandomCommunityResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CommunityResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseRemoveCommunityResp parses an HTTP response from a RemoveCommunityWithResponse call
func ParseRemoveCommunityResp(rsp *http.Response) (*RemoveCommunityResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveCommunityResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CommunityResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTransferCommunityResp parses an HTTP response from a TransferCommunityWithResponse call
func ParseTransferCommunityResp(rsp *http.Response) (*TransferCommunityResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TransferCommunityResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetCommunityResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateCustomEmojiResp parses an HTTP response from a CreateCustomEmojiWithResponse call
func ParseCreateCustomEmojiResp(rsp *http.Response) (*CreateCustomEmojiResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateCustomEmojiResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CustomEmojiResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseEditCustomEmojiResp parses an HTTP response from a EditCustomEmojiWithResponse call
func ParseEditCustomEmojiResp(rsp *http.Response) (*EditCustomEmojiResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EditCustomEmojiResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CustomEmojiResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteCustomEmojiResp parses an HTTP response from a DeleteCustomEmojiWithResponse call
func ParseDeleteCustomEmojiResp(rsp *http.Response) (*DeleteCustomEmojiResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteCustomEmojiResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SuccessResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListCustomEmojisResp parses an HTTP response from a ListCustomEmojisWithResponse call
func ParseListCustomEmojisResp(rsp *http.Response) (*ListCustomEmojisResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListCustomEmojisResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListCustomEmojisResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetFederatedInstancesResp parses an HTTP response from a GetFederatedInstancesWithResponse call
func ParseGetFederatedInstancesResp(rsp *http.Response) (*GetFederatedInstancesResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFederatedInstancesResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetFederatedInstancesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteImageResp parses an HTTP response from a DeleteImageWithResponse call
func ParseDeleteImageResp(rsp *http.Response) (*DeleteImageResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteImageResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SuccessResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUploadImageResp parses an HTTP response from a UploadImageWithResponse call
func ParseUploadImageResp(rsp *http.Response) (*UploadImageResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UploadImageResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UploadImageResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseImageHealthResp parses an HTTP response from a ImageHealthWithResponse call
func ParseImageHealthResp(rsp *http.Response) (*ImageHealthResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ImageHealthResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SuccessResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetModlogResp parses an HTTP response from a GetModlogWithResponse call
func ParseGetModlogResp(rsp *http.Response) (*GetModlogResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetModlogResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetModlogResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAuthenticateWithOAuthResp parses an HTTP response from a AuthenticateWithOAuthWithResponse call
func ParseAuthenticateWithOAuthResp(rsp *http.Response) (*AuthenticateWithOAuthResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AuthenticateWithOAuthResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LoginResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateOAuthProviderResp parses an HTTP response from a CreateOAuthProviderWithResponse call
func ParseCreateOAuthProviderResp(rsp *http.Response) (*CreateOAuthProviderResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateOAuthProviderResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OAuthProvider
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseEditOAuthProviderResp parses an HTTP response from a EditOAuthProviderWithResponse call
func ParseEditOAuthProviderResp(rsp *http.Response) (*EditOAuthProviderResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EditOAuthProviderResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OAuthProvider
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteOAuthProviderResp parses an HTTP response from a DeleteOAuthProviderWithResponse call
func ParseDeleteOAuthProviderResp(rsp *http.Response) (*DeleteOAuthProviderResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteOAuthProviderResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SuccessResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetPersonDetailsResp parses an HTTP response from a GetPersonDetailsWithResponse call
func ParseGetPersonDetailsResp(rsp *http.Response) (*GetPersonDetailsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPersonDetailsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetPersonDetailsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListPersonContentResp parses an HTTP response from a ListPersonContentWithResponse call
func ParseListPersonContentResp(rsp *http.Response) (*ListPersonContentResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListPersonContentResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListPersonContentResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetPostResp parses an HTTP response from a GetPostWithResponse call
func ParseGetPostResp(rsp *http.Response) (*GetPostResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPostResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetPostResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreatePostResp parses an HTTP response from a CreatePostWithResponse call
func ParseCreatePostResp(rsp *http.Response) (*CreatePostResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreatePostResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PostResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseEditPostResp parses an HTTP response from a EditPostWithResponse call
func ParseEditPostResp(rsp *http.Response) (*EditPostResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EditPostResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PostResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeletePostResp parses an HTTP response from a DeletePostWithResponse call
func ParseDeletePostResp(rsp *http.Response) (*DeletePostResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeletePostResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PostResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseFeaturePostResp parses an HTTP response from a FeaturePostWithResponse call
func ParseFeaturePostResp(rsp *http.Response) (*FeaturePostResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FeaturePostResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PostResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseHidePostResp parses an HTTP response from a HidePostWithResponse call
func ParseHidePostResp(rsp *http.Response) (*HidePostResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &HidePostResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SuccessResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseLikePostResp parses an HTTP response from a LikePostWithResponse call
func ParseLikePostResp(rsp *http.Response) (*LikePostResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LikePostResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PostResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListPostLikesResp parses an HTTP response from a ListPostLikesWithResponse call
func ParseListPostLikesResp(rsp *http.Response) (*ListPostLikesResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListPostLikesResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListPostLikesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetPostsResp parses an HTTP response from a GetPostsWithResponse call
func ParseGetPostsResp(rsp *http.Response) (*GetPostsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPostsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetPostsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseLockPostResp parses an HTTP response from a LockPostWithResponse call
func ParseLockPostResp(rsp *http.Response) (*LockPostResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LockPostResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PostResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseMarkPostAsReadResp parses an HTTP response from a MarkPostAsReadWithResponse call
func ParseMarkPostAsReadResp(rsp *http.Response) (*MarkPostAsReadResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MarkPostAsReadResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SuccessResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseMarkManyPostAsReadResp parses an HTTP response from a MarkManyPostAsReadWithResponse call
func ParseMarkManyPostAsReadResp(rsp *http.Response) (*MarkManyPostAsReadResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MarkManyPostAsReadResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SuccessResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseRemovePostResp parses an HTTP response from a RemovePostWithResponse call
func ParseRemovePostResp(rsp *http.Response) (*RemovePostResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemovePostResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PostResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreatePostReportResp parses an HTTP response from a CreatePostReportWithResponse call
func ParseCreatePostReportResp(rsp *http.Response) (*CreatePostReportResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreatePostReportResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PostReportResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseResolvePostReportResp parses an HTTP response from a ResolvePostReportWithResponse call
func ParseResolvePostReportResp(rsp *http.Response) (*ResolvePostReportResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ResolvePostReportResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PostReportResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSavePostResp parses an HTTP response from a SavePostWithResponse call
func ParseSavePostResp(rsp *http.Response) (*SavePostResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SavePostResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PostResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetSiteMetadataResp parses an HTTP response from a GetSiteMetadataWithResponse call
func ParseGetSiteMetadataResp(rsp *http.Response) (*GetSiteMetadataResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSiteMetadataResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetSiteMetadataResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreatePrivateMessageResp parses an HTTP response from a CreatePrivateMessageWithResponse call
func ParseCreatePrivateMessageResp(rsp *http.Response) (*CreatePrivateMessageResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreatePrivateMessageResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PrivateMessageResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseEditPrivateMessageResp parses an HTTP response from a EditPrivateMessageWithResponse call
func ParseEditPrivateMessageResp(rsp *http.Response) (*EditPrivateMessageResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EditPrivateMessageResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PrivateMessageResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeletePrivateMessageResp parses an HTTP response from a DeletePrivateMessageWithResponse call
func ParseDeletePrivateMessageResp(rsp *http.Response) (*DeletePrivateMessageResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeletePrivateMessageResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PrivateMessageResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseMarkPrivateMessageAsReadResp parses an HTTP response from a MarkPrivateMessageAsReadWithResponse call
func ParseMarkPrivateMessageAsReadResp(rsp *http.Response) (*MarkPrivateMessageAsReadResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MarkPrivateMessageAsReadResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PrivateMessageResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreatePrivateMessageReportResp parses an HTTP response from a CreatePrivateMessageReportWithResponse call
func ParseCreatePrivateMessageReportResp(rsp *http.Response) (*CreatePrivateMessageReportResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreatePrivateMessageReportResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PrivateMessageReportResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseResolvePrivateMessageReportResp parses an HTTP response from a ResolvePrivateMessageReportWithResponse call
func ParseResolvePrivateMessageReportResp(rsp *http.Response) (*ResolvePrivateMessageReportResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ResolvePrivateMessageReportResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PrivateMessageReportResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListReportsResp parses an HTTP response from a ListReportsWithResponse call
func ParseListReportsResp(rsp *http.Response) (*ListReportsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListReportsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListReportsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseResolveObjectResp parses an HTTP response from a ResolveObjectWithResponse call
func ParseResolveObjectResp(rsp *http.Response) (*ResolveObjectResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ResolveObjectResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ResolveObjectResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSearchResp parses an HTTP response from a SearchWithResponse call
func ParseSearchResp(rsp *http.Response) (*SearchResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SearchResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetSiteResp parses an HTTP response from a GetSiteWithResponse call
func ParseGetSiteResp(rsp *http.Response) (*GetSiteResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSiteResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetSiteResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateSiteResp parses an HTTP response from a CreateSiteWithResponse call
func ParseCreateSiteResp(rsp *http.Response) (*CreateSiteResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateSiteResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SiteResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseEditSiteResp parses an HTTP response from a EditSiteWithResponse call
func ParseEditSiteResp(rsp *http.Response) (*EditSiteResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EditSiteResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SiteResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteSiteBannerResp parses an HTTP response from a DeleteSiteBannerWithResponse call
func ParseDeleteSiteBannerResp(rsp *http.Response) (*DeleteSiteBannerResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSiteBannerResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SuccessResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUploadSiteBannerResp parses an HTTP response from a UploadSiteBannerWithResponse call
func ParseUploadSiteBannerResp(rsp *http.Response) (*UploadSiteBannerResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UploadSiteBannerResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SuccessResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteSiteIconResp parses an HTTP response from a DeleteSiteIconWithResponse call
func ParseDeleteSiteIconResp(rsp *http.Response) (*DeleteSiteIconResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSiteIconResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SuccessResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUploadSiteIconResp parses an HTTP response from a UploadSiteIconWithResponse call
func ParseUploadSiteIconResp(rsp *http.Response) (*UploadSiteIconResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UploadSiteIconResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SuccessResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}
